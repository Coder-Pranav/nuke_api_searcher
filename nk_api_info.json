[
    {
        "absolute() (LinkableKnobInfo)": "absolute(self)\n\nsource\u00a0code\u00a0\n    \n\nReturns whether the values of this knob should be treated as absolute \n  or relative. This may be useful for positions.\n\nReturns: Boolean"
    }, 
    {
        "addOnCreate() (nuke.callbacks)": "addOnCreate(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n      Add code to execute when a node is created or undeleted\n\nsource\u00a0code"
    }, 
    {
        "altsep (posixpath)": "altsep = None"
    }, 
    {
        "accept() (PythonPanel)": "accept(self)"
    }, 
    {
        "addOnDestroy() (nuke.callbacks)": "addOnDestroy(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n      Add code to execute when a node is destroyed\n\nsource\u00a0code"
    }, 
    {
        "ALWAYS_SAVE (nuke)": "ALWAYS_SAVE = 1048576"
    }, 
    {
        "Accepted (DialogCode)": "values\n\n\n\nValue:\n\n{'Accepted': PySide.QtGui.QDialog.DialogCode.Accepted,\n 'Rejected': PySide.QtGui.QDialog.DialogCode.Rejected}"
    }, 
    {
        "addOnScriptClose() (nuke.callbacks)": "addOnScriptClose(call,\n        args=(),\n        kwargs={},\n        nodeClass='Root')\n      Add code to execute before a script is closed\n\nsource\u00a0code"
    }, 
    {
        "animation (nukescripts)": null
    }, 
    {
        "AColor_Knob (nuke)": null
    }, 
    {
        "addOnScriptLoad() (nuke.callbacks)": "addOnScriptLoad(call,\n        args=(),\n        kwargs={},\n        nodeClass='Root')\n      Add code to execute when a script is loaded\n\nsource\u00a0code"
    }, 
    {
        "animation() (Array_Knob)": "animation(self,\n        chan,\n        view)\n\n\u00a0\n    \n\nReturn the AnimationCurve for the  channel 'chan' and view 'view'. The\n  view argument is optional.\n\nParameters:\n\nchannel - The channel index.\nview - Optional view.\n\nReturns: AnimationCurve or None\nAnimationCurve or None."
    }, 
    {
        "activateInput() (ViewerWindow)": "activateInput(self,\n        input,\n        secondary=False)\n\n\u00a0\n    \n\nSet the given viewer input to be active - i. e. show its image in the \n  output window.\n\nParameters:\n\ninput - The viewer input number, starting with 0 for the first.  If the \n          input is not connected, a ValueError exception is raised.\nsecondary - True if the input should be connected as the secondary (wipe) \n          input, or False to connect it as the primary input (the default).\n\nReturns: None\nNone"
    }, 
    {
        "addOnScriptSave() (nuke.callbacks)": "addOnScriptSave(call,\n        args=(),\n        kwargs={},\n        nodeClass='Root')\n      Add code to execute before a script is saved\n\nsource\u00a0code"
    }, 
    {
        "animation() (nuke)": "animation(object,\n        *commands)\n\n\u00a0\n    \n\nDoes operations on an animation curve.\nThe following commands are supported:\n\n\nclear deletes all the keys from the animation.\n    \n\nerase index last_index removes all \n      keyframes between index and last_index\n    \n\nexpression newvalue returns or sets the \n      expression for the animation. The default is 'curve' or 'y' which \n      returns the interpolation of the keys.\n    \n\ngenerate start end increment field expression field \n      expression ... generates an animation with start, end, and\n      increment. Multiple field/expression pairs generate a keyframe. \n      Possible field commands are:\n      \n\nx sets the frame number for the next keyframe\n        \n\ny sets the keyframe value\n        \n\ndy sets the left slope\n        \n\nldy sets left and right slope to the same value\n        \n\nla and ra are the length of the slope handle in x \n          direction. A value of 1 generates a handle that is one third of \n          the distance to the next keyframe.\n        \n\n\n\nindex x returns the index of the last key with x \n      <= t, return -1 for none.\n    \n\nis_key return non-zero if there is a key with x == t. The \n      actual return value is the index+1.\n    \n\nmove field expression field expression \n      replaces all selected keys in an animation with new ones as explained\n      above in generate\n\n\nname returns a user-friendly name for this animation. This \n      will eliminate any common prefix between this animation and all other\n      selected ones, and also replaces mangled names returned by animations\n      with nice ones.\n    \n\nsize returns the number of keys in the animation.\n    \n\ntest errors if no points in the animation are selected\n    \n\ny index newvalue gets or sets the value of\n      an animation.\n    \n\nx index newvalue gets or sets the \n      horizontal postion of a key. If the animation contains an expression \n      or keyframes, the new value will be overridden.\n    \n\nSee also: animations\n\nParameters:\n\nobject - The animation curve.\ncommands - a varargs-style list of commands, where each command is one of \n          those defined above.\n\nReturns: None\nNone"
    }, 
    {
        "activeInput() (ViewerWindow)": "activeInput(self,\n        secondary=False)\n\n\u00a0\n    \n\nReturns the currently active input of the viewer - i. e. the one with \n  its image in the output window.\n\nParameters:\n\nsecondary - True to return the index of the active secondary (wipe) input, or\n          False (the default) to return the primary input.\n\nReturns: int\nint: The currently active input of the viewer, starting with 0 \n          for the first, or None if no input is active."
    }, 
    {
        "addOnUserCreate() (nuke.callbacks)": "addOnUserCreate(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n      Add code to execute when user creates a node\n\nsource\u00a0code"
    }, 
    {
        "animation_loop() (nukescripts.animation)": null
    }, 
    {
        "activeViewer() (nuke)": "activeViewer()\n\n\u00a0\n    \n\nReturn an object representing the active Viewer panel. This is not the\n  same as the Viewer node, this is the viewer UI element.\n\nReturns: ViewerWindow\nObject representing the active ViewerWindow"
    }, 
    {
        "addPanel() (nukescripts.pyQtExamples.webBrowser)": null
    }, 
    {
        "animation_move() (nukescripts.animation)": null
    }, 
    {
        "actualValue() (Format_Knob)": "actualValue()\n      Return value of knob."
    }, 
    {
        "addPasswordInput() (Panel)": "addPasswordInput(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a password input knob to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "animation_negate() (nukescripts.animation)": null
    }, 
    {
        "add() (CurveWidget)": "add(self)\n      Add a new group layer under the selected item's parent"
    }, 
    {
        "addPivotPointKey() (AnimCTransform)": "addPivotPointKey(self,\n        time,\n        x,\n        y,\n        pressure,\n        view='default')"
    }, 
    {
        "animation_reverse() (nukescripts.animation)": null
    }, 
    {
        "add() (AnimAttributes)": "add(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a new attribute. The name parameter is the name for the attribute \n  and value is the initial int or float value to assign to it.\n\nReturns: None"
    }, 
    {
        "addPoint() (CorrespondencePoints)": "addPoint(cps,\n        time,\n        t_src,\n        t_dest)\n\n\u00a0\n    \n\nAdds a correspondence point\n\nParameters:\n\ntime - Time at which to t_src and t_dest will be set\nt_src - Position on the source curve (where 0=start and 1=end)\nt_dest - Position on the destination curve"
    }, 
    {
        "AnimationCurve (nuke)": null
    }, 
    {
        "add() (Format)": "add(self,\n        name)\n\n\u00a0\n    \n\nAdd this instance to a list of \"named\" formats. The name \n  parameter is the name of the list to add the format to.\n\nReturns: None"
    }, 
    {
        "addPositionKey() (AnimControlPoint)": "addPositionKey(self,\n        time,\n        positionOrDim,\n        view)\n\n\u00a0\n    \n\nAdds a new key to the control point's timeline. positionOrDim can \n  either be a vector or a single scalar that specifies which component \n  (xyzw) to add a key for.\n\nReturns: None"
    }, 
    {
        "animationEnd() (nuke)": "animationEnd()\n\n\u00a0\n    \n\nReturns the last frame (or x value) for the currently selected \n  animations.\n\nReturns: float\nThe end frame."
    }, 
    {
        "add() (FrameRanges)": "add(r)\n      add a new frame range."
    }, 
    {
        "addRGBColorChip() (Panel)": "addRGBColorChip(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a color chooser to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "animationIncrement() (nuke)": "animationIncrement()\n\n\u00a0\n    \n\nReturns a recommended interval between samples of the currently \n  selected animation.\n\nReturns: float\nThe recommended interval."
    }, 
    {
        "add() (VertexSelection)": null
    }, 
    {
        "addRotationKey() (AnimCTransform)": "addRotationKey(self,\n        time,\n        x,\n        y,\n        pressure,\n        view='default')"
    }, 
    {
        "AnimationKey (nuke)": null
    }, 
    {
        "addAfterBackgroundFrameRender() (nuke.callbacks)": "addAfterBackgroundFrameRender(call,\n        args=(),\n        kwargs={})\n\nsource\u00a0code\u00a0\n    \n\n\nAdd code to execute after each frame of a background render.\nThe call must be in the form of:\ndef foo(context):\n  pass\n\nThe context object that will be passed in is a dictionary containing the following elements:\nid => The identifier for the task that's making progress\nframe => the current frame number being rendered\nnumFrames => the total number of frames that is being rendered\nframeProgress => the number of frames rendered so far.\n\nPlease be aware that the current Nuke context will not make sense in the callback (e.g. nuke.thisNode will return a random node)."
    }, 
    {
        "addScaleKey() (AnimCTransform)": "addScaleKey(self,\n        time,\n        x,\n        y,\n        pressure,\n        view='default')"
    }, 
    {
        "animations() (Array_Knob)": "animations(self,\n        view)\n\n\u00a0\n    \n\n\nParameters:\n\nview - Optional view.\n\nReturns: AnimationCurve list\nAnimationCurve list. Example: b = nuke.nodes.Blur() k = b['size']\n          k.setAnimated(0) a = k.animations() a[0].setKey(0, 11) \n          a[0].setKey(10, 20)"
    }, 
    {
        "addAfterBackgroundRender() (nuke.callbacks)": "addAfterBackgroundRender(call,\n        args=(),\n        kwargs={})\n\nsource\u00a0code\u00a0\n    \n\n\nAdd code to execute after any background renders.\nThe call must be in the form of:\ndef foo(context):\n  pass\n\nThe context object that will be passed in is a dictionary containing the following elements:\nid => The identifier for the task that's ended\n\nPlease be aware that the current Nuke context will not make sense in the callback (e.g. nuke.thisNode will return a random node)."
    }, 
    {
        "addScriptCommand() (Panel)": "addScriptCommand(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a script command evaluator to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "animations() (nuke)": "animations()\n\n\u00a0\n    \n\nReturns a list of animatable things the user wants to work on.\nIf this is a command being executed from a menu item in a curve \n  editor, a list of the names of all selected curves is returned. If this \n  list is empty a \"No curves selected\" error is produced.\nIf this is a command being executed from the pop-up list in a knob \n  then a list of all the fields in the knob is returned.\nIf this is a command being executed from the right-mouse-button pop-up\n  list in a field of a knob, the name of that field is returned.\nOtherwise this produces an error indicating that the command requries \n  a knob context. You can get such a context by doing \"in <knob>\n  {command}\"\nAlso see the 'selected' argument to the animation command.\nSee also: animation, animationStart, animationEnd, \n  animationIncrement\n\nReturns: tuple\nA tuple of animatable things."
    }, 
    {
        "addAfterFrameRender() (nuke.callbacks)": "addAfterFrameRender(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n      Add code to execute after each frame of a render\n\nsource\u00a0code"
    }, 
    {
        "addSeparator() (Menu)": "addSeparator(self,\n        **kwargs)\n\n\u00a0\n    \n\nAdd a separator to this menu/toolbar.\n\nParameters:\n\n**kwargs, The, following, keyword, arguments, are, accepted - index     The position to insert the new separator in, in the \n          menu/toolbar.\n\nReturns: The separator that was created\nThe separator that was created."
    }, 
    {
        "animationStart() (nuke)": "animationStart()\n\n\u00a0\n    \n\nReturns the starting frame (or x value) for the currently selected \n  animations.\n\nReturns: float\nThe start frame."
    }, 
    {
        "addAfterRender() (nuke.callbacks)": "addAfterRender(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n      Add code to execute after any renders\n\nsource\u00a0code"
    }, 
    {
        "addSeparator() (MenuBar)": "addSeparator(self,\n        **kwargs)\n\n\u00a0\n    \n\nAdd a separator to this menu/toolbar.\n\nParameters:\n\n**kwargs, The, following, keyword, arguments, are, accepted - index     The position to insert the new separator in, in the \n          menu/toolbar.\n\nReturns: The separator that was created\nThe separator that was created."
    }, 
    {
        "AnimAttributes (_curvelib)": null
    }, 
    {
        "addAutolabel() (nuke.callbacks)": "addAutolabel(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n\nsource\u00a0code\u00a0\n    \n\nAdd code to execute on every node to produce the text to draw on it in\n  the DAG. Any value other than None is converted to a string and used as \n  the text. None indicates that previously-added functions should be \n  tried"
    }, 
    {
        "addSeparator() (ToolBar)": "addSeparator(self,\n        **kwargs)\n\n\u00a0\n    \n\nAdd a separator to this menu/toolbar.\n\nParameters:\n\n**kwargs, The, following, keyword, arguments, are, accepted - index     The position to insert the new separator in, in the \n          menu/toolbar.\n\nReturns: The separator that was created\nThe separator that was created."
    }, 
    {
        "AnimControlPoint (_curvelib)": null
    }, 
    {
        "addAutoSaveDeleteFilter() (nuke.callbacks)": "addAutoSaveDeleteFilter(filter)\n\nsource\u00a0code\u00a0\n    \n\nAdd a function to modify the autosave filename before Nuke attempts \n  delete the autosave file.\nLook at rollingAutoSave.py in the nukescripts directory for an example\n  of using the auto save filters.\n\nParameters:\n\nfilter - A filter function.  The first argument to the filter is the \n          current autosave filename. This function should return the \n          filename to delete or return None if no file should be deleted.\n\nReturns: None"
    }, 
    {
        "addSequenceFileExtension() (nuke)": "addSequenceFileExtension(fileExtension)\n\n\u00a0\n    \n\nAdds the input file extension to the list of extensions that will get \n  displayed as sequences in the file browser.\n\nParameters:\n\nfileExtension, the, new, file, extension., Valid, examples, are - 'exr', '.jpg'; invalid examples are: 'somefile.ext'"
    }, 
    {
        "AnimCTransform (_curvelib)": null
    }, 
    {
        "addAutoSaveFilter() (nuke.callbacks)": "addAutoSaveFilter(filter)\n\nsource\u00a0code\u00a0\n    \n\nAdd a function to modify the autosave filename before Nuke saves the \n  current script on an autosave timeout.\nLook at rollingAutoSave.py in the nukescripts directory for an example\n  of using the auto save filters.\n\nParameters:\n\nfilter - A filter function.  The first argument to the filter is the \n          current autosave filename. The filter should return the filename \n          to save the autosave to.\n\nReturns: None"
    }, 
    {
        "addSingleLineInput() (Panel)": "addSingleLineInput(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a single-line input knob to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "AnimCurve (_curvelib)": null
    }, 
    {
        "addAutoSaveRestoreFilter() (nuke.callbacks)": "addAutoSaveRestoreFilter(filter)\n\nsource\u00a0code\u00a0\n    \n\nAdd a function to modify the autosave restore file before Nuke \n  attempts to restores the autosave file.\nLook at rollingAutoSave.py in the nukescripts directory for an example\n  of using the auto save filters.\n\nParameters:\n\nfilter - A filter function.  The first argument to the filter is the \n          current autosave filename. This function should return the \n          filename to load autosave from or it should return None if the \n          autosave file should be ignored.\n\nReturns: None"
    }, 
    {
        "addSkewXKey() (AnimCTransform)": "addSkewXKey(self,\n        time,\n        x,\n        y,\n        pressure,\n        view='default')"
    }, 
    {
        "AnimCurveKey (_curvelib)": null
    }, 
    {
        "addBeforeBackgroundRender() (nuke.callbacks)": "addBeforeBackgroundRender(call,\n        args=(),\n        kwargs={})\n\nsource\u00a0code\u00a0\n    \n\n\nAdd code to execute before starting any background renders. \nThe call must be in the form of:\ndef foo(context):\n  pass\n\nThe context object that will be passed in is a dictionary containing the following elements:\nid => The identifier for the task that's about to begin\n\nPlease be aware that the current Nuke context will not make sense in the callback (e.g. nuke.thisNode will return a random node)."
    }, 
    {
        "addSnapFunc() (nukescripts.snap3d)": "addSnapFunc(label,\n        func)\n\nsource\u00a0code\u00a0\n    \n\nAdd a new snapping function to the list.\nThe label parameter is the text that will appear in (eg.) an \n  Enumeration_Knob for the function. It cannot be the same as any existing \n  snap function label (if it is, the function will abort without changing \n  anything).\nThe func parameter is the snapping function. It must be a callable \n  object taking a single parameter: the node to perform the snapping \n  on.\n\nReturns: None"
    }, 
    {
        "AnimCurveViews (_curvelib)": null
    }, 
    {
        "addBeforeFrameRender() (nuke.callbacks)": "addBeforeFrameRender(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n      Add code to execute before each frame of a render\n\nsource\u00a0code"
    }, 
    {
        "addTextFontPulldown() (Panel)": "addTextFontPulldown(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a font chooser to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "anySelectedPoint() (nukescripts.snap3d)": "anySelectedPoint(selectionThreshold=0.5)\n\nsource\u00a0code\u00a0\n    \n\nReturn a selected point from the active viewer or the first viewer \n  with a selection. The selectionThreshold parameter is used when working \n  with a soft selection. Only points with a selection level >= the \n  selection threshold will be returned by this function.\n\nReturns: _nukemath.Vector3"
    }, 
    {
        "addBeforeRender() (nuke.callbacks)": "addBeforeRender(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n      Add code to execute before starting any renders\n\nsource\u00a0code"
    }, 
    {
        "addToolsetExcludePaths() (nuke)": "addToolsetExcludePaths(paths)\n\n\u00a0\n    \n\n@param paths Sequence of paths to exclude Adds a list of paths that \n  will be excluded from Toolset search paths.\n\nReturns: None\nNone."
    }, 
    {
        "anySelectedVertexInfo() (nukescripts.snap3d)": "anySelectedVertexInfo(selectionThreshold=0.5)\n\nsource\u00a0code\u00a0\n    \n\nReturns a single VertexInfo for a selected point. If more than one \n  point is selected, one of them will be chosen arbitrarily.\nThe selectionThreshold parameter is used when working with a soft \n  selection. Only points with a selection level >= the selection \n  threshold will be returned by this function.\n\nReturns: VertexInfo"
    }, 
    {
        "addBooleanCheckBox() (Panel)": "addBooleanCheckBox(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a boolean check box knob to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "addToolsetsPanel() (nukescripts.toolsets)": null
    }, 
    {
        "api_version (sys)": "api_version = 1013"
    }, 
    {
        "addButton() (Panel)": "addButton(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a button to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "addToPane() (PythonPanel)": "addToPane(self,\n        pane=None)"
    }, 
    {
        "append() (Layer)": "append(self,\n        element)\n\n\u00a0\n    \n\nAdd a new element inside this layer. The element must be an instance \n  of either the Shape, Stroke or Layer classes. Note that an element cannot\n  be in more than one place in the tree, so if you try to add an element \n  that is already in the tree somewhere else, it'll be removed from its old\n  location first.\n\nReturns: None"
    }, 
    {
        "addCallback() (PythonPanel)": "addCallback(self)"
    }, 
    {
        "addToPane() (ExecuteDialog)": null
    }, 
    {
        "append() (Shape)": "append(self,\n        shapeControlPoint)\n\n\u00a0\n    \n\nAdd a new control point to the shape. The shapeControlPoint parameter \n  must be either an instance of the ShapeControlPoint class, or something \n  we can convert to a ShapeControlPoint. This includes a sequence of 2, 3 \n  or 4 floats; a CVec2, CVec3 or CVec4 object; or an AnimControlPoint \n  object.\n\nReturns: None"
    }, 
    {
        "addClipnameSearch() (Panel)": "addClipnameSearch(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a clipname search knob to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "addToPane() (LinkToTrackPanel)": null
    }, 
    {
        "append() (Stroke)": "append(self,\n        controlPoint)\n\n\u00a0\n    \n\nAdd a new control point to the stroke. The controlPoint parameter must\n  be either an instance of the AnimControlPoint class, or something we can \n  convert to an AnimControlPoint. This includes a sequence of 2, 3 or 4 \n  floats; or a CVec2, CVec3 or CVec4 object.\n\nReturns: None"
    }, 
    {
        "addCommand() (Menu)": "addCommand(self,\n        name,\n        command,\n        shortcut,\n        icon,\n        tooltip,\n        index,\n        readonly)\n\n\u00a0\n    \n\nAdd a new command to this menu/toolbar. Note that when invoked, the \n  command is automatically enclosed in an undo group, so that undo/redo \n  functionality works. Optional arguments can be specified by name. Note \n  that if the command argument is not specified, then the command will be \n  auto-created as a \"nuke.createNode()\" using the name argument \n  as the node to create.\nExample: menubar = nuke.menu('Nuke') fileMenu = \n  menubar.findItem('File') fileMenu.addCommand('NewCommand', 'print 10', \n  shortcut='t')\n\nParameters:\n\nname - The name for the menu/toolbar item. The name may contain submenu \n          names delimited by '/' or '', and submenus are created as needed.\ncommand - Optional. The command to add to the menu/toolbar. This can be a \n          string to evaluate or a Python Callable (function, method, etc) \n          to run.\nshortcut - Optional. The keyboard shortcut for the command, such as 'R', \n          'F5' or 'Ctrl-H'. Note that this overrides pre-existing other \n          uses for the shortcut.\nicon - Optional. An icon for the command. This should be a path to an \n          icon in the nuke.pluginPath() directory. If the icon is not \n          specified, Nuke will automatically try to find an icon with the \n          name argument and .png appended to it.\ntooltip - Optional. The tooltip text, displayed on mouseover for toolbar \n          buttons.\nindex - Optional. The position to insert the new item in, in the \n          menu/toolbar. This defaults to last in the menu/toolbar.\nreadonly - Optional. True/False for whether the item should be available \n          when the menu is invoked in a read-only context.\n\nReturns: The menu/toolbar item that was added to hold the command\nThe menu/toolbar item that was added to hold the command."
    }, 
    {
        "addTransformKey() (AnimCTransform)": "addTransformKey(self,\n        time,\n        view)"
    }, 
    {
        "applyPreset() (nuke)": "applyPreset(nodeName,\n        presetName)\n\n\u00a0\n    \n\nApplies a given preset to the current node.\n\nParameters:\n\npresetName - Name of the preset to use.\n\nReturns: None\nbool."
    }, 
    {
        "addCommand() (MenuBar)": "addCommand(self,\n        name,\n        command,\n        shortcut,\n        icon,\n        tooltip,\n        index,\n        readonly)\n\n\u00a0\n    \n\nAdd a new command to this menu/toolbar. Note that when invoked, the \n  command is automatically enclosed in an undo group, so that undo/redo \n  functionality works. Optional arguments can be specified by name. Note \n  that if the command argument is not specified, then the command will be \n  auto-created as a \"nuke.createNode()\" using the name argument \n  as the node to create.\nExample: menubar = nuke.menu('Nuke') fileMenu = \n  menubar.findItem('File') fileMenu.addCommand('NewCommand', 'print 10', \n  shortcut='t')\n\nParameters:\n\nname - The name for the menu/toolbar item. The name may contain submenu \n          names delimited by '/' or '', and submenus are created as needed.\ncommand - Optional. The command to add to the menu/toolbar. This can be a \n          string to evaluate or a Python Callable (function, method, etc) \n          to run.\nshortcut - Optional. The keyboard shortcut for the command, such as 'R', \n          'F5' or 'Ctrl-H'. Note that this overrides pre-existing other \n          uses for the shortcut.\nicon - Optional. An icon for the command. This should be a path to an \n          icon in the nuke.pluginPath() directory. If the icon is not \n          specified, Nuke will automatically try to find an icon with the \n          name argument and .png appended to it.\ntooltip - Optional. The tooltip text, displayed on mouseover for toolbar \n          buttons.\nindex - Optional. The position to insert the new item in, in the \n          menu/toolbar. This defaults to last in the menu/toolbar.\nreadonly - Optional. True/False for whether the item should be available \n          when the menu is invoked in a read-only context.\n\nReturns: The menu/toolbar item that was added to hold the command\nThe menu/toolbar item that was added to hold the command."
    }, 
    {
        "addTranslationKey() (AnimCTransform)": "addTranslationKey(self,\n        time,\n        x,\n        y,\n        pressure,\n        view='default')"
    }, 
    {
        "applyUserPreset() (nuke)": "applyUserPreset(nodeName,\n        presetName)\n\n\u00a0\n    \n\nApplies a given user preset to the current node.\n\nParameters:\n\npresetName - Name of the preset to use.\n\nReturns: None\nbool."
    }, 
    {
        "addCommand() (ToolBar)": "addCommand(self,\n        name,\n        command,\n        shortcut,\n        icon,\n        tooltip,\n        index,\n        readonly)\n\n\u00a0\n    \n\nAdd a new command to this menu/toolbar. Note that when invoked, the \n  command is automatically enclosed in an undo group, so that undo/redo \n  functionality works. Optional arguments can be specified by name. Note \n  that if the command argument is not specified, then the command will be \n  auto-created as a \"nuke.createNode()\" using the name argument \n  as the node to create.\nExample: menubar = nuke.menu('Nuke') fileMenu = \n  menubar.findItem('File') fileMenu.addCommand('NewCommand', 'print 10', \n  shortcut='t')\n\nParameters:\n\nname - The name for the menu/toolbar item. The name may contain submenu \n          names delimited by '/' or '', and submenus are created as needed.\ncommand - Optional. The command to add to the menu/toolbar. This can be a \n          string to evaluate or a Python Callable (function, method, etc) \n          to run.\nshortcut - Optional. The keyboard shortcut for the command, such as 'R', \n          'F5' or 'Ctrl-H'. Note that this overrides pre-existing other \n          uses for the shortcut.\nicon - Optional. An icon for the command. This should be a path to an \n          icon in the nuke.pluginPath() directory. If the icon is not \n          specified, Nuke will automatically try to find an icon with the \n          name argument and .png appended to it.\ntooltip - Optional. The tooltip text, displayed on mouseover for toolbar \n          buttons.\nindex - Optional. The position to insert the new item in, in the \n          menu/toolbar. This defaults to last in the menu/toolbar.\nreadonly - Optional. True/False for whether the item should be available \n          when the menu is invoked in a read-only context.\n\nReturns: The menu/toolbar item that was added to hold the command\nThe menu/toolbar item that was added to hold the command."
    }, 
    {
        "addUdimFile() (UDIMOptionsDialog)": "addUdimFile(self,\n        udim_file)\n\nsource\u00a0code"
    }, 
    {
        "argv (sys)": "argv\n\n\n\nValue:\n\n['Resources/Apps/Nuke/Docs/src/nuke_epydoc.py',\n '--config',\n 'Resources/Apps/Nuke/Docs/src/nuke_epydoc.cfg',\n '-o',\n '/tmp/tmpCZJ9PX',\n '--debug',\n '--simple-term']"
    }, 
    {
        "addControlPoint() (AnimControlPoint)": "addControlPoint(self,\n        controlPoint)"
    }, 
    {
        "addUpdateUI() (nuke.callbacks)": "addUpdateUI(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n\nsource\u00a0code\u00a0\n    \n\nAdd code to execute on every node when things change. This is done \n  during idle, you cannot rely on it being done before it starts updating \n  the viewer"
    }, 
    {
        "array() (Array_Knob)": "array(self)\n\n\u00a0\n    \n\n\nReturns: List of knob values\nList of knob values."
    }, 
    {
        "addCurve() (LookupCurves_Knob)": "addCurve(self,\n        curve,\n        expr=None)\n\n\u00a0\n    \n\nAdds a curve.\n\nParameters:\n\ncurve - The name of an animation curve, or an AnimationCurve instance.\nexpr - Optional parameter giving an expression for the curve.\n\nReturns: None\nNone"
    }, 
    {
        "addValidateFilename() (nuke.callbacks)": "addValidateFilename(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n\nsource\u00a0code\u00a0\n    \n\nAdd a function to validate a filename in Write nodes. The first \n  argument is the filename and it should return a Boolean as to whether the\n  filename is valid or not. If a callback is provided, it will control \n  whether the Render button of Write nodes and the Execute button of \n  WriteGeo nodes is enabled or not."
    }, 
    {
        "Array_Knob (nuke)": null
    }, 
    {
        "addDropDataCallback() (nukescripts.drop)": "addDropDataCallback(callback)\n\nsource\u00a0code\u00a0\n    \n\nAdd a function to the list of callbacks. This function will called \n  whenever data is dropped onto the DAG. Override it to perform other \n  actions. If you handle the drop, return True, otherwise return None."
    }, 
    {
        "addView() (Root)": "addView(self,\n        s)\n\n\u00a0\n    \n\nAdd view.\n\nParameters:\n\ns - Name of view.\n\nReturns: None\nNone."
    }, 
    {
        "arraySize() (Array_Knob)": "arraySize(self)\n\n\u00a0\n    \n\n\nReturns: Number of elements in array\nNumber of elements in array."
    }, 
    {
        "addEnumerationPulldown() (Panel)": "addEnumerationPulldown(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a pulldown menu to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "addView() (nuke)": "addView(s)\n\n\u00a0\n    \n\nDeprecated. Use the Root node.\nAdds a new view to the list of views.\n\nParameters:\n\ns - View name.\n\nReturns: None\nNone"
    }, 
    {
        "ask() (nuke)": "ask(prompt)\n\n\u00a0\n    \n\nShow a Yes/No dialog.\n\nParameters:\n\nprompt - Present the user with this message.\n\nReturns: bool\nTrue if Yes, False otherwise."
    }, 
    {
        "addExpressionInput() (Panel)": "addExpressionInput(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd an expression evaluator to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "AFTER_CONST (nuke)": "AFTER_CONST = 21"
    }, 
    {
        "askUserForOptions() (PrecompOptions)": null
    }, 
    {
        "addFavoriteDir() (nuke)": "addFavoriteDir(name,\n        directory,\n        type,\n        icon,\n        tooltip,\n        key)\n\n\u00a0\n    \n\nAdd a path to the file choosers favorite directory list. The path name\n  can contain environment variables which will be expanded when the user \n  clicks the favourites button\n\nParameters:\n\nname - Favourite path entry ('Home', 'Desktop', etc.).\ndirectory - FileChooser will change to this directory path.\ntype - Optional bitwise OR combination of nuke.IMAGE, nuke.SCRIPT, \n          nuke.FONT or nuke.GEO.\nicon - Optional filename of an image to use as an icon.\ntooltip - Optional short text to explain the path and the meaning of the \n          name.\nkey - Optional shortcut key.\n\nReturns: None\nNone."
    }, 
    {
        "AFTER_LINEAR (nuke)": "AFTER_LINEAR = 22"
    }, 
    {
        "autobackdrop (nukescripts)": null
    }, 
    {
        "addFilenameFilter() (nuke.callbacks)": "addFilenameFilter(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n\nsource\u00a0code\u00a0\n    \n\nAdd a function to modify filenames before Nuke passes them to the \n  operating system. The first argument to the function is the filename, and\n  it should return the new filename. None is the same as returning the \n  string unchanged. All added functions are called in backwards order."
    }, 
    {
        "afterBackgroundFrameRender() (nuke.callbacks)": "afterBackgroundFrameRender(context)\n\nsource\u00a0code"
    }, 
    {
        "autoBackdrop() (nukescripts.autobackdrop)": "autoBackdrop()\n\nsource\u00a0code\u00a0\n    \n\nAutomatically puts a backdrop behind the selected nodes.\nThe backdrop will be just big enough to fit all the select nodes in, \n  with room at the top for some text in a large font."
    }, 
    {
        "addFilenameSearch() (Panel)": "addFilenameSearch(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a filename search knob to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "afterBackgroundFrameRenders (nuke)": "afterBackgroundFrameRenders = []"
    }, 
    {
        "autocrop() (nukescripts.crop)": "autocrop(first=None,\n        last=None,\n        inc=None,\n        layer='rgba')\n\nsource\u00a0code\u00a0\n    \n\nRun the CurveTool's AutoCrop function on each selected node over the \n  specified frame range and channels. If the range values are None, the \n  project first_frame and last_frame are used; if inc is None, 1 is used. \n  After execution, the CurveTool AutoCrop results are copied into a Crop \n  node attached to each selected node."
    }, 
    {
        "addFormat() (nuke)": "addFormat(s)\n\n\u00a0\n    \n\nCreate a new image format, which will show up on the pull-down menus \n  for image formats. You must give a width and height and name. The xyrt \n  rectangle describes the image area, if it is smaller than the width and \n  height (for Academy aperture, for example). The pixel aspect is the ratio\n  of the width of a pixel to the height.\n\nParameters:\n\ns - String in TCL format \"w h ?x y r t? ?pa? name\".\n\nReturns: Format or None\nFormat or None."
    }, 
    {
        "afterBackgroundFrameRenders (nuke.callbacks)": "afterBackgroundFrameRenders = []"
    }, 
    {
        "autolabel() (nuke.callbacks)": "autolabel()\n\nsource\u00a0code"
    }, 
    {
        "addItem() (pyQtRenderDialog)": "addItem(self,\n        n)\n\nsource\u00a0code"
    }, 
    {
        "afterBackgroundRender() (nuke.callbacks)": "afterBackgroundRender(context)\n\nsource\u00a0code"
    }, 
    {
        "autolabels (nuke)": "autolabels = {}"
    }, 
    {
        "addItems() (SceneView_Knob)": "addItems(self)\n\n\u00a0\n    \n\nAdds a list of string items to the knob. New items are automatically \n  set as imported and selected.\n\nReturns: None"
    }, 
    {
        "afterBackgroundRenders (nuke)": "afterBackgroundRenders = []"
    }, 
    {
        "autolabels (nuke.callbacks)": "autolabels = {}"
    }, 
    {
        "addKey() (AnimAttributes)": "addKey(self,\n        time,\n        name,\n        value,\n        view)\n\n\u00a0\n    \n\nself.addKey(time, view) -> None When a name and value is specified,\n  this method adds a new key to an existing attribute at the given time. \n  When the name and value are omitted, a new key is added to all attributes\n  at the specified time. The view parameter is optional in either case.\n\nReturns: None"
    }, 
    {
        "afterBackgroundRenders (nuke.callbacks)": "afterBackgroundRenders = []"
    }, 
    {
        "autoplace() (Node)": "autoplace(self)\n\n\u00a0\n    \n\nAutomatically place nodes, so they do not overlap.\n\nReturns: None\nNone."
    }, 
    {
        "addKey() (AnimControlPoint)": "addKey(self,\n        time,\n        controlPointOrDim,\n        view)"
    }, 
    {
        "afterFrameRender() (nuke.callbacks)": "afterFrameRender()\n\nsource\u00a0code"
    }, 
    {
        "autoplace() (nuke)": "autoplace(n)\n\n\u00a0\n    \n\nDeprecated. Use Node.autoplace.\nAutomatically place nodes, so they do not overlap.\n\nParameters:\n\nn - Node.\n\nReturns: None\nNone"
    }, 
    {
        "addKey() (AnimCurve)": "addKey(self,\n        time,\n        value)\n\n\u00a0\n    \n\nself.addKey(keyObj) -> None Add a new key to this curve. You can \n  pass in either a time and value pair (the value parameter is optional), \n  or an AnimCurveKey object you've created yourself. In the former case, a \n  new AnimCurveKey object will be created and added to the curve; in the \n  latter case, the key you pass in will be added directly.\n\nReturns: None"
    }, 
    {
        "afterFrameRenders (nuke)": "afterFrameRenders = {}"
    }, 
    {
        "autoplaceSnap() (nuke)": "autoplaceSnap(n)\n\n\u00a0\n    \n\nMove node to the closest grid position.\n\nParameters:\n\nn - Node.\n\nReturns: None\nNone"
    }, 
    {
        "addKey() (AnimationCurve)": "addKey(self,\n        keys)\n\n\u00a0\n    \n\nInsert a sequence of keys.\n\nParameters:\n\nkeys - Sequence of AnimationKey.\n\nReturns: None\nNone."
    }, 
    {
        "afterFrameRenders (nuke.callbacks)": "afterFrameRenders = {}"
    }, 
    {
        "autoSaveDeleteFilter() (nuke.callbacks)": "autoSaveDeleteFilter(filename)\n\nsource\u00a0code\u00a0\n    \n\nInternal function.  Use addAutoSaveDeleteFilter to add a callback"
    }, 
    {
        "addKnob() (Node)": "addKnob(self,\n        k)\n\n\u00a0\n    \n\nAdd knob k to this node or panel.\n\nParameters:\n\nk - Knob.\n\nReturns: None\nNone."
    }, 
    {
        "afterRender() (nuke.callbacks)": "afterRender()\n\nsource\u00a0code"
    }, 
    {
        "autoSaveDeleteFilters (nuke)": "autoSaveDeleteFilters\n\n\n\nValue:\n\n{'Root': [(<function onAutoSaveDelete at 0x7f9c4da079b0>,\n           (),\n           {},\n           None)]}"
    }, 
    {
        "addKnob() (PanelNode)": "addKnob(self,\n        k)\n\n\u00a0\n    \n\nAdd knob k to this node or panel.\n\nParameters:\n\nk - Knob.\n\nReturns: None\nNone."
    }, 
    {
        "afterRenders (nuke)": "afterRenders = {}"
    }, 
    {
        "autoSaveDeleteFilters (nuke.callbacks)": "autoSaveDeleteFilters\n\n\n\nValue:\n\n{'Root': [(<function onAutoSaveDelete at 0x7f9c4da079b0>,\n           (),\n           {},\n           None)]}"
    }, 
    {
        "addKnob() (PythonPanel)": "addKnob(self,\n        knob)"
    }, 
    {
        "afterRenders (nuke.callbacks)": "afterRenders = {}"
    }, 
    {
        "autoSaveFilter() (nuke.callbacks)": "autoSaveFilter(filename)\n\nsource\u00a0code\u00a0\n    \n\nInternal function.  Use addAutoSaveFilter to add a callback"
    }, 
    {
        "addKnob() (ExecuteDialog)": null
    }, 
    {
        "ALL (nuke)": "ALL = 1"
    }, 
    {
        "autoSaveFilters (nuke)": "autoSaveFilters\n\n\n\nValue:\n\n{'Root': [(<function onAutoSave at 0x7f9c4da07668>, (), {}, None)]}"
    }, 
    {
        "addKnobChanged() (nuke.callbacks)": "addKnobChanged(call,\n        args=(),\n        kwargs={},\n        nodeClass='*',\n        node=None)\n\nsource\u00a0code\u00a0\n    \n\nAdd code to execute when the user changes a knob The knob is availble \n  in nuke.thisKnob() and the node in nuke.thisNode(). This is also called \n  with dummy knobs when the control panel is opened or when the inputs to \n  the node changes. The purpose is to update other knobs in the control \n  panel. Use addUpdateUI() for changes that should happen even when the \n  panel is closed."
    }, 
    {
        "all_plugins (nukescripts)": null
    }, 
    {
        "autoSaveFilters (nuke.callbacks)": "autoSaveFilters\n\n\n\nValue:\n\n{'Root': [(<function onAutoSave at 0x7f9c4da07668>, (), {}, None)]}"
    }, 
    {
        "addMenu() (Menu)": "addMenu(self,\n        **kwargs)\n\n\u00a0\n    \n\nAdd a new submenu.\n\nParameters:\n\n**kwargs, The, following, keyword, arguments, are, accepted - name      The name for the menu/toolbar item icon      An icon \n          for the menu. Loaded from the nuke search path. tooltip   The \n          tooltip text. index     The position to insert the menu in. Use \n          -1 to add to the end of the menu.\n\nReturns: The submenu that was added\nThe submenu that was added."
    }, 
    {
        "allign_nodes() (nukescripts.udim)": "allign_nodes(nodes,\n        base)\n\nsource\u00a0code"
    }, 
    {
        "autoSaveRestoreFilter() (nuke.callbacks)": "autoSaveRestoreFilter(filename)\n\nsource\u00a0code\u00a0\n    \n\nInternal function.  Use addAutoSaveRestoreFilter to add a callback"
    }, 
    {
        "addMenu() (MenuBar)": "addMenu(self,\n        **kwargs)\n\n\u00a0\n    \n\nAdd a new submenu.\n\nParameters:\n\n**kwargs, The, following, keyword, arguments, are, accepted - name      The name for the menu/toolbar item icon      An icon \n          for the menu. Loaded from the nuke search path. tooltip   The \n          tooltip text. index     The position to insert the menu in. Use \n          -1 to add to the end of the menu.\n\nReturns: The submenu that was added\nThe submenu that was added."
    }, 
    {
        "allKnobs() (Node)": "allKnobs(self)\n\n\u00a0\n    \n\nGet a list of all knobs in this node, including nameless knobs.\nFor example:\n\n>>> b = nuke.nodes.Blur()\n>>> b.allKnobs()\n\nReturns: dict\nList of all knobs.\n          Note that this doesn't follow the links for Link_Knobs"
    }, 
    {
        "autoSaveRestoreFilters (nuke)": "autoSaveRestoreFilters\n\n\n\nValue:\n\n{'Root': [(<function onAutoSaveRestore at 0x7f9c4da076e0>,\n           (),\n           {},\n           None)]}"
    }, 
    {
        "addMenu() (ToolBar)": "addMenu(self,\n        **kwargs)\n\n\u00a0\n    \n\nAdd a new submenu.\n\nParameters:\n\n**kwargs, The, following, keyword, arguments, are, accepted - name      The name for the menu/toolbar item icon      An icon \n          for the menu. Loaded from the nuke search path. tooltip   The \n          tooltip text. index     The position to insert the menu in. Use \n          -1 to add to the end of the menu.\n\nReturns: The submenu that was added\nThe submenu that was added."
    }, 
    {
        "allNodes() (nuke)": "allNodes(filter,\n        group)\n\n\u00a0\n    \n\nList of all nodes in a group. If you need to get all the nodes in the \n  script from a context which has no child nodes, for instance a control \n  panel, use nuke.root().nodes().\n\nParameters:\n\nfilter - Optional. Only return nodes of the specified class.\ngroup - Optional. If the group is omitted the current group (ie the group\n          the user picked a menu item from the toolbar of) is used.\nrecurseGroups - Optional. If True, will also return all child nodes within any \n          group nodes. This is done recursively and defaults to False.\n\nReturns: List\nList"
    }, 
    {
        "autoSaveRestoreFilters (nuke.callbacks)": "autoSaveRestoreFilters\n\n\n\nValue:\n\n{'Root': [(<function onAutoSaveRestore at 0x7f9c4da076e0>,\n           (),\n           {},\n           None)]}"
    }, 
    {
        "addMultilineTextInput() (Panel)": "addMultilineTextInput(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a multi-line text knob to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "allNodes() (nukescripts.snap3d)": "allNodes()\n\nsource\u00a0code\u00a0\n    \n\nReturn an iterator which yields all nodes in the current script.\nThis includes nodes inside groups. They will be returned in top-down, \n  depth-first order.\n\nReturns: iterator"
    }, 
    {
        "averageNormal() (nukescripts.snap3d)": "averageNormal(vertexSelection)\n      averageNormal(selectionThreshold -> _nukemath.Vector3 Return a \n      _nukemath.Vector3 which is the average of the normals of all selected\n      points\n\nsource\u00a0code"
    }, 
    {
        "addNodePresetExcludePaths() (nuke)": "addNodePresetExcludePaths(paths)\n\n\u00a0\n    \n\n@param paths Sequence of paths to exclude Adds a list of paths that \n  will be excluded from Node preset search paths.\n\nReturns: None\nNone."
    }, 
    {
        "allNodesWithGeoSelectKnob() (nukescripts.snap3d)": "allNodesWithGeoSelectKnob()\n\nsource\u00a0code"
    }, 
    {
        "Axis_Knob (nuke)": null
    }, 
    {
        "addNotepad() (Panel)": "addNotepad(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a text edit widget to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "altsep (os)": "altsep = None"
    }, 
    {
        "BackdropNode (nuke)": null
    }, 
    {
        "beforeRender() (nuke.callbacks)": "beforeRender()\n\nsource\u00a0code"
    }, 
    {
        "BREAK (nuke)": "BREAK = 18"
    }, 
    {
        "BaseCurve (_curvelib)": null
    }, 
    {
        "beforeRenders (nuke)": "beforeRenders = {}"
    }, 
    {
        "breakoutLayers() (nukescripts.psd)": null
    }, 
    {
        "bbox() (Node)": "bbox(self)\n\n\u00a0\n    \n\nBounding box of the node.\n\nReturns: List of x, y, w, h\nList of x, y, w, h."
    }, 
    {
        "beforeRenders (nuke.callbacks)": "beforeRenders = {}"
    }, 
    {
        "BreakoutThreadClass (nukescripts.psd)": null
    }, 
    {
        "BBox_Knob (nuke)": null
    }, 
    {
        "begin() (Group)": "begin(self)\n\n\u00a0\n    \n\nAll python code that follows will be executed in the context of node. \n  All names are evaluated relative to this object. Must be paired with \n  end.\n\nReturns: Group\nGroup."
    }, 
    {
        "buildFolderList() (CreateToolsetsPanel)": null
    }, 
    {
        "bboxToTopLeft() (nukescripts.renderdialog)": "bboxToTopLeft(height,\n        roi)\n\nsource\u00a0code\u00a0\n    \n\nConvert the roi passed from a origin at the bottom left to the top \n  left. Also replaces the r and t keys with w and h keys.\n\nParameters:\n\nheight - the height used to determine the top.\nroi - the roi with a bottom left origin, must have x, y, r & t \n          keys. @result dict with x, y, w & h keys"
    }, 
    {
        "begin() (Undo)": "begin(...)\n      Begin a new user-visible group of undo actions."
    }, 
    {
        "buildPresetDeletePanel() (nukescripts.nodepresets)": null
    }, 
    {
        "BEFORE_CONST (nuke)": "BEFORE_CONST = 19"
    }, 
    {
        "BeginTabGroup_Knob (nuke)": null
    }, 
    {
        "buildPresetFileList() (nukescripts.nodepresets)": null
    }, 
    {
        "BEFORE_LINEAR (nuke)": "BEFORE_LINEAR = 20"
    }, 
    {
        "Bitmask_Knob (nuke)": null
    }, 
    {
        "buildPresetLoadPanel() (nukescripts.nodepresets)": null
    }, 
    {
        "beforeBackgroundRender() (nuke.callbacks)": "beforeBackgroundRender(context)\n\nsource\u00a0code"
    }, 
    {
        "bookmarks (nukescripts)": null
    }, 
    {
        "buildPresetSavePanel() (nukescripts.nodepresets)": null
    }, 
    {
        "beforeBackgroundRenders (nuke)": "beforeBackgroundRenders = []"
    }, 
    {
        "Boolean_Knob (nuke)": null
    }, 
    {
        "buildUserPresetDeletePanel() (nukescripts.nodepresets)": null
    }, 
    {
        "beforeBackgroundRenders (nuke.callbacks)": "beforeBackgroundRenders = []"
    }, 
    {
        "booleanCheckBox (nukescripts.panel_test)": null
    }, 
    {
        "buildUserPresetLoadPanel() (nukescripts.nodepresets)": null
    }, 
    {
        "beforeFrameRender() (nuke.callbacks)": "beforeFrameRender()\n\nsource\u00a0code"
    }, 
    {
        "Box (nuke)": null
    }, 
    {
        "builtin_module_names (sys)": "builtin_module_names\n\n\n\nValue:\n\n('__builtin__',\n '__main__',\n '_ast',\n '_codecs',\n '_curveknob',\n '_curvelib',\n '_geo',\n '_nuke_internal',\n..."
    }, 
    {
        "beforeFrameRenders (nuke)": "beforeFrameRenders = {}"
    }, 
    {
        "Box3_Knob (nuke)": null
    }, 
    {
        "byteorder (sys)": "byteorder = 'little'"
    }, 
    {
        "beforeFrameRenders (nuke.callbacks)": "beforeFrameRenders = {}"
    }, 
    {
        "branch() (nukescripts.edit)": "branch()\n\nsource\u00a0code"
    }, 
    {
        "cache (nukescripts)": null
    }, 
    {
        "clear() (AnimationCurve)": "clear(self)\n\n\u00a0\n    \n\nDelete all keys.\n\nReturns: None\nNone."
    }, 
    {
        "copyAnimation() (Array_Knob)": "copyAnimation(self,\n        channel,\n        curve,\n        view)\n\n\u00a0\n    \n\nCopies the i'th channel of the AnimationCurve curve to this object. \n  The view is optional and defaults to the current view.\n\nParameters:\n\nchannel - The channel index.\ncurve - AnimationCurve.\nview - Optional view. Defaults to current.\n\nReturns: None\nNone."
    }, 
    {
        "cache_clear() (nukescripts.cache)": null
    }, 
    {
        "clear() (Box)": "clear(self)\n      Set to is_constant()."
    }, 
    {
        "copyAnimations() (Array_Knob)": "copyAnimations(self,\n        curves,\n        view)\n\n\u00a0\n    \n\nCopies the AnimationCurves from curves to this object. The view is \n  optional and defaults to the current view.\n\nParameters:\n\ncurves - AnimationCurve list.\nview - Optional view. Defaults to current.\n\nReturns: None\nNone."
    }, 
    {
        "cache_report() (nukescripts.cache)": null
    }, 
    {
        "clear() (FrameRanges)": "clear()\n      reset all store frame ranges."
    }, 
    {
        "copyright (sys)": "copyright\n\n\n\nValue:\n\n'''Copyright (c) 2001-2010 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n..."
    }, 
    {
        "cacheDir() (FlipbookApplication)": "cacheDir(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the preferred directory for rendering.\n\nReturns:\nString"
    }, 
    {
        "clear() (Panel)": "clear(self)\n      Clear all panel attributes."
    }, 
    {
        "CorrespondencePoints (_curvelib)": null
    }, 
    {
        "cacheDir() (FramecyclerFlipbook)": "cacheDir(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the preferred directory for rendering.\n\nReturns:\nString\nOverrides:\n        flipbooking.FlipbookApplication.cacheDir\n(inherited documentation)"
    }, 
    {
        "clear_selection_recursive() (nukescripts.misc)": "clear_selection_recursive(group=nuke.root())\n      Sets all nodes to unselected, including in child groups.\n\nsource\u00a0code"
    }, 
    {
        "create (nukescripts)": null
    }, 
    {
        "cacheDir() (ExampleRVFlipbook)": "cacheDir(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the preferred directory for rendering.\n\nReturns:\nString\nOverrides:\n        flipbooking.FlipbookApplication.cacheDir\n(inherited documentation)"
    }, 
    {
        "clearAnimated() (Array_Knob)": "clearAnimated(self,\n        index,\n        view)\n\n\u00a0\n    \n\nDelete animation.\n\nParameters:\n\nindex - Optional index.\nview - Optional view.\n\nReturns: True if succeeded, False otherwise\nTrue if succeeded, False otherwise.\nOverrides:\n        Knob.clearAnimated"
    }, 
    {
        "create() (PythonPanel)": "create(self)"
    }, 
    {
        "cacheUsage() (nuke)": "cacheUsage()\n\n\u00a0\n    \n\nGet the total amount of memory currently used by the cache.\n\nReturns: int\nCurrent memory usage in bytes."
    }, 
    {
        "clearAnimated() (Knob)": "clearAnimated(...)\n\n\u00a0\n    \n\nClear animation for channel 'c'. Return True if successful."
    }, 
    {
        "create_camera_here() (nukescripts.camera)": "create_camera_here()\n\nsource\u00a0code"
    }, 
    {
        "calcAveragePosition() (nukescripts.snap3d)": "calcAveragePosition(vertexSelection)\n\nsource\u00a0code\u00a0\n    \n\nCalculate the average position of all points.\n\nParameters:\n\npoints - An iterable sequence of _nukemath.Vector3 objects.\n\nReturns:\nA _nukemath.Vector3 containing the average of all the points."
    }, 
    {
        "clearDiskCache() (nuke)": "clearDiskCache()\n      Clear the disk cache of all files."
    }, 
    {
        "create_curve() (nukescripts.create)": "create_curve()\n\nsource\u00a0code"
    }, 
    {
        "calcBounds() (nukescripts.snap3d)": "calcBounds(vertexSelection)\n\nsource\u00a0code"
    }, 
    {
        "clearFlag() (Knob)": "clearFlag(self,\n        f)\n\n\u00a0\n    \n\nClear flag.\n\nParameters:\n\nf - Flag.\n\nReturns: None\nNone."
    }, 
    {
        "create_matrix() (nukescripts.toolbars)": null
    }, 
    {
        "calcRotationVector() (nukescripts.snap3d)": "calcRotationVector(vertexSelection,\n        norm)\n\nsource\u00a0code"
    }, 
    {
        "clearMenu() (Menu)": "clearMenu(self)\n\n\u00a0\n    \n\nClears a menu.\n\nParameters:\n\n**kwargs, The, following, keyword, arguments, are, accepted - name      The name for the menu/toolbar item\n\nReturns:\ntrue if cleared, false if menu not found"
    }, 
    {
        "create_planartracker() (nukescripts.toolbars)": null
    }, 
    {
        "callbacks (nuke)": null
    }, 
    {
        "clearMenu() (MenuBar)": "clearMenu(self)\n\n\u00a0\n    \n\nClears a menu.\n\nParameters:\n\n**kwargs, The, following, keyword, arguments, are, accepted - name      The name for the menu/toolbar item\n\nReturns:\ntrue if cleared, false if menu not found"
    }, 
    {
        "create_read() (nukescripts.create)": "create_read(defaulttype='Read')\n\nsource\u00a0code\u00a0\n    \n\nCreate a Read node for a file selected from the file browser. If a \n  node is currently selected in the nodegraph and it has a 'file' (or \n  failing that a 'proxy') knob, the value (if any) will be used as the \n  default path for the file browser."
    }, 
    {
        "callSnapFunc() (nukescripts.snap3d)": "callSnapFunc(nodeToSnap=None)\n\nsource\u00a0code\u00a0\n    \n\nCall the snapping function on a node.\nThe nodeToSnap parameter is optional. If it's not specified, or is \n  None, we use the result of nuke.thisNode() instead.\nThe node must have an Enumeration_Knob called \"snapFunc\" \n  which selects the snapping function to call.\n\nReturns: None"
    }, 
    {
        "clearMenu() (ToolBar)": "clearMenu(self)\n\n\u00a0\n    \n\nClears a menu.\n\nParameters:\n\n**kwargs, The, following, keyword, arguments, are, accepted - name      The name for the menu/toolbar item\n\nReturns:\ntrue if cleared, false if menu not found"
    }, 
    {
        "create_time_warp() (nukescripts.toolbars)": null
    }, 
    {
        "camera (nukescripts)": null
    }, 
    {
        "clearRAMCache() (nuke)": "clearRAMCache()\n      Clear the RAM cache of all files."
    }, 
    {
        "create_viewsplitjoin() (nukescripts.create)": "create_viewsplitjoin()\n\nsource\u00a0code"
    }, 
    {
        "camera_down() (nukescripts.camera)": "camera_down()\n\nsource\u00a0code\u00a0\n    \n\nAll new camera_down that uses the version_get/set functions. This \n  script takes the render camera up one in selected iread/writes. Camera \n  may be _c# or _p# for previs camera number"
    }, 
    {
        "client (nukescripts.clientserver)": null
    }, 
    {
        "createCurveTool() (nukescripts.toolbars)": null
    }, 
    {
        "camera_up() (nukescripts.camera)": "camera_up()\n\nsource\u00a0code\u00a0\n    \n\nAll new camera_up that uses the version_get/set functions. This script\n  takes the render camera up one in selected iread/writes. Camera may be \n  _c# or _p# for previs camera number"
    }, 
    {
        "clientserver (nukescripts)": null
    }, 
    {
        "createKronos() (nukescripts.toolbars)": null
    }, 
    {
        "cameraProjectionMatrix() (nukescripts.snap3d)": "cameraProjectionMatrix(cameraNode)\n      Calculate the projection matrix for the camera based on its knob \n      values.\n\nsource\u00a0code"
    }, 
    {
        "clipnameSearch (nukescripts.panel_test)": null
    }, 
    {
        "createNode() (nuke)": "createNode(node,\n        args,\n        inpanel)\n\n\u00a0\n    \n\nCreates a node of the specified type and adds it to the DAG.\n\nParameters:\n\nnode - Node class (e.g. Blur).\nargs - Optional string containing a TCL list of name value pairs (like \n          \"size 50 quality 19\")\ninpanel - Optional boolean to open the control bin (default is True; only \n          applies when the GUI is running).\n\nReturns: Node\nNode."
    }, 
    {
        "cancel() (Undo)": "cancel(...)\n      Undoes any actions recorded in the current set and throws it away."
    }, 
    {
        "clone() (Element)": "clone(self)"
    }, 
    {
        "createNodePreset() (nukescripts.nodepresets)": null
    }, 
    {
        "cancel() (nuke)": "cancel()\n\n\u00a0\n    \n\nCancel an in-progress operation. This has the same effect as hitting \n  cancel on the progress panel.\n\nReturns: None\nNone"
    }, 
    {
        "clone() (nuke)": "clone(n,\n        args,\n        inpanel)\n\n\u00a0\n    \n\nCreate a clone node that behaves identical to the original. The node \n  argument is the node to be cloned, args and inpanel are optional \n  arguments similar to createNode. A cloned node shares the exact same \n  properties with its original. Clones share the same set of knobs and the \n  same control panel. However they can have different positions and \n  connections in the render tree. Any clone, including the original, can be\n  deleted at any time without harming any of its clones.\n\nParameters:\n\nn - Node.\nargs - Optional number of inputs requested.\ninpanel - Optional boolean.\n\nReturns: Node\nNode"
    }, 
    {
        "createNodePresetsMenu() (nukescripts.nodepresets)": null
    }, 
    {
        "cancel() (PythonPanel)": "cancel(self)"
    }, 
    {
        "clones() (Node)": "clones(self)\n\n\u00a0\n    \n\n\nReturns: Number of clones\nNumber of clones."
    }, 
    {
        "CreateNodePresetsPanel (nukescripts.nodepresets)": null
    }, 
    {
        "canSetInput() (Node)": "canSetInput(self,\n        i,\n        node)\n\n\u00a0\n    \n\nCheck whether the output of 'node' can be connected to input i.\n\nParameters:\n\ni - Input number.\nnode - The node to be connected to input i.\n\nReturns: bool\nTrue if node can be connected, False otherwise."
    }, 
    {
        "clones() (Root)": "clones(self)\n\n\u00a0\n    \n\n\nReturns: Number of clones\nNumber of clones.\nOverrides:\n        Node.clones\n(inherited documentation)"
    }, 
    {
        "createPreset() (CreateNodePresetsPanel)": null
    }, 
    {
        "canSetInput() (Root)": "canSetInput(self,\n        i,\n        node)\n\n\u00a0\n    \n\nCheck whether the output of 'node' can be connected to input i.\n\nParameters:\n\ni - Input number.\nnode - The node to be connected to input i.\n\nReturns: bool\nTrue if node can be connected, False otherwise.\nOverrides:\n        Node.canSetInput\n(inherited documentation)"
    }, 
    {
        "cloneSelected() (nuke)": "cloneSelected(action)\n\n\u00a0\n    \n\nThis makes a clone of all selected nodes, preserving connections \n  between them, and makes only the clones be selected.\n\nParameters:\n\naction - Optional and if 'copy' it cuts the resulting clones to the \n          clipboard.\n\nReturns: bool\nTrue if succeeded, False otherwise."
    }, 
    {
        "createPreset() (CreateToolsetsPanel)": null
    }, 
    {
        "capabilities() (FlipbookApplication)": "capabilities(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the capabilities of the flipbook application. Currently used \n  are: proxyScale: bool, whether the flipbook supports proxies crop: bool, \n  whether the flipbook supports crops canPreLaunch: bool, whether the \n  flipbook can display a frames that are still being rendered by Nuke. \n  maximumViews: int, the number of views supported by this flipbook, should\n  be 1 or higher. fileTypes: list, the extensions of the file types \n  supported by this format. Must all be lowercase, e.g [\"exr\", \n  \"jpg\", ...]\n\nReturns:\ndict with the capabilities above."
    }, 
    {
        "close() (client)": null
    }, 
    {
        "createPrmanRender() (nukescripts.toolbars)": null
    }, 
    {
        "capabilities() (FramecyclerFlipbook)": "capabilities(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the capabilities of the flipbook application. Currently used \n  are: proxyScale: bool, whether the flipbook supports proxies crop: bool, \n  whether the flipbook supports crops canPreLaunch: bool, whether the \n  flipbook can display a frames that are still being rendered by Nuke. \n  maximumViews: int, the number of views supported by this flipbook, should\n  be 1 or higher. fileTypes: list, the extensions of the file types \n  supported by this format. Must all be lowercase, e.g [\"exr\", \n  \"jpg\", ...]\n\nReturns:\ndict with the capabilities above.\nOverrides:\n        flipbooking.FlipbookApplication.capabilities\n(inherited documentation)"
    }, 
    {
        "closeApplication() (pyQtAppHelper)": "closeApplication(self)\n\nsource\u00a0code"
    }, 
    {
        "createScenefileBrowser() (nuke)": "createScenefileBrowser(fileName,\n        nodeName)\n\n\u00a0\n    \n\nPops up a scene browser dialog box. Receives the path to an Alembic \n  (abc) file, and displays a hierarchical tree of the nodes within the \n  file. The user can select which nodes they are interseted in, and nodes \n  of the appropriate type will automatically. be created. If a valid scene \n  file nodeName is specified, this node will be populated with the selected\n  tree.\n\nParameters:\n\nfileName - Path and filename for an alembic file.\nnodeName - name of a valid scene file node to populate. If the node is \n          invalid, new nodes will be automatically created\n\nReturns: None"
    }, 
    {
        "capabilities() (ExampleRVFlipbook)": "capabilities(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the capabilities of the flipbook application. Currently used \n  are: proxyScale: bool, whether the flipbook supports proxies crop: bool, \n  whether the flipbook supports crops canPreLaunch: bool, whether the \n  flipbook can display a frames that are still being rendered by Nuke. \n  maximumViews: int, the number of views supported by this flipbook, should\n  be 1 or higher. fileTypes: list, the extensions of the file types \n  supported by this format. Must all be lowercase, e.g [\"exr\", \n  \"jpg\", ...]\n\nReturns:\ndict with the capabilities above.\nOverrides:\n        flipbooking.FlipbookApplication.capabilities\n(inherited documentation)"
    }, 
    {
        "CMatrix4 (_curvelib)": null
    }, 
    {
        "createToolset() (nuke)": "createToolset(filename=None,\n        overwrite=-1,\n        rootPath= None)\n\n\u00a0\n    \n\n\nCreates a tool preset based on the currently selected nodes. \n\n@param filename: Saves the preset as a script with the given file name.\n @param overwrite: If 1 (true) always overwrite; if 0 (false) never overwrite; @param rootPath: If specified, use this as the root path to save the Toolset to. If not specified, save to the user's .nuke/Toolsets folder.  otherwise, in GUI mode ask the user, in terminal do same as False. Default  is -1, meaning 'ask the user'.\n\n\n\nReturns: None"
    }, 
    {
        "CascadingEnumeration_Knob (nuke)": null
    }, 
    {
        "collapseToGroup() (nuke)": "collapseToGroup(show=True)\n\n\u00a0\n    \n\nMoves the currently selected nodes to a new group, maintaining their \n  previous connections.\n\nParameters:\n\nshow - If show is True, the node graph for the new group is shown in the\n          background.\n\nReturns: Group\nThe new Group node."
    }, 
    {
        "createToolsetMenuItems() (nukescripts.toolsets)": null
    }, 
    {
        "CATMULL_ROM (nuke)": "CATMULL_ROM = 3"
    }, 
    {
        "Color_Knob (nuke)": null
    }, 
    {
        "createToolsetsMenu() (nukescripts.toolsets)": null
    }, 
    {
        "cellChanged() (UDIMOptionsDialog)": "cellChanged(self,\n        row,\n        column)\n\nsource\u00a0code"
    }, 
    {
        "color_nodes() (nukescripts.nodes)": null
    }, 
    {
        "CreateToolsetsPanel (nukescripts.toolsets)": null
    }, 
    {
        "center (ShapeControlPoint)": "center\n      The center of the control point"
    }, 
    {
        "ColorChip_Knob (nuke)": null
    }, 
    {
        "createUVTile() (nukescripts.toolbars)": null
    }, 
    {
        "center() (nuke)": "center()\n\n\u00a0\n    \n\nReturn the center values of a group's display, these values are \n  suitable to be passed to nuke.zoom as the DAG center point.  Like so: \n  center = nuke.center() zoom = nuke.zoom() print center[0] print center[1]\n  ## move DAG back to center point without changing zoom. nuke.zoom( zoom, \n  center )\n\nReturns: array with x, then y\nArray of x, y."
    }, 
    {
        "command() (Gizmo)": "command(self)\n\n\u00a0\n    \n\nGizmo command.\n\nReturns: String\nString."
    }, 
    {
        "createWidget() (PanelNode)": "createWidget(...)\n      Create the widget for the panel"
    }, 
    {
        "centerX() (Box)": "centerX(self)\n      Return center in X."
    }, 
    {
        "command() (Script_Knob)": "command(self)\n\n\u00a0\n    \n\nGet the current command.\n\nReturns: str\nThe current command as a string, or None if there is no current \n          command."
    }, 
    {
        "critical() (Knob)": "critical(self,\n        message)\n\n\u00a0\n    \n\n\nParameters:\n\nmessage - message to put the knob in error, and do a popup.\n\nReturns: None\nNone."
    }, 
    {
        "centerY() (Box)": "centerY(self)\n      Return height in Y."
    }, 
    {
        "commands() (Pulldown_Knob)": "commands(n)\n\n\u00a0\n    \n\nReturn command n. The argument n is an integer and in the range of 0 \n  and numValues.\n\nReturns: string"
    }, 
    {
        "critical() (nuke)": "critical(message)\n\n\u00a0\n    \n\nPuts the message into the error console, treating it like an error. \n  Also pops up an alert dialog to the user, immediately.\n\nParameters:\n\nmessage - String parameter.\n\nReturns: None\nNone."
    }, 
    {
        "changed() (CurveKnob)": "changed(self)\n\n\u00a0\n    \n\nCall this after performing updates on the tree, to tell it that it's \n  been updated. For many operations this is called automatically, but you \n  can call it manually for those cases where it isn't.\n\nReturns: None"
    }, 
    {
        "compact() (FrameRanges)": "compact()\n      compact all the frame ranges."
    }, 
    {
        "crop (nukescripts)": null
    }, 
    {
        "changeInterpolation() (AnimationCurve)": "changeInterpolation(self,\n        keys,\n        type)\n\n\u00a0\n    \n\nChange interpolation (and extrapolation) type for the keys.\n\nParameters:\n\nkeys - Sequence of keys.\ntype - Interpolation type. One of nuke.HORIZONTAL, nuke.BREAK, \n          nuke.BEFORE_CONST, nuke.BEFORE_LINEAR, nuke.AFTER_CONST or \n          nuke.AFTER_LINEAR.\n\nReturns: None\nNone."
    }, 
    {
        "compare_UDIMFile() (nukescripts.udim)": "compare_UDIMFile(a,\n        b)\n\nsource\u00a0code"
    }, 
    {
        "CTransform (_curvelib)": null
    }, 
    {
        "changeLocation() (WebBrowserWidget)": null
    }, 
    {
        "confstr_names (os)": "confstr_names\n\n\n\nValue:\n\n{'CS_LFS64_CFLAGS': 1004,\n 'CS_LFS64_LDFLAGS': 1005,\n 'CS_LFS64_LIBS': 1006,\n 'CS_LFS64_LINTFLAGS': 1007,\n 'CS_LFS_CFLAGS': 1000,\n 'CS_LFS_LDFLAGS': 1001,\n 'CS_LFS_LIBS': 1002,\n 'CS_LFS_LINTFLAGS': 1003,\n..."
    }, 
    {
        "CUBIC (nuke)": "CUBIC = 4"
    }, 
    {
        "Channel_Knob (nuke)": null
    }, 
    {
        "connect_selected_to_viewer() (nukescripts.misc)": "connect_selected_to_viewer(inputIndex)\n      Connects the selected node to the given viewer input index, ignoring \n      errors if no node is selected.\n\nsource\u00a0code"
    }, 
    {
        "CubicCurve (_curvelib)": null
    }, 
    {
        "ChannelMask_Knob (nuke)": null
    }, 
    {
        "connectInput() (Node)": "connectInput(self,\n        i,\n        node)\n\n\u00a0\n    \n\nConnect the output of 'node' to the i'th input or the next available \n  unconnected input. The requested input is tried first, but if it is \n  already set then subsequent inputs are tried until an unconnected one is \n  found, as when you drop a connection arrow onto a node in the GUI.\n\nParameters:\n\ni - Input number to try first.\nnode - The node to connect to input i.\n\nReturns: bool\nTrue if a connection is made, False otherwise."
    }, 
    {
        "curdir (os)": "curdir = '.'"
    }, 
    {
        "channels() (Layer)": "channels(self)\n\n\u00a0\n    \n\nGet a list of the channels in this layer.\n\nReturns: [string, ...]\nA list of strings, where each string is the name of a channel in \n          this layer."
    }, 
    {
        "connectInput() (Root)": "connectInput(self,\n        i,\n        node)\n\n\u00a0\n    \n\nConnect the output of 'node' to the i'th input or the next available \n  unconnected input. The requested input is tried first, but if it is \n  already set then subsequent inputs are tried until an unconnected one is \n  found, as when you drop a connection arrow onto a node in the GUI.\n\nParameters:\n\ni - Input number to try first.\nnode - The node to connect to input i.\n\nReturns: bool\nTrue if a connection is made, False otherwise.\nOverrides:\n        Node.connectInput\n(inherited documentation)"
    }, 
    {
        "curdir (posixpath)": "curdir = '.'"
    }, 
    {
        "channels() (Node)": "channels(self)\n\n\u00a0\n    \n\nList channels output by this node.\n\nReturns: String list\nString list."
    }, 
    {
        "connectNodes() (nuke)": "connectNodes()\n\n\u00a0\n    \n\nDeprecated. Use Group.connectSelectedNodes.\n\nReturns: None\nNone"
    }, 
    {
        "CurveKnob (_curveknob)": null
    }, 
    {
        "channels() (Root)": "channels(...)\n\n\u00a0\n    \n\nnuke.Root.channels() -> Channel list. Class method.\n\nReturns: String list\nChannel list.\nOverrides:\n        Node.channels"
    }, 
    {
        "connectSelectedNodes() (Group)": "connectSelectedNodes(self,\n        backward,\n        inputA)\n\n\u00a0\n    \n\nConnect the selected nodes. @param backward. @param inputA.\n\nReturns: None\nNone."
    }, 
    {
        "curveknob (nuke)": null
    }, 
    {
        "channels() (nuke)": "channels(n=None)\n\n\u00a0\n    \n\nDeprecated. Use Node.channels.\nList channels. The n argument is a Nuke node and if given only the \n  channels output by this node are listed. If not given or None, all \n  channels known about are listed.\n\nParameters:\n\nn - Optional node parameter.\n\nReturns: (string)\nA list of channel names."
    }, 
    {
        "connectViewer() (nuke)": "connectViewer(inputNum,\n        node)\n\n\u00a0\n    \n\nConnect a viewer input to a node. The argument i is the input number \n  and n is either a Nuke node or None. Some viewer in the current group is \n  found, if there are no viewers one is created. The viewer is then altered\n  to have at least n+1 inputs and then input n is connected to the given \n  node.This function is used by the numeric shortcuts in the DAG view \n  menu.\n\nParameters:\n\ninputNum - Input number.\nnode - The Node to connect to the input.\n\nReturns: None\nNone"
    }, 
    {
        "curvelib (nuke)": null
    }, 
    {
        "channelSelector() (Channel_Knob)": "channelSelector(self)"
    }, 
    {
        "CONSTANT (nuke)": "CONSTANT = 1"
    }, 
    {
        "curveTension (BaseCurve)": "curveTension\n      The tension type for this curve."
    }, 
    {
        "checkForEmptyToolsetDirectories() (nukescripts.toolsets)": null
    }, 
    {
        "constant() (AnimationCurve)": "constant(self)\n\n\u00a0\n    \n\n\nReturns: bool\nTrue if the animation appears to be a horizontal line, is a \n          simple number, or it is the default and all the points are at the\n          same y value and have 0 slopes. False otherwise."
    }, 
    {
        "curveType (BaseCurve)": "curveType\n      The type of curve to treat this as."
    }, 
    {
        "checkMarks() (Channel_Knob)": "checkMarks(self)"
    }, 
    {
        "constantValue (AnimCurve)": "constantValue\n      The constant (not-animated) value for this curve, if any."
    }, 
    {
        "CurveType (_curvelib)": null
    }, 
    {
        "checkUdimValue() (nukescripts.udim)": "checkUdimValue(udim)\n\nsource\u00a0code"
    }, 
    {
        "ControlPoint (_curvelib)": null
    }, 
    {
        "curveWidget (CurveKnob)": "curveWidget\n      Curve Widget"
    }, 
    {
        "choice() (nuke)": "choice(title,\n        prompt,\n        options,\n        default= 0)\n\n\u00a0\n    \n\nShows a dialog box with the given title and prompt text, and a combo \n  box containing the given options.\n\nParameters:\n\ntitle - Text to put in the dialog's title bar.\nprompt - Text to display at the top of the dialog.\noptions - A list of strings for the user to choose from.\ndefault - The index (starting from zero) of the option to select first.\n\nReturns: index\nAn integer index (starting from zero) of the choice the user \n          selected, or None if the dialog was cancelled."
    }, 
    {
        "convertDirectoryToNuke6() (nuke.rotopaint)": "convertDirectoryToNuke6(fromDir,\n        toDir,\n        matchPattern='.*\\\\.nk',\n        overwrite=False)\n\nsource\u00a0code\u00a0\n    \n\nConvert a directory containing NUKE 7 roto scripts in one containing \n  the old format. Note that the pattern is a regular expression."
    }, 
    {
        "CurveWidget (_curveknob)": null
    }, 
    {
        "clampX() (Box)": "clampX(self,\n        x)\n      Return x restricted to pointing at a pixel in the box."
    }, 
    {
        "convertDirectoryToNuke7() (nuke.rotopaint)": "convertDirectoryToNuke7(fromDir,\n        toDir,\n        matchPattern='.*\\\\.nk',\n        overwrite=False)\n\nsource\u00a0code\u00a0\n    \n\nConvert a directory containing NUKE 6 roto scripts in one containing \n  the new format. Note that the pattern is a regular expression."
    }, 
    {
        "cut_paste_file() (nukescripts.edit)": "cut_paste_file()\n\nsource\u00a0code"
    }, 
    {
        "clampY() (Box)": "clampY(self,\n        y)\n      Return y restricted to pointing at a pixel in the box."
    }, 
    {
        "convertToNuke6() (nuke.rotopaint)": "convertToNuke6(fromScript,\n        toScript,\n        overwrite=False)\n      Convert a script containing NUKE 7 roto in one containing the old \n      format.\n\nsource\u00a0code"
    }, 
    {
        "CVec2 (_curvelib)": null
    }, 
    {
        "Class() (Knob)": "Class(self)\n\n\u00a0\n    \n\n\nReturns: Class name\nClass name."
    }, 
    {
        "convertToNuke7() (nuke.rotopaint)": "convertToNuke7(fromScript,\n        toScript,\n        overwrite=False)\n      Convert a script containing NUKE 6 roto in one containing the new \n      format.\n\nsource\u00a0code"
    }, 
    {
        "CVec3 (_curvelib)": null
    }, 
    {
        "Class() (Node)": "Class(self)\n\n\u00a0\n    \n\n\nReturns: Class of node\nClass of node."
    }, 
    {
        "copy_knobs() (nukescripts.misc)": "copy_knobs(args)\n\nsource\u00a0code"
    }, 
    {
        "CVec4 (_curvelib)": null
    }, 
    {
        "DEBUG (re)": "DEBUG = 128"
    }, 
    {
        "deleteToolset() (nukescripts.toolsets)": null
    }, 
    {
        "dim (ControlPoint)": "dim\n      The dimensionality of the control point."
    }, 
    {
        "debug() (Knob)": "debug(self,\n        message)\n\n\u00a0\n    \n\n\nParameters:\n\nmessage - message to put out to the error console, attached to the knob, if\n          the verbosity level is set high enough.\n\nReturns: None\nNone."
    }, 
    {
        "deleteUserNodePreset() (nukescripts.nodepresets)": null
    }, 
    {
        "dimensions() (Array_Knob)": "dimensions(self)\n\n\u00a0\n    \n\n\nReturns: Dimensions in array\nDimensions in array."
    }, 
    {
        "debug() (nuke)": "debug(message)\n\n\u00a0\n    \n\nPuts the message into the error console, treating it like a debug \n  message, which only shows up when the verbosity level is high enough.\n\nParameters:\n\nmessage - String parameter.\n\nReturns: None\nNone."
    }, 
    {
        "deleteUserPreset() (nuke)": "deleteUserPreset(nodeClassName,\n        presetName)\n\n\u00a0\n    \n\nDeletes a pre-created user node preset\n\nParameters:\n\nnodeClassName - Name of the node class to create a preset for.\npresetName - Name of the preset to create.\n\nReturns: None\nbool."
    }, 
    {
        "dimensions() (IArray_Knob)": "dimensions(self)\n\n\u00a0\n    \n\nReturn number of dimensions.\n\nReturns: Dimensions in array\nDimensions in array.\nOverrides:\n        Array_Knob.dimensions"
    }, 
    {
        "declone() (nukescripts.misc)": "declone(node)\n\nsource\u00a0code"
    }, 
    {
        "deleteView() (Root)": "deleteView(self,\n        s)\n\n\u00a0\n    \n\nDelete view.\n\nParameters:\n\ns - Name of view.\n\nReturns: None\nNone."
    }, 
    {
        "disable() (Undo)": "disable(...)\n      Prevent recording undos until matching enable()"
    }, 
    {
        "deepSample() (Node)": "deepSample(self,\n        c,\n        x,\n        y,\n        n)\n\n\u00a0\n    \n\nReturn pixel values from a deep image. This requires the image to be \n  calculated, so performance may be very bad if this is placed into an \n  expression in a control panel.\n\nParameters:\n\nc - Channel name.\nx - Position to sample (X coordinate).\ny - Position to sample (Y coordinate).\nn - Sample index (between 0 and the number returned by \n          deepSampleCount() for this pixel, or -1 for the frontmost).\n\nReturns: Floating point value\nFloating point value."
    }, 
    {
        "deleteView() (nuke)": "deleteView(s)\n\n\u00a0\n    \n\nDeprecated. Use the Root node.\nDeletes a view from the list of views.\n\nParameters:\n\ns - View name.\n\nReturns: None\nNone"
    }, 
    {
        "DISABLED (nuke)": "DISABLED = 128"
    }, 
    {
        "deepSampleCount() (Node)": "deepSampleCount(self,\n        x,\n        y)\n\n\u00a0\n    \n\nReturn number of samples for a pixel on a deep image. This requires \n  the image to be calculated, so performance may be very bad if this is \n  placed into an expression in a control panel.\n\nParameters:\n\nx - Position to sample (X coordinate).\ny - Position to sample (Y coordinate).\n\nReturns: Integer value\nInteger value."
    }, 
    {
        "dependencies() (Node)": "dependencies(self,\n        what)\n\n\u00a0\n    \n\n\nList all nodes referred to by this node. 'what' is an optional integer (see below).\nYou can use the following constants or'ed together to select what types of dependencies are looked for:\n         nuke.EXPRESSIONS = expressions\n         nuke.INPUTS = visible input pipes\n         nuke.HIDDEN_INPUTS = hidden input pipes.\nThe default is to look for all types of connections.\n\nExample:\nnuke.toNode('Blur1').dependencies( nuke.INPUTS | nuke.EXPRESSIONS )\n@param what: Or'ed constant of nuke.EXPRESSIONS, nuke.INPUTS and nuke.HIDDEN_INPUTS to select the types of dependencies. The default is to look for all types of connections.\n@return: List of nodes.\n\n\n\nReturns: List of nodes"
    }, 
    {
        "disabled() (Undo)": "disabled(...)\n      True if disable() has been called"
    }, 
    {
        "defaultFontPathname() (nuke)": "defaultFontPathname()\n\n\u00a0\n    \n\nGet the path to Nukes default font.\n\nReturns: str\nPath to the font."
    }, 
    {
        "dependencies() (nuke.overrides)": "dependencies(nodes,\n        what=7)\n\nsource\u00a0code\u00a0\n    \n\n\nList all nodes referred to by the nodes argument. 'what' is an optional integer (see below).\n  You can use the following constants or'ed together to select the types of dependencies that are looked for:\n         nuke.EXPRESSIONS = expressions\n         nuke.INPUTS = visible input pipes\n         nuke.HIDDEN_INPUTS = hidden input pipes.\n  The default is to look for all types of connections.\n  \nExample:\n  n1 = nuke.nodes.Blur()\n  n2 = nuke.nodes.Merge()\n  n2.setInput(0, n1)\n  deps = nuke.dependencies([n2], nuke.INPUTS | nuke.HIDDEN_INPUTS | nuke.EXPRESSIONS)"
    }, 
    {
        "display() (nuke)": "display(s,\n        node,\n        title,\n        width)\n\n\u00a0\n    \n\nCreates a window showing the result of a python script. The script is \n  executed in the context of the given node, so this and a knob name in \n  expressions refer to that node.\nThe window will have an 'update' button to run the script again.\n\nParameters:\n\ns - Python script.\nnode - Node.\ntitle - Optional title of window.\nwidth - Optional width of window.\n\nReturns: None\nNone."
    }, 
    {
        "defaultNodeColor() (nuke)": "defaultNodeColor(s)\n\n\u00a0\n    \n\nGet the default node colour.\n\nParameters:\n\ns - Node class.\n\nReturns: int\nThe color as a packed integer (0xRRGGBB00)."
    }, 
    {
        "dependent() (Node)": "dependent(self,\n        what,\n        forceEvaluate)\n\n\u00a0\n    \n\n\nList all nodes that read information from this node.  'what' is an optional integer:\n         You can use any combination of the following constants or'ed together to select what types of dependent nodes to look for:\n                 nuke.EXPRESSIONS = expressions\n                 nuke.INPUTS = visible input pipes\n                 nuke.HIDDEN_INPUTS = hidden input pipes.\nThe default is to look for all types of connections.\n\nforceEvaluate is an optional boolean defaulting to True. When this parameter is true, it forces a re-evaluation of the entire tree. \nThis can be expensive, but otherwise could give incorrect results if nodes are expression-linked. \n\nExample:\nnuke.toNode('Blur1').dependent( nuke.INPUTS | nuke.EXPRESSIONS )\n@param what: Or'ed constant of nuke.EXPRESSIONS, nuke.INPUTS and nuke.HIDDEN_INPUTS to select the types of dependent nodes. The default is to look for all types of connections.\n@param forceEvaluate: Specifies whether a full tree evaluation will take place. Defaults to True.\n@return: List of nodes.\n\n\n\nReturns: List of nodes"
    }, 
    {
        "displayName() (LinkableKnobInfo)": "displayName(self)\n      Returns the custom display name that will appear in Link-to menus.\n\nsource\u00a0code"
    }, 
    {
        "defaultValue() (Array_Knob)": "defaultValue(self)\n\n\u00a0\n    \n\n\nReturns: Default value\nDefault value."
    }, 
    {
        "dependentNodes() (nuke.overrides)": "dependentNodes(what=7,\n        nodes=[],\n        evaluateAll=True)\n\nsource\u00a0code\u00a0\n    \n\n\nList all nodes referred to by the nodes argument. 'what' is an optional integer (see below).\n  You can use the following constants or'ed together to select what types of dependent nodes are looked for:\n         nuke.EXPRESSIONS = expressions\n         nuke.INPUTS = visible input pipes\n         nuke.HIDDEN_INPUTS = hidden input pipes.\n  The default is to look for all types of connections.\n  \n  evaluateAll is an optional boolean defaulting to True. When this parameter is true, it forces a re-evaluation of the entire tree.\n  This can be expensive, but otherwise could give incorrect results if nodes are expression-linked.\n  \n  \nExample:\n  n1 = nuke.nodes.Blur()\n  n2 = nuke.nodes.Merge()\n  n2.setInput(0, n1)\n  ndeps = nuke.dependentNodes(nuke.INPUTS | nuke.HIDDEN_INPUTS | nuke.EXPRESSIONS, [n1])\n  \n  @param what: Or'ed constant of nuke.EXPRESSIONS, nuke.INPUTS and nuke.HIDDEN_INPUTS to select the types of dependent nodes. The default is to look for all types of connections.\n  @param evaluateAll: Specifies whether a full tree evaluation will take place. Defaults to True.\n  @return: List of nodes."
    }, 
    {
        "DO_NOT_WRITE (nuke)": "DO_NOT_WRITE = 512"
    }, 
    {
        "defpath (os)": "defpath = ':/bin:/usr/bin'"
    }, 
    {
        "depth() (Channel_Knob)": "depth(self)\n\n\u00a0\n    \n\nGet the channel depth.\n\nReturns: int\nThe depth of the channel as an int."
    }, 
    {
        "DONT_SAVE_TO_NODEPRESET (nuke)": "DONT_SAVE_TO_NODEPRESET = 549755813888"
    }, 
    {
        "defpath (posixpath)": "defpath = ':/bin:/usr/bin'"
    }, 
    {
        "derivative() (AnimationCurve)": "derivative(self,\n        t,\n        n)\n\n\u00a0\n    \n\nThe n'th derivative at time 't'. If n is less than 1 it returns \n  evaluate(t).\n\nParameters:\n\nt - Time.\nn - Optional. Default is 1.\n\nReturns: Float\nThe value of the derivative."
    }, 
    {
        "dont_write_bytecode (sys)": "dont_write_bytecode = False"
    }, 
    {
        "delCurve() (LookupCurves_Knob)": "delCurve(self,\n        curve)\n\n\u00a0\n    \n\nDeletes a curve.\n\nParameters:\n\ncurve - The name of the animation curve.\n\nReturns: None\nNone"
    }, 
    {
        "devnull (os)": "devnull = '/dev/null'"
    }, 
    {
        "doReaderBreakout() (nukescripts.psd)": null
    }, 
    {
        "delete() (nuke)": "delete(n)\n\n\u00a0\n    \n\nThe named node is deleted. It can be recovered with an undo.\n\nParameters:\n\nn - Node.\n\nReturns: None\nNone"
    }, 
    {
        "devnull (posixpath)": "devnull = '/dev/null'"
    }, 
    {
        "DOTALL (re)": "DOTALL = 16"
    }, 
    {
        "deleteAnimation() (Array_Knob)": "deleteAnimation(self,\n        curve)\n\n\u00a0\n    \n\nRaises ValueError if not found. Deletes the AnimationCurve.\n\nParameters:\n\ncurve - An AnimationCurve instance which belongs to this Knob.\n\nReturns: None\nNone. Raises ValueError if not found."
    }, 
    {
        "Double_Knob (nuke)": null
    }, 
    {
        "deleteNodePreset() (nukescripts.nodepresets)": null
    }, 
    {
        "dialogKnobChanged() (FlipbookApplication)": "dialogKnobChanged(self,\n        dialog,\n        knob)\n\nsource\u00a0code\u00a0\n    \n\nCalled whenever this flipbook is selected and one of the knobs added \n  in dialogKnobs was changed.\n\nParameters:\n\ndialog - The FlipbookDialog that contains the knob\nknob - The knob added in dialogKnobs that was modified.\n\nReturns:\nNone"
    }, 
    {
        "DrawChildren (RenderFlag)": "values\n\n\n\nValue:\n\n{'DrawChildren': PySide.QtGui.QWidget.RenderFlag.DrawChildren,\n 'DrawWindowBackground': PySide.QtGui.QWidget.RenderFlag.DrawWindowBac\nkground,\n 'IgnoreMask': PySide.QtGui.QWidget.RenderFlag.IgnoreMask}"
    }, 
    {
        "deletePreset() (nuke)": "deletePreset(nodeClassName,\n        presetName)\n\n\u00a0\n    \n\nDeletes a pre-created node preset\n\nParameters:\n\nnodeClassName - Name of the node class to create a preset for.\npresetName - Name of the preset to create.\n\nReturns: None\nbool."
    }, 
    {
        "dialogKnobs() (FlipbookApplication)": "dialogKnobs(self,\n        dialog)\n\nsource\u00a0code\u00a0\n    \n\nThis is called when the user has selected this flipbook application, \n  and will be interested in any knobs that you might have to show for \n  custom settings.\n\nParameters:\n\ndialog - The FlipbookDialog that has requested the knobs to be added to \n          it, e.g. dialog.addKnob(...)\n\nReturns:\nNone"
    }, 
    {
        "DrawWindowBackground (RenderFlag)": "DrawWindowBackground\n\n\n\nValue:\n\nPySide.QtGui.QWidget.RenderFlag.DrawWindowBackground"
    }, 
    {
        "deletePreset() (PresetsDeletePanel)": null
    }, 
    {
        "DialogState (nukescripts.renderdialog)": null
    }, 
    {
        "drop (nukescripts)": null
    }, 
    {
        "deletePreset() (UserPresetsDeletePanel)": null
    }, 
    {
        "dim (AnimControlPoint)": "dim\n      The dimensionality, or number of components, for this control point \n      (usually 3 - x, y and pressure)."
    }, 
    {
        "dropData() (nukescripts.drop)": "dropData(mimeType,\n        text)\n      Handle data drops by invoking the list of callback functions until \n      one has handled the event\n\nsource\u00a0code"
    }, 
    {
        "eAColorKnob (KnobType)": null
    }, 
    {
        "enabled() (Knob)": "enabled(self)\n\n\u00a0\n    \n\n\nReturns: Boolean\nTrue if the knob is enabled, False if it's disabled."
    }, 
    {
        "evaluate() (Stroke)": "evaluate(self,\n        time,\n        viewName='default')\n\n\u00a0\n    \n\nBake out a curve for the path of this stroke at the specified \n  time.\n\nParameters:\n\ntime - The (floating point) frame number to bake the curve from.\nviewName - Optional parameter specifying which view to bake the curve from. \n          If omitted, the default view will be used.\n\nReturns: CubicCurve"
    }, 
    {
        "eActiveFlag (FlagType)": null
    }, 
    {
        "enabled() (LinkableKnobInfo)": "enabled(self)\n      Returns whether the knob is currently enabled or not.\n\nsource\u00a0code"
    }, 
    {
        "evaluate() (AnimCTransform)": "evaluate(self,\n        time,\n        view)"
    }, 
    {
        "eArrayKnob (KnobType)": null
    }, 
    {
        "end() (Group)": "end(self)\n\n\u00a0\n    \n\nAll python code that follows will no longer be executed in the context\n  of node. Must be paired with begin.\n\nReturns: None\nNone."
    }, 
    {
        "evaluate() (AnimControlPoint)": "evaluate(self,\n        time,\n        view)\n      Evaluates the animated control point's position at the specific time."
    }, 
    {
        "eAxisKnob (KnobType)": null
    }, 
    {
        "end() (Undo)": "end(...)\n      Complete current undo set and add it to the undo list."
    }, 
    {
        "evaluate() (AnimCurve)": "evaluate(self,\n        time)\n\n\u00a0\n    \n\nCalculate the value of the curve at a specific time, the pass that in \n  to the expression for the curve. The return value is the result of the \n  expression.\n\nReturns: float"
    }, 
    {
        "eBBoxKnob (KnobType)": null
    }, 
    {
        "evaluate() (AnimationCurve)": "evaluate(self,\n        t)\n\n\u00a0\n    \n\nValue at time 't'.\n\nParameters:\n\nt - Time.\n\nReturns: float\nThe value of the animation at time 't'."
    }, 
    {
        "eBezierCurveType (CurveType)": null
    }, 
    {
        "endGroup() (nuke)": "endGroup()\n\n\u00a0\n    \n\nDeprecated. Use Group.run, Group.begin/Group.end pairs or (preferably)\n  the with statement.\nChanges the current group to the parent of the current group. Does \n  nothing if the current group is a Root (the main window of a script).\n\nReturns: None\nNone."
    }, 
    {
        "evaluate() (EvalString_Knob)": "evaluate(self)\n\n\u00a0\n    \n\nEvaluate the string, performing substitutions.\n\nReturns: String\nString."
    }, 
    {
        "eBitMaskKnob (KnobType)": null
    }, 
    {
        "ENDLINE (nuke)": "ENDLINE = 8192"
    }, 
    {
        "evaluateY() (AnimCurve)": "evaluateY(self,\n        time)\n      Calculates the value of the curve at a specific time."
    }, 
    {
        "eBoolKnob (KnobType)": null
    }, 
    {
        "EndTabGroup_Knob (nuke)": null
    }, 
    {
        "eViewPairKnob (KnobType)": null
    }, 
    {
        "eBox3Knob (KnobType)": null
    }, 
    {
        "eNukeAnimCurveEvalFlag (FlagType)": null
    }, 
    {
        "eViewViewKnob (KnobType)": null
    }, 
    {
        "eBreakFlag (FlagType)": null
    }, 
    {
        "Enumeration_Knob (nuke)": null
    }, 
    {
        "eVisibleFlag (FlagType)": null
    }, 
    {
        "eBSplineCurveType (CurveType)": null
    }, 
    {
        "enumerationPulldown (nukescripts.panel_test)": null
    }, 
    {
        "eVSpacerKnob (KnobType)": null
    }, 
    {
        "eCachedFileKnob (KnobType)": null
    }, 
    {
        "enumName() (Enumeration_Knob)": "enumName(self,\n        n)\n\n\u00a0\n    \n\nReturn name of enumeration n. The argument n is an integer and in the \n  range of 0 and numValues. Deprecated.\n\nReturns: string"
    }, 
    {
        "eWHKnob (KnobType)": null
    }, 
    {
        "eCancelExecutionKnob (KnobType)": null
    }, 
    {
        "eNurbsCurveType (CurveType)": null
    }, 
    {
        "EX_CANTCREAT (os)": "EX_CANTCREAT = 73"
    }, 
    {
        "eCardinalCurveType (CurveType)": null
    }, 
    {
        "env (nuke)": "env\n\n\n\nValue:\n\n{'64bit': True, 'EXPERIMENTAL': True, 'ExecutablePath': '/workspace/pe\nter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-release-410/Bundle/Nu\nke7.0', 'LINUX': True, 'MACOS': False, 'NukeVersionDate': 'Nov 23 2012\n', 'NukeVersionMajor': 7, 'NukeVersionMinor': 0, 'NukeVersionPhase': '\nd', 'NukeVersionPhaseNumber': 0, 'NukeVersionRelease': 0, 'NukeVersion\nString': '7.0v0d0', 'PluginExtension': 'so', 'PluginsVerbose': False, \n'WIN32': False, 'debugval': 0, 'gui': False, 'interactive': True, 'nuk\nex': False, 'numCPUs': 16, 'ple': False, 'threads': 16}"
    }, 
    {
        "EX_CONFIG (os)": "EX_CONFIG = 78"
    }, 
    {
        "eCascadingEnumerationKnob (KnobType)": null
    }, 
    {
        "environ (os)": "environ\n\n\n\nValue:\n\n{'TMP': '/tmp', 'NUKE_TEMP_DIR': '/tmp/nuke', 'TEMP': '/tmp', 'SHLVL':\n '1', 'FOUNDRY_LICENSE_FILE': '30003@mother', 'PWD': '/workspace/peter\n/7.0dev_3', '_': 'Apps/Nuke/nuke/objects/linux-64-x86-release-410/Bund\nle/Nuke7.0', 'PATH': '/workspace/peter/7.0dev_3/Thirdparty/IntelCompil\ner/12.1.0258/bin/linux-64/bin:/usr/bin/:/usr/local/bin:/opt/bin:/bin',\n 'TMPDIR': '/tmp'}"
    }, 
    {
        "EX_DATAERR (os)": "EX_DATAERR = 65"
    }, 
    {
        "eCatmullRomCurveType (CurveType)": null
    }, 
    {
        "eObsoleteKnob (KnobType)": null
    }, 
    {
        "EX_IOERR (os)": "EX_IOERR = 74"
    }, 
    {
        "eChannelKnob (KnobType)": null
    }, 
    {
        "eOneViewKnob (KnobType)": null
    }, 
    {
        "EX_NOHOST (os)": "EX_NOHOST = 68"
    }, 
    {
        "eChannelMaskKnob (KnobType)": null
    }, 
    {
        "eOpenFlag (FlagType)": null
    }, 
    {
        "EX_NOINPUT (os)": "EX_NOINPUT = 66"
    }, 
    {
        "eColorChipKnob (KnobType)": null
    }, 
    {
        "ePasswordKnob (KnobType)": null
    }, 
    {
        "EX_NOPERM (os)": "EX_NOPERM = 77"
    }, 
    {
        "eColorKnob (KnobType)": null
    }, 
    {
        "ePixelAspectKnob (KnobType)": null
    }, 
    {
        "EX_NOUSER (os)": "EX_NOUSER = 67"
    }, 
    {
        "eConstantExtrapolationType (ExtrapolationType)": null
    }, 
    {
        "ePluginPythonKnob (KnobType)": null
    }, 
    {
        "EX_OK (os)": "EX_OK = 0"
    }, 
    {
        "eControlPointCollectionKnob (KnobType)": null
    }, 
    {
        "ePositionVectorKnob (KnobType)": null
    }, 
    {
        "EX_OSERR (os)": "EX_OSERR = 71"
    }, 
    {
        "eCpKnob (KnobType)": null
    }, 
    {
        "ePressureInZFlag (FlagType)": null
    }, 
    {
        "EX_OSFILE (os)": "EX_OSFILE = 72"
    }, 
    {
        "eCubicInterpolationType (InterpolationType)": null
    }, 
    {
        "ePulldownKnob (KnobType)": null
    }, 
    {
        "EX_PROTOCOL (os)": "EX_PROTOCOL = 76"
    }, 
    {
        "eCustomKnob (KnobType)": null
    }, 
    {
        "ePyPulldownKnob (KnobType)": null
    }, 
    {
        "EX_SOFTWARE (os)": "EX_SOFTWARE = 70"
    }, 
    {
        "eCycleExtrapolationType (ExtrapolationType)": null
    }, 
    {
        "ePyScriptKnob (KnobType)": null
    }, 
    {
        "EX_TEMPFAIL (os)": "EX_TEMPFAIL = 75"
    }, 
    {
        "edit (nukescripts)": null
    }, 
    {
        "ePythonKnob (KnobType)": null
    }, 
    {
        "EX_UNAVAILABLE (os)": "EX_UNAVAILABLE = 69"
    }, 
    {
        "editCurve() (LookupCurves_Knob)": "editCurve(self,\n        curve,\n        expr=None)\n\n\u00a0\n    \n\nEdits an existing curve.\n\nParameters:\n\ncurve - The name of an animation curve.\nexpr - The new expression for the curve.\n\nReturns: None\nNone"
    }, 
    {
        "eRangeKnob (KnobType)": null
    }, 
    {
        "EX_USAGE (os)": "EX_USAGE = 64"
    }, 
    {
        "EditNextItem (EndEditHint)": "EditNextItem\n\n\n\nValue:\n\nPySide.QtGui.QAbstractItemDelegate.EndEditHint.EditNextItem"
    }, 
    {
        "eRelativeTangentFlag (FlagType)": null
    }, 
    {
        "ExampleRVFlipbook (nukescripts.pyQtExamples.flipbookingExample)": null
    }, 
    {
        "EditPreviousItem (EndEditHint)": "EditPreviousItem\n\n\n\nValue:\n\nPySide.QtGui.QAbstractItemDelegate.EndEditHint.EditPreviousItem"
    }, 
    {
        "eRenderableFlag (FlagType)": null
    }, 
    {
        "exc_type (sys)": "exc_type = None"
    }, 
    {
        "eDoubleKnob (KnobType)": null
    }, 
    {
        "eRightTangentSelectedFlag (FlagType)": null
    }, 
    {
        "EXE_PATH (nuke)": "EXE_PATH\n\n\n\nValue:\n\n'/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-release\n-410/Bundle/Nuke7.0'"
    }, 
    {
        "eDynamicBitmaskKnob (KnobType)": null
    }, 
    {
        "eRippleKnob (KnobType)": null
    }, 
    {
        "exec_prefix (sys)": "exec_prefix\n\n\n\nValue:\n\n'/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-release\n-410/Bundle'"
    }, 
    {
        "eEnumKnob (KnobType)": null
    }, 
    {
        "executable (sys)": "executable\n\n\n\nValue:\n\n'/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-release\n-410/Bundle/Nuke7.0'"
    }, 
    {
        "eExoGroupKnob (KnobType)": null
    }, 
    {
        "error() (Knob)": "error(self,\n        message)\n\n\u00a0\n    \n\n\nParameters:\n\nmessage - message to put the knob in error.\n\nReturns: None\nNone."
    }, 
    {
        "execute (nukescripts)": null
    }, 
    {
        "eEyeDropperKnob (KnobType)": null
    }, 
    {
        "error() (Node)": "error()\n\n\u00a0\n    \n\nTrue if the node or any in its input tree have an error, or False \n  otherwise.\nError state of the node and its input tree.  Deprecated; use hasError \n  or treeHasError instead. Note that this will always return false for \n  viewers, which cannot generate their input trees.  Instead, choose an \n  input of the viewer (e.g. the active one), and call treeHasError() on \n  that.\n\nReturns: bool"
    }, 
    {
        "execute() (Panel)": "execute(self,\n        name)\n\n\u00a0\n    \n\nExecute the script command associated with a particular label and \n  return the result as a string.\n\nParameters:\n\nname - The name of the script field to execute.\n\nReturns: The result of the script as a string, or None if it fails\nThe result of the script as a string, or None if it fails."
    }, 
    {
        "eFileKnob (KnobType)": null
    }, 
    {
        "error() (nuke)": "error(message)\n\n\u00a0\n    \n\nPuts the message into the error console, treating it like an \n  error.\n\nParameters:\n\nmessage - String parameter.\n\nReturns: None\nNone."
    }, 
    {
        "execute() (Script_Knob)": "execute(self)\n\n\u00a0\n    \n\nExecute the command.\n\nReturns: None\nNone."
    }, 
    {
        "eFloatKnob (KnobType)": null
    }, 
    {
        "eRSTTransformOrder (TransformOrder)": null
    }, 
    {
        "execute() (nuke)": "execute(nameOrNode,\n        start,\n        end,\n        incr,\n        views,\n        continueOnError= False)\n\n\u00a0\n    \n\nexecute(nameOrNode, frameRangeSet, views, continueOnError = False) \n  -> None.\nExecute the named Write node over the specified frames.\nThere are two variants of this function. The first allows you to \n  specify the frames to write range by giving the start frame number, the \n  end frame number and the frame increment. The second allows you to \n  specify more complicated sets of frames by providing a sequence of \n  FrameRange objects.\nIf Nuke is run with the GUI up, this will pop up a progress meter. If \n  the user hits the cancel button this command will return 'cancelled' \n  error. If Nuke is run from the nuke command line (ie nuke was started \n  with the -t switch) execute() prints a text percentage as it progresses. \n  If the user types ^C it will aborting the execute() and return a \n  'cancelled' error.\n\nParameters:\n\nnameOrNode - A node name or a node object.\nstart - Optional start frame. Default is root.first_frame.\nend - Optional end frame. Default is root.last_frame.\nincr - Optional increment. Default is 1.\nviews - Optional list of views. Default is None, meaning \"all \n          views\".\n\nReturns: None\nNone"
    }, 
    {
        "eFormatKnob (KnobType)": null
    }, 
    {
        "eRTSTransformOrder (TransformOrder)": null
    }, 
    {
        "execute_panel() (nukescripts.execute)": null
    }, 
    {
        "eFrameRangeTypeAll (FrameRangeType)": null
    }, 
    {
        "eScaleKnob (KnobType)": null
    }, 
    {
        "executeBackgroundNuke() (nuke)": "executeBackgroundNuke(exe_path,\n        nodes,\n        frameRange,\n        views,\n        limits,\n        continueOnError= False,\n        flipbookToRun= ,\n        flipbookOptions= {})\n\n\u00a0\n    \n\nRun an instance of Nuke as a monitored sub process. Returns an integer\n  that's used as unique id for the started task. If it failed to launch \n  this will be -1.\n\nParameters:\n\nexe_path - Path to Nuke or a script that can take Nuke arguments. You \n          probably want to supply nuke.EXE_PATH.\nnodes - A list of nodes to execute.\nframeRanges - List of frame ranges to execute.\nviews - A list of view names to execute.\nlimits - A dictionary with system limits, currently uses keys maxThreads \n          and maxCache.\nflipbookToRun - The name of the flipbook application to run after the render, or \n          an empty string if not desired.\nflipbookOptions - A dictionary with options to pass to the flipbook. These should \n          include roi and pixelAspect.\n\nReturns: None\nInt."
    }, 
    {
        "eFrameRangeTypeFromStart (FrameRangeType)": null
    }, 
    {
        "eSceneViewKnob (KnobType)": null
    }, 
    {
        "executeDeferred() (nukescripts.utils)": null
    }, 
    {
        "eFrameRangeTypeFromStartToEnd (FrameRangeType)": null
    }, 
    {
        "eScriptKnob (KnobType)": null
    }, 
    {
        "ExecuteDialog (nukescripts.renderdialog)": null
    }, 
    {
        "eFrameRangeTypeSingle (FrameRangeType)": null
    }, 
    {
        "eSelectedFlag (FlagType)": null
    }, 
    {
        "executeInMain (nuke)": null
    }, 
    {
        "eFrameRangeTypeToEnd (FrameRangeType)": null
    }, 
    {
        "eSimpleArrayKnob (KnobType)": null
    }, 
    {
        "executeInMainThread() (nuke.executeInMain)": null
    }, 
    {
        "eGeoSelectKnob (KnobType)": null
    }, 
    {
        "eSizeKnob (KnobType)": null
    }, 
    {
        "executeInMainThreadWithResult() (nuke.executeInMain)": null
    }, 
    {
        "eGPUEngineKnob (KnobType)": null
    }, 
    {
        "eSpacerKnob (KnobType)": null
    }, 
    {
        "executeMultiple() (nuke)": "executeMultiple(nodes,\n        ranges,\n        views,\n        continueOnError=False)\n\n\u00a0\n    \n\nExecute the current script for a specified frame range. The argument \n  nodes is a sequence of Nuke nodes and ranges is a sequence of range \n  lists. A Nuke range list is a sequence of 3 integers - first, last and \n  incr ( e.g. nuke.execute((w,), ((1,100,1),)) ). The named nodes must all \n  be Write or other executable operators. If no nodes are given then all \n  executable nodes in the current group are executed. Note that DiskCache \n  and Precomp nodes do not get executed with this call, unless explicitly \n  specified.\nIf Nuke is run with the GUI up, this will pop up a progress meter. If \n  the user hits the cancel button this command will raise a 'cancelled' \n  error. If Nuke is run in terminal mode (with the -t switch) this prints a\n  text percentage as it progresses.\nIf the user types ^C it will abort the execute() and raise a \n  'cancelled' error.\n\nParameters:\n\nnodes - Node list.\nranges - Optional start frame. Default is root.first_frame.\nviews - Optional list of views. Default is None. Execute for all.\n\nReturns: None\nNone"
    }, 
    {
        "eHelpKnob (KnobType)": null
    }, 
    {
        "eSRTTransformOrder (TransformOrder)": null
    }, 
    {
        "exists() (nuke)": "exists(s)\n\n\u00a0\n    \n\nCheck for the existence of a named item. Function for \n  backwards-compatibility with TCL.\n\nParameters:\n\ns - Name of item.\n\nReturns: bool\nTrue if exists, False otherwise."
    }, 
    {
        "eHermiteCurveType (CurveType)": null
    }, 
    {
        "eStepInterpolationType (InterpolationType)": null
    }, 
    {
        "expand() (Group)": "expand(self)\n\n\u00a0\n    \n\nMoves all nodes from the group node into its parent group, maintaining\n  node input and output connections, and deletes the group. Returns the \n  nodes that were moved, which will also be selected.\n\nReturns: None\nNone."
    }, 
    {
        "eHistogramKnob (KnobType)": null
    }, 
    {
        "eStringKnob (KnobType)": null
    }, 
    {
        "EXPAND_TO_WIDTH (nuke)": "EXPAND_TO_WIDTH = 68719476736"
    }, 
    {
        "eInputOnlyChannelKnob (KnobType)": null
    }, 
    {
        "eSTRTransformOrder (TransformOrder)": null
    }, 
    {
        "expandSelectedGroup() (nuke)": "expandSelectedGroup()\n\n\u00a0\n    \n\nMoves all nodes from the currently selected group node into its parent\n  group, maintaining node input and output connections, and deletes the \n  group. Returns the nodes that were moved, which will also be \n  selected.\n\nReturns: None\nNone"
    }, 
    {
        "eInputOnlyChannelMaskKnob (KnobType)": null
    }, 
    {
        "eTabGroupKnob (KnobType)": null
    }, 
    {
        "export_nodes_as_script() (nukescripts.importexport)": "export_nodes_as_script()\n\nsource\u00a0code"
    }, 
    {
        "eIntKnob (KnobType)": null
    }, 
    {
        "eTabKnob (KnobType)": null
    }, 
    {
        "expr() (nuke)": "expr(s)\n\n\u00a0\n    \n\nParse a Nuke expression. Runs the same expression parser as is used by\n  animations. This is not the same as the tcl expr parser. The main \n  differences are:\n\n\n      Only floating point numbers are calculated. There are no strings, \n      boolean, or integer values.\n    \n\n      You can name any knob that returns a floating point value, with a \n      dot-separated name, see knob for details on these names. You may \n      follow the knob name with a time in parenthesis (like a function \n      call) and if it is animated it will be evaluated at that time. If it \n      is animated and no time is given, 'frame' is used.\n    \n\n      The words 'frame', 't', and 'x' evaluate to the frame number of the \n      context node, or the frame number this animation is being evaluated \n      at.\n    \n\n      The word 'y' in an animation expression evaluates to the value the \n      animation would have if the control points were used and there was no\n      expression. Outside an animation expression y returns zero.\n    \n\n\nParameters:\n\ns - The expression, as a string.\n\nReturns: float\nThe result."
    }, 
    {
        "eKeyerKnob (KnobType)": null
    }, 
    {
        "eTableKnob (KnobType)": null
    }, 
    {
        "expression() (AnimationCurve)": "expression(self)\n      Get the expression.@return: String."
    }, 
    {
        "eKeySelectedFlag (FlagType)": null
    }, 
    {
        "eTangentLengthLockFlag (FlagType)": null
    }, 
    {
        "expression() (nuke)": "animation(object,\n        *commands)\n\n\u00a0\n    \n\nDoes operations on an animation curve.\nThe following commands are supported:\n\n\nclear deletes all the keys from the animation.\n    \n\nerase index last_index removes all \n      keyframes between index and last_index\n    \n\nexpression newvalue returns or sets the \n      expression for the animation. The default is 'curve' or 'y' which \n      returns the interpolation of the keys.\n    \n\ngenerate start end increment field expression field \n      expression ... generates an animation with start, end, and\n      increment. Multiple field/expression pairs generate a keyframe. \n      Possible field commands are:\n      \n\nx sets the frame number for the next keyframe\n        \n\ny sets the keyframe value\n        \n\ndy sets the left slope\n        \n\nldy sets left and right slope to the same value\n        \n\nla and ra are the length of the slope handle in x \n          direction. A value of 1 generates a handle that is one third of \n          the distance to the next keyframe.\n        \n\n\n\nindex x returns the index of the last key with x \n      <= t, return -1 for none.\n    \n\nis_key return non-zero if there is a key with x == t. The \n      actual return value is the index+1.\n    \n\nmove field expression field expression \n      replaces all selected keys in an animation with new ones as explained\n      above in generate\n\n\nname returns a user-friendly name for this animation. This \n      will eliminate any common prefix between this animation and all other\n      selected ones, and also replaces mangled names returned by animations\n      with nice ones.\n    \n\nsize returns the number of keys in the animation.\n    \n\ntest errors if no points in the animation are selected\n    \n\ny index newvalue gets or sets the value of\n      an animation.\n    \n\nx index newvalue gets or sets the \n      horizontal postion of a key. If the animation contains an expression \n      or keyframes, the new value will be overridden.\n    \n\nSee also: animations\n\nParameters:\n\nobject - The animation curve.\ncommands - a varargs-style list of commands, where each command is one of \n          those defined above.\n\nReturns: None\nNone"
    }, 
    {
        "eLeftTangentSelectedFlag (FlagType)": null
    }, 
    {
        "eTextEditorKnob (KnobType)": null
    }, 
    {
        "expressionInput (nukescripts.panel_test)": null
    }, 
    {
        "Element (_curveknob)": null
    }, 
    {
        "eTextKnob (KnobType)": null
    }, 
    {
        "EXPRESSIONS (nuke)": "EXPRESSIONS = 1"
    }, 
    {
        "eLinearExtrapolationType (ExtrapolationType)": null
    }, 
    {
        "eToolbarKnob (KnobType)": null
    }, 
    {
        "expressionString (AnimCurve)": "expressionString\n      The expression string for the this curve, if any."
    }, 
    {
        "eLinearInterpolationType (InterpolationType)": null
    }, 
    {
        "eToolboxKnob (KnobType)": null
    }, 
    {
        "extract() (nukescripts.edit)": "extract()\n\nsource\u00a0code\u00a0\n    \n\nDisconnect all arrows between selected and unselected nodes, and move \n  selected nodes to the right. This function is maintained only for \n  compatibility.  Please use nuke.extractSelected() instead."
    }, 
    {
        "eLinkKnob (KnobType)": null
    }, 
    {
        "eTooltipKnob (KnobType)": null
    }, 
    {
        "extractSelected() (nuke)": "extractSelected()\n\n\u00a0\n    \n\nDisconnects the selected nodes in the group from the tree, and shifts \n  them to the side.\n\nReturns: None\nNone"
    }, 
    {
        "eListKnob (KnobType)": null
    }, 
    {
        "eTransform2DKnob (KnobType)": null
    }, 
    {
        "extrapolation (AnimationKey)": "extrapolation\n      Controls how to set the left slope of the first point and the right \n      slope of the last point"
    }, 
    {
        "eLockedFlag (FlagType)": null
    }, 
    {
        "eTransformJackKnob (KnobType)": null
    }, 
    {
        "ExtrapolationType (_curvelib)": null
    }, 
    {
        "eLookupCurvesKnob (KnobType)": null
    }, 
    {
        "eTRSTransformOrder (TransformOrder)": null
    }, 
    {
        "extsep (os)": "extsep = '.'"
    }, 
    {
        "eMaxFlag (FlagType)": null
    }, 
    {
        "eTSRTransformOrder (TransformOrder)": null
    }, 
    {
        "extsep (posixpath)": "extsep = '.'"
    }, 
    {
        "eMenuKnob (KnobType)": null
    }, 
    {
        "eUndefineCurveType (CurveType)": null
    }, 
    {
        "eXYKnob (KnobType)": null
    }, 
    {
        "eMetaDataKnob (KnobType)": null
    }, 
    {
        "eUndefineExtrapolationType (ExtrapolationType)": null
    }, 
    {
        "eXYZKnob (KnobType)": null
    }, 
    {
        "eMetaKeyFrameKnob (KnobType)": null
    }, 
    {
        "eUndefineFlag (FlagType)": null
    }, 
    {
        "eXYZRotationOrder (RotationOrder)": null
    }, 
    {
        "eMultiArrayKnob (KnobType)": null
    }, 
    {
        "eUndefineInterpolationType (InterpolationType)": null
    }, 
    {
        "eXZYRotationOrder (RotationOrder)": null
    }, 
    {
        "eMultilineEvalStringKnob (KnobType)": null
    }, 
    {
        "eUndefineRotationOrder (RotationOrder)": null
    }, 
    {
        "Eyedropper_Knob (nuke)": null
    }, 
    {
        "eMultilineStringKnob (KnobType)": null
    }, 
    {
        "eUndefineTransformOrder (TransformOrder)": null
    }, 
    {
        "eYXZRotationOrder (RotationOrder)": null
    }, 
    {
        "eMultiViewKnob (KnobType)": null
    }, 
    {
        "eUVKnob (KnobType)": null
    }, 
    {
        "eYZXRotationOrder (RotationOrder)": null
    }, 
    {
        "enable() (Undo)": "enable(...)\n      Undoes the previous disable()"
    }, 
    {
        "EvalString_Knob (nuke)": null
    }, 
    {
        "eZXYRotationOrder (RotationOrder)": null
    }, 
    {
        "enableChannel() (Channel_Knob)": "enableChannel(self,\n        name,\n        b)\n\n\u00a0\n    \n\nEnable or disable a channel.\n\nParameters:\n\nname - The name of the channel.\nb - True to enable the channel, False to disable it.\n\nReturns: None\nNone"
    }, 
    {
        "evaluate() (Shape)": "evaluate(self,\n        curveNum,\n        time,\n        viewName='default')\n\n\u00a0\n    \n\nBake out a curve for the outline of this shape at the specified \n  time.\nNote that the feather curve is represented as an offset from the main \n  curve. If you want to get the screen position of a point along the \n  feather curve, you'll need to add it to the corresponding position on the\n  main curve. For example:\n\n>>> frameNum = 10.0\n>>> t = 0.5\n>>> rotoknob = nuke.toNode('RotoPaint1')['curves']\n>>> shape = rotoknob.toElement('Bezier1')\n>>> mainCurve = shape.evaluate(0, frameNum)\n>>> featherCurve = shape.evaluate(1, frameNum)\n>>> pointOnMainCurve = mainCurve.getPoint(t)\n>>> featherOffset = featherCurve.getPoint(t)\n>>> pointOnFeatherCurve = pointOnMainCurve + featherOffset\n\nParameters:\n\ncurveNum - 0 for the main curve, 1 for the feather curve.\ntime - The (floating point) frame number to bake the curve from.\nviewName - Optional parameter specifying which view to bake the curve from. \n          If omitted, the default view will be used.\n\nReturns: CubicCurve"
    }, 
    {
        "eZYXRotationOrder (RotationOrder)": null
    }, 
    {
        "f() (Box3_Knob)": "f(...)\n\n\u00a0\n    \n\nReturn value for F extent. F (far) is the maximum Z extent of the \n  box."
    }, 
    {
        "flags (nukescripts)": null
    }, 
    {
        "frameControl() (ViewerWindow)": "frameControl(self,\n        i)\n\n\u00a0\n    \n\n\ni is an integer indicating viewer frame control 'button' to execute:\n\n   -6 go to start\n   -5 play reverse\n   -4 go to previous keyframe\n   -3 step back by increment\n   -2 go back previous keyframe or increment, whichever is closer\n   -1 step back one frame\n\n    0 stop\n\n   +1 step forward one frame\n   +2 go to next keyframe or increment, whichever is closer\n   +3 step forward by increment\n   +4 go to next keyframe\n   +5 play forward\n   +6 go to end\n\n\n\nReturns: True"
    }, 
    {
        "F_OK (os)": "F_OK = 0"
    }, 
    {
        "flags (sys)": "flags\n\n\n\nValue:\n\nsys.flags(debug=0, py3k_warning=0, division_warning=0, division_new=0,\n inspect=0, interactive=0, optimize=0, dont_write_bytecode=0, no_user_\nsite=0, no_site=0, ignore_environment=0, tabcheck=0, verbose=0, unicod\ne=0, bytes_warning=0)"
    }, 
    {
        "framecycler (nukescripts)": null
    }, 
    {
        "fc (nukescripts.framecycler)": "fc = FramecyclerFlipbook()"
    }, 
    {
        "FlagType (_curvelib)": null
    }, 
    {
        "framecycler_linux_version() (nukescripts.run_framecycler)": "framecycler_linux_version()\n\nsource\u00a0code"
    }, 
    {
        "fc_path (nukescripts.run_framecycler)": "fc_path\n\n\n\nValue:\n\n'/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-release\n-410/Bundle/FrameCyclerCentOS5/bin/framecycler'"
    }, 
    {
        "flip (nukescripts)": null
    }, 
    {
        "framecycler_sequence() (nukescripts.run_framecycler)": "framecycler_sequence(frange,\n        filename,\n        cmd_args_size)\n\nsource\u00a0code"
    }, 
    {
        "fc_suffix (nukescripts.run_framecycler)": "fc_suffix = ''"
    }, 
    {
        "flipbook() (nukescripts.flip)": "flipbook(command,\n        node,\n        framesAndViews=None)\n\nsource\u00a0code\u00a0\n    \n\nRuns an arbitrary command on the images output by a node. This checks \n  to see if the node is a Read or Write and calls the function directly \n  otherwise it creates a temporary Write, executes it, and then calls the \n  command on that temporary Write, then deletes it.\nBy writing your own function you can use this to launch your own \n  flipbook or video-output programs.\nSpecify framesAndViews as a tuple if desired, like so: \n  (\"1,5\", [\"main\"]) This can be useful when running \n  without a GUI."
    }, 
    {
        "framecycler_stereo_available() (nukescripts.run_framecycler)": "framecycler_stereo_available()\n      This function used to detect if we were running on Mac OS Tiger; we \n      no longer support Tiger, so this function always returns true now.\n\nsource\u00a0code"
    }, 
    {
        "fcBasePath (nukescripts.framecycler)": "fcBasePath\n\n\n\nValue:\n\n'/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-release\n-410/Bundle/FrameCyclerCentOS5'"
    }, 
    {
        "FlipbookApplication (nukescripts.flipbooking)": null
    }, 
    {
        "framecycler_this() (nukescripts.run_framecycler)": "framecycler_this(node,\n        start,\n        end,\n        incr,\n        view)\n\nsource\u00a0code\u00a0\n    \n\nRun framecycler on a Read or Write node. See the flipbook command for \n  how we run framecycler on *any* node."
    }, 
    {
        "fcBinPath (nukescripts.framecycler)": "fcBinPath\n\n\n\nValue:\n\n'/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-release\n-410/Bundle/FrameCyclerCentOS5/bin'"
    }, 
    {
        "FlipbookDialog (nukescripts.renderdialog)": null
    }, 
    {
        "FramecyclerFlipbook (nukescripts.framecycler)": null
    }, 
    {
        "featherCenter (ShapeControlPoint)": "featherCenter\n      The feather point offsets, relative to the center point"
    }, 
    {
        "FlipbookFactory (nukescripts.flipbooking)": null
    }, 
    {
        "FrameRange (nuke)": null
    }, 
    {
        "featherLeftTangent (ShapeControlPoint)": "featherLeftTangent\n      The left feather tangent offsets, relative to the feather center \n      point."
    }, 
    {
        "flipbooking (nukescripts)": null
    }, 
    {
        "frameRange() (Node)": "frameRange(self)\n\n\u00a0\n    \n\nFrame range for this node.\n\nReturns: FrameRange\nFrameRange."
    }, 
    {
        "featherRightTangent (ShapeControlPoint)": "featherRightTangent\n      The right feather tangent offsets, relative to the feather center \n      point."
    }, 
    {
        "flipbookingExample (nukescripts.pyQtExamples)": null
    }, 
    {
        "framerangepanel (nukescripts)": null
    }, 
    {
        "File_Knob (nuke)": null
    }, 
    {
        "flipbookKnobs() (FlipbookDialog)": "flipbookKnobs(self)\n\nsource\u00a0code"
    }, 
    {
        "FrameRangePanel (nukescripts.framerangepanel)": null
    }, 
    {
        "filename() (Gizmo)": "filename(self)\n\n\u00a0\n    \n\nGizmo filename.\n\nReturns: String\nString."
    }, 
    {
        "FlipbookLUTPathRegistry (nukescripts.flipbooking)": null
    }, 
    {
        "FrameRanges (nuke)": null
    }, 
    {
        "filename() (nuke)": "autoSaveDeleteFilter(filename)\n\nsource\u00a0code\u00a0\n    \n\nInternal function.  Use addAutoSaveDeleteFilter to add a callback"
    }, 
    {
        "FLOAT (nuke)": "FLOAT = 5"
    }, 
    {
        "FrameRangeType (_rotopaint)": null
    }, 
    {
        "filenameFilter() (nuke.callbacks)": "filenameFilter(filename)\n\nsource\u00a0code"
    }, 
    {
        "float_info (sys)": "float_info\n\n\n\nValue:\n\nsys.floatinfo(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=30\n8, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15\n, mant_dig=53, epsilon=2.2204460492503131e-16, radix=2, rounds=1)"
    }, 
    {
        "frames() (FrameRange)": "frames(self)\n      return the numbers of frames defined in the range."
    }, 
    {
        "filenameFilters (nuke.callbacks)": "filenameFilters = {}"
    }, 
    {
        "FnPySingleton (nuke.utils)": null
    }, 
    {
        "fromByte() (Lut)": "fromByte(self,\n        float)\n      Converts byte values in the range 0-255 to floating point."
    }, 
    {
        "filenameFilters (nuke)": "filenameFilters = {}"
    }, 
    {
        "FONT (nuke)": "FONT = 4"
    }, 
    {
        "fromByteSingle() (Lut)": "fromByteSingle(self,\n        float)\n      Converts byte values in the range 0-255 to floating point."
    }, 
    {
        "filenameSearch (nukescripts.panel_test)": null
    }, 
    {
        "Font_Knob (nuke)": null
    }, 
    {
        "fromDict() (BBox_Knob)": "fromDict(self,\n        box)\n\n\u00a0\n    \n\nSet the bounding box from the given box.\n\nParameters:\n\nbox - Dictionary containing the x, y, r and t keys.\n\nReturns: None\nNone"
    }, 
    {
        "filterRIB() (nukescripts.renderman)": null
    }, 
    {
        "forceClone() (nuke)": "forceClone()\n\n\u00a0\n    \n\n\nReturns: bool\nTrue if succeeded, False otherwise."
    }, 
    {
        "fromFloat() (Lut)": "fromFloat(src,\n        alpha)\n\n\u00a0\n    \n\nConvert a sequence of floating-point values to from_byte(x*255). Alpha\n  is an optional argument and if present unpremultiply by alpha, convert, \n  and then multiply back.\n\nReturns: float list"
    }, 
    {
        "findItem() (Menu)": "findItem(self,\n        name)\n\n\u00a0\n    \n\nFinds a submenu or command with a particular name.\n\nParameters:\n\nname - The name to search for.\n\nReturns: Menu or None\nThe submenu or command we found, or None if we could not find \n          anything."
    }, 
    {
        "forceLoad() (nuke)": "forceLoad(n)\n\n\u00a0\n    \n\nForce the plugin to be fully instantiated.\n\nParameters:\n\nn - Optional node argument. Default is the current node.\n\nReturns: None\nNone"
    }, 
    {
        "fromNode() (nuke)": "fromNode(n)\n\n\u00a0\n    \n\nReturn the Node n as a string. This function is most useful when \n  combining Python and TCL scripts for backwards compatibility reasons.\n\nParameters:\n\nn - A Node.\n\nReturns: String\nString."
    }, 
    {
        "findItem() (MenuBar)": "findItem(self,\n        name)\n\n\u00a0\n    \n\nFinds a submenu or command with a particular name.\n\nParameters:\n\nname - The name to search for.\n\nReturns: Menu or None\nThe submenu or command we found, or None if we could not find \n          anything."
    }, 
    {
        "forceValidate() (Node)": "forceValidate(self)\n      Force the node to validate itself, updating its hash."
    }, 
    {
        "fromScript() (AnimationCurve)": "fromScript(self,\n        s)\n\n\u00a0\n    \n\n\nParameters:\n\ns - String.\n\nReturns: None\nNone."
    }, 
    {
        "findItem() (ToolBar)": "findItem(self,\n        name)\n\n\u00a0\n    \n\nFinds a submenu or command with a particular name.\n\nParameters:\n\nname - The name to search for.\n\nReturns: Menu or None\nThe submenu or command we found, or None if we could not find \n          anything."
    }, 
    {
        "Format (nuke)": null
    }, 
    {
        "fromScript() (Array_Knob)": "fromScript(self,\n        s)\n\n\u00a0\n    \n\nSet value of the knob to a user defined script (TCL syntax, as in .nk \n  file). Return True if successful.\n\nParameters:\n\ns - Nuke script to be set on knob.\n\nReturns: True if successful, False otherwise\nTrue if successful, False otherwise.\nOverrides:\n        Knob.fromScript"
    }, 
    {
        "findNextName() (nukescripts.precomp)": null
    }, 
    {
        "format() (Node)": "format(self)\n\n\u00a0\n    \n\nFormat of the node.\n\nReturns: Format\nFormat."
    }, 
    {
        "fromScript() (File_Knob)": "fromScript(self,\n        s)\n\n\u00a0\n    \n\nAssign string to knob.\n\nParameters:\n\ns - String to assign.\n\nReturns: None\nNone.\nOverrides:\n        Knob.fromScript"
    }, 
    {
        "findNextName() (nukescripts.udim)": "findNextName(name)\n\nsource\u00a0code"
    }, 
    {
        "Format_Knob (nuke)": null
    }, 
    {
        "fromScript() (Format_Knob)": "fromScript(s)\n\n\u00a0\n    \n\nInitialise from script s.\n\nReturns: True if succeeded, False otherwise\nOverrides:\n        Knob.fromScript"
    }, 
    {
        "findNextNodeName() (nukescripts.utils)": null
    }, 
    {
        "formats() (nuke)": "formats()\n\n\u00a0\n    \n\n\nReturns: list\nList of all available formats."
    }, 
    {
        "fromScript() (Knob)": "fromScript(...)\n      Initialise from script."
    }, 
    {
        "finishModalDialog() (PythonPanel)": "finishModalDialog(self,\n        result)"
    }, 
    {
        "fps() (Root)": "fps(self)\n\n\u00a0\n    \n\nReturn the FPS rounded to an int. This is deprecated. Please use \n  real_fps().\n\nReturns: integer"
    }, 
    {
        "fromScript() (MultiView_Knob)": "fromScript(s)\n\n\u00a0\n    \n\nInitialise from script s.\n\nReturns: True if succeeded, False otherwise\nOverrides:\n        Knob.fromScript"
    }, 
    {
        "first() (FrameRange)": "first(self)\n      return the first frame of the range."
    }, 
    {
        "frame (nukescripts)": null
    }, 
    {
        "fromUserText() (File_Knob)": "fromUserText(self,\n        s)\n\n\u00a0\n    \n\nAssign string to knob, parses frame range off the end and opens file \n  to get set the format.\n\nParameters:\n\ns - String to assign.\n\nReturns: None\nNone."
    }, 
    {
        "firstFrame() (Node)": "firstFrame(self)\n\n\u00a0\n    \n\nFirst frame in frame range for this node.\n\nReturns: int\nint."
    }, 
    {
        "frame() (Array_Knob)": "frame(self)\n\n\u00a0\n    \n\n\nReturns: Frame number\nFrame number."
    }, 
    {
        "fromUV() (Format)": "fromUV(self,\n        u,\n        v)\n\n\u00a0\n    \n\nTransform a UV coordinate in the range 0-1 into the format's XY range.\n  Returns a list containing the x and y coordinates.\n\nParameters:\n\nu - The U coordinate.\nv - The V coordinate.\n\nReturns: [x, y]\n[x, y]"
    }, 
    {
        "firstFrame() (Root)": "firstFrame(self)\n\n\u00a0\n    \n\nFirst frame.\n\nReturns: Integer\nInteger.\nOverrides:\n        Node.firstFrame"
    }, 
    {
        "frame() (OutputContext)": "frame()\n      Return frame value."
    }, 
    {
        "fullName() (Node)": "fullName(self)\n\n\u00a0\n    \n\nGet the name of this node and any groups enclosing it in \n  'group.group.name' form.\n\nReturns: str\nThe fully-qualified name of this node, as a string."
    }, 
    {
        "fixSlopes() (AnimationCurve)": "fixSlopes(self)\n\n\u00a0\n    \n\n\nReturns: None\nNone."
    }, 
    {
        "frame() (nuke)": "frame(f)\n\n\u00a0\n    \n\nReturn or set the current frame number. Deprecated. Use \n  Root.frame.\nReturns the current frame. Normally this is the frame number set in \n  the root node, typically by the user moving the frame slider in a viewer.\n  If a number is given, it sets the current frame number to that number. If\n  the current context is the root this changes the root frame.\n\nParameters:\n\nf - Optional frame number.\n\nReturns: Current frame\nCurrent frame."
    }, 
    {
        "fullyQualifiedName() (Knob)": "fullyQualifiedName(self,\n        channel=-1)\n\n\u00a0\n    \n\nReturns the fully-qualified name of the knob within the node. This can\n  be useful for expression linking.\n\nParameters:\n\nchannel - Optional parameter, specifies the channel number of the sub-knob \n          (for example, channels of  0 and 1 would refer to the x and y of \n          a XY_Knob respectively), leave blank or set to -1 to get the  \n          qualified name of the knob only.\n\nReturns: string\nThe string of the qualified knob or sub-knob, which can be used \n          directly in expression links."
    }, 
    {
        "Flag (_curvelib)": null
    }, 
    {
        "frameCached() (Viewer)": "frameCached(f)\n      Determine whether frame /f/ is known to be in the memory cache."
    }, 
    {
        "GEO (nuke)": "GEO = 16"
    }, 
    {
        "getKeyIndex() (Knob)": "getKeyIndex(...)\n      Return keyframe index at time 't' for channel 'c'."
    }, 
    {
        "getRotationAnimCurve() (AnimCTransform)": "getRotationAnimCurve(self,\n        index,\n        view)"
    }, 
    {
        "geo (nuke)": null
    }, 
    {
        "getKeyTime() (AnimAttributes)": "getKeyTime(self,\n        index,\n        keyIndexOrHash,\n        view)\n\n\u00a0\n    \n\nGets the time a particular key is set at. The index parameter is the \n  index of the attribute; keyIndexOrHash is either the index of the key in \n  the attributes AnimCurve, or its associated Hash; and view is the \n  optional view name.\n\nReturns: float"
    }, 
    {
        "getRotationKeyTime() (AnimCTransform)": "getRotationKeyTime(self,\n        index,\n        view)\n\n\u00a0\n    \n\nGet the time for a specific key on the rotation attribute. index is \n  the index of the key. The view parameter is optional.\n\nReturns: float"
    }, 
    {
        "getKeyTime() (Array_Knob)": "getKeyTime(...)\n\n\u00a0\n    \n\nReturn time of the keyframe at time 't' and channel 'c'.\n\nOverrides:\n        Knob.getKeyTime"
    }, 
    {
        "getRotationKeyTimes() (AnimCTransform)": "getRotationKeyTimes(self,\n        view)\n      Get the times for all keys on the rotation attribute.The view \n      parameter is optional."
    }, 
    {
        "get() (GlobalsEnvironment)": "get(...)"
    }, 
    {
        "getKeyTime() (Knob)": "getKeyTime(...)\n      Return index of the keyframe at time 't' for channel 'c'."
    }, 
    {
        "getScaleAnimCurve() (AnimCTransform)": "getScaleAnimCurve(self,\n        index,\n        view)"
    }, 
    {
        "get() (DialogState)": "get(self,\n        knob,\n        defaultValue=None)\n\nsource\u00a0code\u00a0\n    \n\nReturn the given knob's stored last state value. If none exists, \n  defaultValue is returned. Values are stored in a dict referenced by knob \n  name, so names must be unique!"
    }, 
    {
        "getLayers() (nukescripts.psd)": null
    }, 
    {
        "getScaleKeyTime() (AnimCTransform)": "getScaleKeyTime(self,\n        index,\n        view)\n\n\u00a0\n    \n\nGet the time for a specific key on the scale attribute. index is the \n  index of the key. The view parameter is optional.\n\nReturns: float"
    }, 
    {
        "get_reads() (nukescripts.reads)": "get_reads(method)\n\nsource\u00a0code\u00a0\n    \n\n\nReturns file names from all Read nodes.\n\nOptions:\n  file - outputs only file names\n  dir  - outputs only directory names\n  long - outputs the entire path"
    }, 
    {
        "getLink() (Link_Knob)": "getLink()"
    }, 
    {
        "getScaleKeyTimes() (AnimCTransform)": "getScaleKeyTimes(self,\n        view)\n\n\u00a0\n    \n\nGet the times for all keys on the scale attribute. The view parameter \n  is optional.\n\nReturns: list of floats"
    }, 
    {
        "get_script_data() (nukescripts.script)": null
    }, 
    {
        "getLinkedKnob() (Link_Knob)": "getLinkedKnob()"
    }, 
    {
        "getSelected() (CurveKnob)": "getSelected(self)\n      Returns list of all selected items in a curve knob As an example, say\n      you have a Bezier curve selected,the following will return 'Bezier1' \n      >>> curveKnob = nuke.toNode('RotoPaint1)['curves'] \n      >>> selected = curveKnob.getSelected() >>> \n      selected[0].name"
    }, 
    {
        "getAllItems() (SceneView_Knob)": "getAllItems(self)\n      Returns a list of strings containing all items that the knob can \n      import."
    }, 
    {
        "getLUTPath() (nukescripts.flipbooking)": "getLUTPath(flipbookAppliction,\n        lut)\n\nsource\u00a0code\u00a0\n    \n\nReturns a path to a LUT file for the given flipbook. The contents of \n  the file will be different for each flipbook application. Please see the \n  relevant documentation for the specific flipbook applications.\n\nParameters:\n\nflipbook - The unique name of the flipbook\nlut - The unique name for the LUT, e.g. 'sRGB' and 'rec709'"
    }, 
    {
        "getSelectedItems() (CurveWidget)": "getSelectedItems(self)"
    }, 
    {
        "getallnodeinfo() (nukescripts.info)": null
    }, 
    {
        "getLUTPathForFlipbook() (FlipbookLUTPathRegistry)": "getLUTPathForFlipbook(self,\n        flipbook,\n        lut)\n\nsource\u00a0code\u00a0\n    \n\nReturn the path for the given flipbook and lut. May return an empty \n  string if none registered.\n\nParameters:\n\nflipbook - The unique name of the flipbook\nlut - The unique name for the LUT, e.g. 'sRGB' and 'rec709'"
    }, 
    {
        "getSelectedItems() (SceneView_Knob)": "getSelectedItems(self)\n      Returns a list of strings containing all currently selected items in \n      the knob."
    }, 
    {
        "getAllUserPresets() (nuke)": "getAllUserPresets()\n\n\u00a0\n    \n\ngets a list of all current user presets\n\nReturns: None\na list of tuples containing all nodename/presetname pairs."
    }, 
    {
        "getMatrix() (CTransform)": "getMatrix(self)\n      Get the matrix which represents the combination of the translation, \n      scale, rotation, skew and pivotPoint settings for this transform."
    }, 
    {
        "getSelection() (nukescripts.snap3d)": "getSelection(selectionThreshold=0.5)\n\nsource\u00a0code"
    }, 
    {
        "getAnimCurve() (CorrespondencePoints)": "getAnimCurve(cps,\n        index,\n        which)\n\n\u00a0\n    \n\n\nParameters:\n\nindex - Index to the point to get the associated AnimCurve object for\nwhich - Whether the source (0) or destination (1) t-value is being \n          modified\n\nReturns: AnimCurve\nAn AnimCurve object for the timeline of the specified point and \n          src/dest value"
    }, 
    {
        "getName() (AnimAttributes)": "getName(self,\n        index)\n      Get the name of an attribute when you know its index."
    }, 
    {
        "getSkewXAnimCurve() (AnimCTransform)": "getSkewXAnimCurve(self,\n        index,\n        view)"
    }, 
    {
        "getApplication() (FlipbookFactory)": "getApplication(self,\n        name)\n\nsource\u00a0code\u00a0\n    \n\nReturns the flipbook app implementation with the given name, raises an\n  exception if none could be found.\n\nParameters:\n\nname - The name of a flipbook that was registered.\n\nReturns:\nFlipBookApplication"
    }, 
    {
        "getNames() (FlipbookFactory)": "getNames(self)\n\nsource\u00a0code\u00a0\n    \n\nReturns a list of the names of all available flipbook apps.\n\nReturns:\nlist"
    }, 
    {
        "getSkewXKeyTime() (AnimCTransform)": "getSkewXKeyTime(self,\n        index,\n        view)\n\n\u00a0\n    \n\nGet the time for a specific key on the skewX attribute. index is the \n  index of the key. The view parameter is optional.\n\nReturns: float"
    }, 
    {
        "getApplication() (pyQtAppHelper)": "getApplication(self,\n        argv)\n\nsource\u00a0code"
    }, 
    {
        "getNodeClassName() (nuke)": "getNodeClassName()\n\n\u00a0\n    \n\ngets the class name for the currently selected node\n\nReturns: None\na string containing the name."
    }, 
    {
        "getSkewXKeyTimes() (AnimCTransform)": "getSkewXKeyTimes(self,\n        view)\n\n\u00a0\n    \n\nGet the times for all keys on the skewX attribute. The view parameter \n  is optional.\n\nReturns: list of floats"
    }, 
    {
        "getApplication() (pyWxAppHelper)": "getApplication(self)\n\nsource\u00a0code"
    }, 
    {
        "getNodePresetExcludePaths() (nuke)": "getNodePresetExcludePaths()\n\n\u00a0\n    \n\nGets a list of all paths that are excluded from the search for node \n  presets.\n\nReturns: string list\nList of paths."
    }, 
    {
        "getText() (Password_Knob)": "getText(self)\n      Return text associated with knob."
    }, 
    {
        "getAttributes() (Layer)": "getAttributes(self)\n      Gets the collection of attributes for this stroke."
    }, 
    {
        "getNodePresetID() (nuke)": "getNodePresetID()\n\n\u00a0\n    \n\ngets the node preset identifier for the currently selected node\n\nReturns: None\na string containing the ID."
    }, 
    {
        "getText() (String_Knob)": "getText(self,\n        oc)\n\n\u00a0\n    \n\nGet the value of this knob as a string.\n\nParameters:\n\noc - Optional parameter specifying the output context.\n\nReturns: str\nString value."
    }, 
    {
        "getAttributes() (Shape)": "getAttributes(self)\n      Gets the collection of attributes for this shape."
    }, 
    {
        "getNthDerivative() (Array_Knob)": "getNthDerivative(...)\n\n\u00a0\n    \n\nReturn n'th derivative at time 't' and index 'i'.\n\nOverrides:\n        Knob.getNthDerivative"
    }, 
    {
        "getToolsetExcludePaths() (nuke)": "getToolsetExcludePaths()\n\n\u00a0\n    \n\nGets a list of all paths that are excluded from the search for node \n  presets.\n\nReturns: string list\nList of paths."
    }, 
    {
        "getAttributes() (Stroke)": "getAttributes(self)\n      Gets the collection of attributes for this stroke."
    }, 
    {
        "getNthDerivative() (Knob)": "getNthDerivative(...)\n      Return nth derivative at time 't' for channel 'c'."
    }, 
    {
        "getTransform() (Layer)": "getTransform(self)\n      Gets the transform for this shape."
    }, 
    {
        "getAutoSaveFiles() (nukescripts.rollingAutoSave)": null
    }, 
    {
        "getNukeUserFolder() (nukescripts.nodepresets)": null
    }, 
    {
        "getTransform() (Shape)": "getTransform(self)\n      Gets the transform for this shape."
    }, 
    {
        "getClipname() (nuke)": "getClipname(prompt,\n        pattern=None,\n        default=None,\n        multiple=False)\n\n\u00a0\n    \n\nPops up a file chooser dialog box. You can use the pattern to restrict\n  the displayed choices to matching filenames, normal Unix glob rules are \n  used here. getClipname compresses lists of filenames that only differ by \n  an index number into a single entry called a 'clip'.\n\nParameters:\n\nprompt - Present the user with this message.\npattern - Optional file selection pattern.\ndefault - Optional default filename and path.\nmultiple - Optional boolean convertible object to allow for multiple  \n          selection.\n\nReturns: list of strings or string\nIf multiple is True, the user input is returned as a list of  \n          strings, otherwise as a single string. If the dialog is \n          cancelled, the  return value is None."
    }, 
    {
        "getNumberOfKeys() (AnimAttributes)": "getNumberOfKeys(self,\n        attr,\n        view)\n\n\u00a0\n    \n\nReturns the number of keys in the curve for a particular attribute. \n  The attr parameter can be the index or name of the attribute. The view \n  parameter is optional.\n\nReturns: int"
    }, 
    {
        "getTransform() (Stroke)": "getTransform(self)\n      Gets the transform for this shape."
    }, 
    {
        "getColor() (nuke)": "getColor(initial)\n\n\u00a0\n    \n\nShow a color chooser dialog and return the selected color as an \n  int.\nThe format of the color values is packed 8bit rgb multiplied by 256 \n  (ie in hex: 0xRRGGBB00).\n\nParameters:\n\ninitial - Optional initial color. Integer with components packed as above.\n\nReturns: int\nThe selected color."
    }, 
    {
        "getNumberOfKeys() (AnimCurve)": "getNumberOfKeys(self)\n      Returns the number of keys along this curve."
    }, 
    {
        "getTransformKeyTime() (AnimCTransform)": "getTransformKeyTime(self,\n        index,\n        view)\n\n\u00a0\n    \n\nGet the time for a specific key. The view parameter is optional.\n\nReturns: float"
    }, 
    {
        "getControlPointKeyTimes() (AnimControlPoint)": "getControlPointKeyTimes(self,\n        view)\n\n\u00a0\n    \n\nGet the list of times at which this control point has a key. The view \n  parameter is optional.\n\nReturns: list of floats"
    }, 
    {
        "getNumberOfPivotPointKeys() (AnimCTransform)": "getNumberOfPivotPointKeys(self,\n        view)\n\n\u00a0\n    \n\nGet the number of keys for the pivotPoint attribute. The view \n  parameter is optional.\n\nReturns: int"
    }, 
    {
        "getTransformKeyTimes() (AnimCTransform)": "getTransformKeyTimes(self,\n        view)\n\n\u00a0\n    \n\nGet the times for all keys, across all attributes of this transform. \n  The view parameter is optional.\n\nReturns: list of floats"
    }, 
    {
        "getCorrespondencePoints() (SplineKnob)": "getCorrespondencePoints(...)\n      self.getCorrespondencePoints('path/to/element') -> \n      CorrespondencePoints Gets the collection of correspondence point \n      collection for the element specified by the path."
    }, 
    {
        "getNumberOfRotationKeys() (AnimCTransform)": "getNumberOfRotationKeys(self,\n        view)\n\n\u00a0\n    \n\nGet the number of keys for the rotation attribute. The view parameter \n  is optional.\n\nReturns: int"
    }, 
    {
        "getTranslationAnimCurve() (AnimCTransform)": "getTranslationAnimCurve(self,\n        index,\n        view)"
    }, 
    {
        "getCurve() (AnimAttributes)": "getCurve(self,\n        attr,\n        view)\n\n\u00a0\n    \n\nGets the AnimCurve object for a particular attribute. The attr \n  parameter can be the index or name of the attribute. The view parameter \n  is optional.\n\nReturns: AnimCurve"
    }, 
    {
        "getNumberOfScaleKeys() (AnimCTransform)": "getNumberOfScaleKeys(self,\n        view)\n\n\u00a0\n    \n\nGet the number of keys for the scale attribute. The view parameter is \n  optional.\n\nReturns: int"
    }, 
    {
        "getTranslationKeyTime() (AnimCTransform)": "getTranslationKeyTime(self,\n        index,\n        view)\n\n\u00a0\n    \n\nGet the time for a specific key on the translation attribute. index is\n  the index of the key. The view parameter is optional.\n\nReturns: float"
    }, 
    {
        "getDefaultOCIOConfig() (nukescripts.ViewerProcess)": null
    }, 
    {
        "getNumberOfSkewXKeys() (AnimCTransform)": "getNumberOfSkewXKeys(self,\n        view)\n\n\u00a0\n    \n\nGet the number of keys for the skewX attribute. The view parameter is \n  optional.\n\nReturns: int"
    }, 
    {
        "getTranslationKeyTimes() (AnimCTransform)": "getTranslationKeyTimes(self,\n        view)\n\n\u00a0\n    \n\nGet the times for all keys on the translation attribute. The view \n  parameter is optional.\n\nReturns: list of floats"
    }, 
    {
        "getDeletedPresets() (nuke)": "getDeletedPresets()\n\n\u00a0\n    \n\ngets a list of all currently deleted presets\n\nReturns: None\na pyDict containing all nodename/presetname pairs."
    }, 
    {
        "getNumberOfTransformKeys() (AnimCTransform)": "getNumberOfTransformKeys(self,\n        view)\n\n\u00a0\n    \n\nGet the number of keys for all attributes of this transform. The view \n  parameter is optional.\n\nReturns: int"
    }, 
    {
        "getTransposeMatrix() (CTransform)": "getTransposeMatrix(self)\n      Returns a transposed copy of the matrix representing this transform."
    }, 
    {
        "getDerivative() (Array_Knob)": "getDerivative(...)\n\n\u00a0\n    \n\nReturn derivative at time 't' and index 'i'.\n\nOverrides:\n        Knob.getDerivative"
    }, 
    {
        "getNumberOfTranslationKeys() (AnimCTransform)": "getNumberOfTranslationKeys(self,\n        view)\n\n\u00a0\n    \n\nGet the number of keys for the translation attribute. The view \n  parameter is optional.\n\nReturns: int"
    }, 
    {
        "getUserPresetKnobValues() (nuke)": "getUserPresetKnobValues()\n\n\u00a0\n    \n\ngets a list of knob values for a given preset\n\nParameters:\n\nnodeClassName - Name of the node class to get values for.\npresetName - Name of the preset to get values for.\n\nReturns: None\na pyDict containing all knob name/value pairs."
    }, 
    {
        "getDerivative() (Knob)": "getDerivative(...)\n      Return derivative at time 't' for channel 'c'."
    }, 
    {
        "getNumberOfViews() (AnimCurveViews)": "getNumberOfViews(self)\n      Get the number of views."
    }, 
    {
        "getUserPresets() (nuke)": "getUserPresets(Node)\n\n\u00a0\n    \n\ngets a list of all user presets for the currently selected node's \n  class\n\nReturns: None\na pyList containing all nodename/presetname pairs."
    }, 
    {
        "getEvaluatedValue() (File_Knob)": "getEvaluatedValue(self,\n        oc)\n\n\u00a0\n    \n\nReturns the string on this knob, will be normalized to technical \n  notation if sequence (%4d). Will also evaluate the string for any tcl \n  expressions\n\nReturns: String\nString."
    }, 
    {
        "getNumKeys() (Array_Knob)": "getNumKeys(...)\n\n\u00a0\n    \n\nReturn number of keys at channel 'c'.\n\nOverrides:\n        Knob.getNumKeys"
    }, 
    {
        "getValue() (AnimAttributes)": "getValue(self,\n        time,\n        indexOrName,\n        view)\n\n\u00a0\n    \n\nEvaluates the anim curve of an attribute at a particular time and \n  returns the value. time is the time for which to evaluate the attribute; \n  indexOrName is either the index of the attribute to evaluate, or its \n  name; and view is the optional view name.\n\nReturns: float"
    }, 
    {
        "getExtraMatrixAnimCurve() (AnimCTransform)": "getExtraMatrixAnimCurve(self,\n        i,\n        j,\n        view)\n      Returns the AnimCurve object for the 4i+j element in the transform's \n      extra matrix.The view parameter is optional."
    }, 
    {
        "getNumKeys() (Knob)": "getNumKeys(...)\n      Return number of keyframes for channel 'c'."
    }, 
    {
        "getValue() (Array_Knob)": "getValue(self,\n        index,\n        view,\n        time)\n\n\u00a0\n    \n\nReturn value at the current frame for channel 'c'.\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: Floating point or List of floating point values (in case some are \n      different)\nFloating point or List of floating point values (in case some are\n          different).\nOverrides:\n        Knob.getValue"
    }, 
    {
        "getFilename() (nuke)": "getFilename(message,\n        pattern=None,\n        default=None,\n        favorites=None,\n        type=None,\n        multiple=False)\n\n\u00a0\n    \n\nPops up a file chooser dialog box. You can use the pattern to restrict\n  the displayed choices to matching filenames, normal Unix glob rules are \n  used here.\n\nParameters:\n\nmessage - Present the user with this message.\npattern - Optional file selection pattern.\ndefault - Optional default filename and path.\nfavorites - Optional. Restrict favorites to this set. Must be one of  \n          'image', 'script', or 'font'.\ntype - Optional the type of browser, to define task-specific behaviors;\n          currently only 'save' is recognised.\nmultiple - Optional boolean convertible object to allow for multiple  \n          selection. If this is True, the return value will be a list of \n          strings; if  not, it will be a single string. The default is\n\nReturns: list of strings or single string\nIf multiple is True, the user input is returned as a list of  \n          strings, otherwise as a single string. If the dialog was \n          cancelled, the  return value will be None."
    }, 
    {
        "getNumKnobs() (Node)": "getNumKnobs(self)\n\n\u00a0\n    \n\n\nReturns: The number of knobs\nThe number of knobs."
    }, 
    {
        "getValue() (File_Knob)": "getValue(self)\n\n\u00a0\n    \n\nReturns the string on this knob, will be normalized to technical \n  notation if sequence (%4d).\n\nParameters:\n\noc - Optional parameter specifying the output context.\n\nReturns: String\nString.\nOverrides:\n        Knob.getValue"
    }, 
    {
        "getFileNameList() (nuke)": "getFileNameList(dir,\n        splitSequences= False,\n        extraInformation= False,\n        returnDirs=True,\n        returnHidden=False)\n\n\u00a0\n    \n\n@param dir the directory to get sequences from @param splitSequences \n  whether to split sequences or not @param extraInformation whether or not \n  there should be extra sequence information on the sequence name @param \n  returnDirs whether to return a list of directories as well as sequences \n  @param returnHidden whether to return hidden files and directories. \n  Retrieves the filename list .\n\nReturns: str\nArray of files."
    }, 
    {
        "getNumPoints() (CorrespondencePoints)": "getNumPoints(cps)\n\n\u00a0\n    \n\n\nReturns:\nReturns the number of correspondence points in the object"
    }, 
    {
        "getValue() (Knob)": "getValue(...)\n      Return value at the current frame for channel 'c'."
    }, 
    {
        "getFlag() (Layer)": "getFlag(self,\n        flag)\n\n\u00a0\n    \n\nCheck whether a particular flag is set or not. The flag parameter \n  should be one of the constants from the FlagType class. The return value \n  will be True if the flag is set, False if it isn't.\n\nReturns: bool"
    }, 
    {
        "getObject() (PyCustom_Knob)": "getObject(...)\n      Returns the custom knob object as created in the by the 'command' \n      argument to the PyCuston_Knob constructor."
    }, 
    {
        "getValue() (String_Knob)": "getValue(self,\n        oc)\n\n\u00a0\n    \n\nGet the value of this knob as a string.\n\nParameters:\n\noc - Optional parameter specifying the output context.\n\nReturns: str\nString value.\nOverrides:\n        Knob.getValue"
    }, 
    {
        "getFlag() (Shape)": "getFlag(self,\n        flag)\n\n\u00a0\n    \n\nCheck whether a particular flag is set or not. The flag parameter \n  should be one of the constants from the FlagType class. The return value \n  will be True if the flag is set, False if it isn't.\n\nReturns: bool"
    }, 
    {
        "getObject() (PythonCustomKnob)": "getObject(...)\n      Returns the custom knob object as created in the by the 'command' \n      argument to the PyCuston_Knob constructor."
    }, 
    {
        "getValue() (DialogState)": "getValue(self,\n        id,\n        defaultValue=None)\n\nsource\u00a0code\u00a0\n    \n\nRecalls the value. If it was not set before, it will return the \n  defaultValue."
    }, 
    {
        "getFlag() (Stroke)": "getFlag(self,\n        flag)\n\n\u00a0\n    \n\nCheck whether a particular flag is set or not. The flag parameter \n  should be one of the constants from the FlagType class. The return value \n  will be True if the flag is set, False if it isn't.\n\nReturns: bool"
    }, 
    {
        "getPaneFor() (nuke)": "getPaneFor(panelName)\n\n\u00a0\n    \n\nReturns the first pane that contains the named panel or None if it \n  can't be found. Note that the panelName must be exact as described in the\n  layout.xml file or the panel ID. For example, 'Properties.1' or 'Viewer.1\n  or 'co.uk.thefoundry.WebBrowser'\n\nReturns: Dock\nThe pane or None."
    }, 
    {
        "getValueAt() (Array_Knob)": "getValueAt(self,\n        time,\n        index,\n        view)\n\n\u00a0\n    \n\nReturn value for this knob at specified time, optional index and \n  view.\n\nParameters:\n\ntime - Time.\nindex - Optional index. Default is 0.\nview - Optional view.\n\nReturns: Floating point or List of floating point values (in case some are \n      different)\nFloating point or List of floating point values (in case some are\n          different).\nOverrides:\n        Knob.getValueAt"
    }, 
    {
        "getFlag() (Flag)": "getFlag(flag)\n\n\u00a0\n    \n\nGets the specified flag. The parameter should be one of the FlagType \n  constants.\n\nReturns: bool"
    }, 
    {
        "getPivotPointAnimCurve() (AnimCTransform)": "getPivotPointAnimCurve(self,\n        index,\n        view)"
    }, 
    {
        "getValueAt() (Knob)": "getValueAt(...)\n      Return value at time 't' for channel 'c'."
    }, 
    {
        "getFlag() (Knob)": "getFlag(self,\n        f)\n\n\u00a0\n    \n\nReturns whether the input flag is set.\n\nParameters:\n\nf - Flag.\n\nReturns: Bool\nTrue if set, False otherwise."
    }, 
    {
        "getPivotPointKeyTime() (AnimCTransform)": "getPivotPointKeyTime(self,\n        index,\n        view)\n\n\u00a0\n    \n\nGet the time for a specific key on the pivotPoint attribute. index is \n  the index of the key. The view parameter is optional.\n\nReturns: float"
    }, 
    {
        "getViewIndex() (AnimCurveViews)": "getViewIndex(self,\n        name)\n      Get the index of a view when you know its name."
    }, 
    {
        "getFrame() (FrameRange)": "getFrame(self,\n        n)\n      return the frame according to the index, parameter n must be between \n      0 and frames()."
    }, 
    {
        "getPivotPointKeyTimes() (AnimCTransform)": "getPivotPointKeyTimes(self,\n        view)\n\n\u00a0\n    \n\nGet the times for all keys on the pivotPoint attribute. The view \n  parameter is optional.\n\nReturns: list of floats"
    }, 
    {
        "getViewName() (AnimCurveViews)": "getViewName(self,\n        index)\n      Get the name of a particular view when you know its index."
    }, 
    {
        "getFramesAndViews() (nuke)": "getFramesAndViews(label,\n        default=None,\n        maxviews=0)\n\n\u00a0\n    \n\nPops up a dialog with fields for a frame range and view selection.\n\nParameters:\n\nlabel - User message.\ndefault - Optional value for the input field.\nmaxviews - Optional max number of views.\n\nReturns: (ranges, views)\nList of ranges and views."
    }, 
    {
        "getPoint() (CubicCurve)": "getPoint(self,\n        t)\n\n\u00a0\n    \n\n\nParameters:\n\nt - The parameter value to evaluate the curve with. 0.0 is the start \n          of the curve and 1.0 is the end. A value outside this range will \n          throw a ValueError.\n\nReturns: CVec4\nA CVec4 containing the evalution result. If the curve has less \n          than 4 dimension, the extra dimensions will be filled with \n          default values."
    }, 
    {
        "getViewNames() (AnimCurveViews)": "getViewNames(self)\n      Get the list of all view names."
    }, 
    {
        "getGeometryNodes() (ViewerWindow)": "getGeometryNodes(self)\n\n\u00a0\n    \n\nReturns the a list of geometry nodes attached with this viewer\n\nReturns: None\nNodes: a list of the geometry nodes."
    }, 
    {
        "getPointValues() (CorrespondencePoints)": "getPointValues(cps,\n        time,\n        index)\n\n\u00a0\n    \n\n\nParameters:\n\ntime - Time at which to evaluate point's values\nindex - Index to the point to evaluate\n\nReturns: (t_stc, t_dest)\nA tuple containing source and destionation t-values"
    }, 
    {
        "getVisible() (Element)": "getVisible(self,\n        time)\n      Get the value of the visible attribute at a particular time."
    }, 
    {
        "getGLCameraMatrix() (ViewerWindow)": "getGLCameraMatrix(self)\n\n\u00a0\n    \n\nReturn the world transformations of the current GL viewer camera.\n\nReturns: Matrix4\nMatrix4: GL camera world transformation."
    }, 
    {
        "getPosition() (AnimControlPoint)": "getPosition(self,\n        time,\n        view)\n\n\u00a0\n    \n\nGet the position of this control point at a particular time. The time \n  parameter is a float specifying which time to calculate the position for;\n  the view parameter is the optional view name.\n\nReturns: CVec3"
    }, 
    {
        "gFlipbookFactory (nukescripts.flipbooking)": "gFlipbookFactory = FlipbookFactory()"
    }, 
    {
        "getHighlightedItem() (SceneView_Knob)": "getHighlightedItem(self)\n      Returns a string containing the item which is currently highlighted."
    }, 
    {
        "getPositionAnimCurve() (AnimControlPoint)": "getPositionAnimCurve(self,\n        index,\n        view)\n      Returns the AnimCurve object containing the time line for the control\n      point."
    }, 
    {
        "gFlipbookLUTPathRegistry (nukescripts.flipbooking)": "gFlipbookLUTPathRegistry = FlipbookLUTPathRegistry()"
    }, 
    {
        "getImportedItems() (SceneView_Knob)": "getImportedItems(self)\n      Returns a list of strings containing all items imported into the \n      knob."
    }, 
    {
        "getPositionKeyTime() (AnimControlPoint)": "getPositionKeyTime(self,\n        index,\n        keyIndex,\n        view)\n\n\u00a0\n    \n\nGet the time of a particular key for this control point. index is 0 \n  for the X coordinate, 1 for Y or 2 for Z. keyIndex is the index of the \n  relevant key. The view parameter is optional.\n\nReturns: float"
    }, 
    {
        "Gizmo (nuke)": null
    }, 
    {
        "getInput() (nuke)": "getInput(prompt,\n        default)\n\n\u00a0\n    \n\nPops up a dialog box with a text field for an arbitrary string.\n\nParameters:\n\nprompt - Present the user with this message.\ndefault - Default value for the input text field.\n\nReturns: str\nString from text field or None if dialog is cancelled."
    }, 
    {
        "getPresetKnobValues() (nuke)": "getPresetKnobValues()\n\n\u00a0\n    \n\ngets a list of knob values for a given preset\n\nParameters:\n\nnodeClassName - Name of the node class to get values for.\npresetName - Name of the preset to get values for.\n\nReturns: None\na pyDict containing all knob name/value pairs."
    }, 
    {
        "GlobalsEnvironment (nuke)": null
    }, 
    {
        "getIntegral() (Array_Knob)": "getIntegral(...)\n\n\u00a0\n    \n\nReturn integral at time interval [t1, t2] and index 'i'.\n\nOverrides:\n        Knob.getIntegral"
    }, 
    {
        "getPresetPath() (CreateNodePresetsPanel)": null
    }, 
    {
        "goofy_title() (nukescripts.misc)": "goofy_title()\n\nsource\u00a0code\u00a0\n    \n\nReturns a random message for use as an untitled script name. Can be \n  assigned to nuke.untitled as a callable. Put a goofy_title.txt somewhere \n  in your NUKE_PATH to customise."
    }, 
    {
        "getIntegral() (Knob)": "getIntegral(...)\n      Return integral at the interval [t1, t2] for channel 'c'."
    }, 
    {
        "getPresetPath() (CreateToolsetsPanel)": null
    }, 
    {
        "goto_frame() (nukescripts.frame)": null
    }, 
    {
        "getInverseMatrix() (CTransform)": "getInverseMatrix(self)\n      Gets the inverse transform matrix, which can be used for undoing the \n      effects of this transform."
    }, 
    {
        "getPresets() (nuke)": "getPresets()\n\n\u00a0\n    \n\ngets a list of all presets for the currently selected node's class\n\nReturns: None\na pyList containing all nodename/presetname pairs."
    }, 
    {
        "Group (nuke)": null
    }, 
    {
        "getItemDirName() (nukescripts.nodepresets)": null
    }, 
    {
        "getPresetsMenu() (nuke)": "getPresetsMenu(Node)\n\n\u00a0\n    \n\nGets the presets menu for the currently selected node.\n\nReturns: Menu or None\nThe menu, or None if it doesn't exist."
    }, 
    {
        "group (nukescripts)": null
    }, 
    {
        "getKey() (AnimCurve)": "getKey(self,\n        index)\n      Returns one of the keys on this curve."
    }, 
    {
        "getRange() (FrameRanges)": "getRange()\n      return a range from the list"
    }, 
    {
        "groupmake() (nukescripts.group)": "groupmake()\n\nsource\u00a0code\u00a0\n    \n\nBuilds a group from the current node selection. This function is only \n  maintained for backwards compatibility. Please use nuke.makeGroup() \n  instead."
    }, 
    {
        "getKeyIndex() (Array_Knob)": "getKeyIndex(...)\n\n\u00a0\n    \n\nReturn index of the keyframe at time 't' and channel 'c'.\n\nOverrides:\n        Knob.getKeyIndex"
    }, 
    {
        "getReadFileKnob() (nuke)": "getReadFileKnob(node)\n\n\u00a0\n    \n\n\brief Gets the read knob for a node (if it exists).\n\nParameters:\n\nnode - The node to get the knob for.\n\nReturns: knob\nA PyObject containing the read knob if it exists, NULL otherwise"
    }, 
    {
        "GUI (nuke)": "GUI = False"
    }, 
    {
        "h() (Box)": "h(self)\n      Return height."
    }, 
    {
        "height() (Array_Knob)": "height(self)\n\n\u00a0\n    \n\n\nReturns: Height of array of values\nHeight of array of values."
    }, 
    {
        "hideControlPanel() (Node)": "hideControlPanel(self)\n\n\u00a0\n    \n\n\nReturns: None\nNone"
    }, 
    {
        "h() (Info)": "h(self)\n      Return height."
    }, 
    {
        "height() (Format)": "height(self)\n      Return the height of image file in pixels."
    }, 
    {
        "highSoft() (Keyer_Knob)": "highSoft(...)"
    }, 
    {
        "has_key() (GlobalsEnvironment)": "has_key(...)"
    }, 
    {
        "height() (IArray_Knob)": "height(self)\n\n\u00a0\n    \n\nReturn height of the array.\n\nReturns: Height of array of values\nHeight of array of values.\nOverrides:\n        Array_Knob.height"
    }, 
    {
        "highTol() (Keyer_Knob)": "highTol(...)"
    }, 
    {
        "hasError() (Node)": "hasError()\n\n\u00a0\n    \n\nTrue if the node itself has an error, regardless of the state of the \n  ops in its input tree, or False otherwise.\nError state of the node itself, regardless of the state of the ops in \n  its input tree. Note that an error on a node may not appear if there is \n  an error somewhere in its input tree, because it may not be possible to \n  validate the node itself correctly in that case.\n\nReturns: bool"
    }, 
    {
        "height() (Node)": "height(self)\n\n\u00a0\n    \n\nHeight of the node.\n\nReturns: int\nint."
    }, 
    {
        "Histogram_Knob (nuke)": null
    }, 
    {
        "hasExpression() (Array_Knob)": "hasExpression(self,\n        index)\n\n\u00a0\n    \n\nReturn True if animation at index 'index' has an expression.\n\nParameters:\n\nindex - Optional index.\n\nReturns: True if has expression, False otherwise\nTrue if has expression, False otherwise.\nOverrides:\n        Knob.hasExpression"
    }, 
    {
        "help() (Node)": "help(self)\n\n\u00a0\n    \n\n\nReturns: str\nHelp for the node."
    }, 
    {
        "HORIZONTAL (nuke)": "HORIZONTAL = 17"
    }, 
    {
        "hasExpression() (Knob)": "hasExpression(self,\n        index=-1)\n\n\u00a0\n    \n\nReturn True if animation at index 'index' has an expression.\n\nParameters:\n\nindex - Optional index parameter. Defaults to -1 if not specified. This \n          can be specified as a keyword parameter if desired.\n\nReturns: bool\nTrue if has expression, False otherwise."
    }, 
    {
        "Help_Knob (nuke)": null
    }, 
    {
        "HOST (nukescripts.clientserver)": null
    }, 
    {
        "hash (AnimControlPoint)": "hash\n      The hash value for this control point."
    }, 
    {
        "hexversion (sys)": "hexversion = 33949168"
    }, 
    {
        "hotkeys() (nuke)": "hotkeys()\n\n\u00a0\n    \n\nReturns the Nuke key assignments as a string formatted for use in \n  nuke.display().\n\nReturns: str\nA formatted string."
    }, 
    {
        "hash (ControlPoint)": "hash\n      The hash value."
    }, 
    {
        "HIDDEN_INPUTS (nuke)": "HIDDEN_INPUTS = 4"
    }, 
    {
        "hide() (PythonPanel)": "hide(self)\n\n\u00a0\n    \n\nHide the widget.\n\nOverrides:\n        unreachable.Widget.hide\n        (inherited documentation)"
    }, 
    {
        "I (re)": "I = 2"
    }, 
    {
        "inputNumber() (Color_Knob)": "inputNumber()\n      Return input number."
    }, 
    {
        "isAudioFilename() (nukescripts.create)": "isAudioFilename(filename)\n\nsource\u00a0code"
    }, 
    {
        "IArray_Knob (nuke)": null
    }, 
    {
        "INPUTS (nuke)": "INPUTS = 2"
    }, 
    {
        "isBackgrounded() (RenderDialog)": "isBackgrounded(self)\n      Return whether the backgroun rendering option is enabled.\n\nsource\u00a0code"
    }, 
    {
        "icon() (MenuItem)": "setIcon(self,\n        icon)\n\n\u00a0\n    \n\nSet the icon on this menu item.\n\nParameters:\n\nicon - the new icon as a path\n\nReturns: None"
    }, 
    {
        "inputs() (Node)": "inputs(self)\n\n\u00a0\n    \n\n\nReturns: Gets the maximum number of connected inputs\nNumber of the highest connected input + 1. If inputs 0, 1, and 3 \n          are connected, this will return 4."
    }, 
    {
        "isCancelled() (ProgressTask)": "isCancelled(self)"
    }, 
    {
        "identity() (AnimationCurve)": "identity(self)\n\n\u00a0\n    \n\n\nReturns: bool\nTrue if the animation appears to be such that y == x everywhere. \n          This is True only for an expression of 'x' or the default \n          expression and all points having y == x and slope == 1. \n          Extrapolation is ignored."
    }, 
    {
        "inputs() (Root)": "inputs(self)\n\n\u00a0\n    \n\n\nReturns: Gets the maximum number of connected inputs\nNumber of the highest connected input + 1. If inputs 0, 1, and 3 \n          are connected, this will return 4.\nOverrides:\n        Node.inputs\n(inherited documentation)"
    }, 
    {
        "isChannelEnabled() (Channel_Knob)": "isChannelEnabled(self,\n        name)\n\n\u00a0\n    \n\nTest if a channel is enabled.\n\nParameters:\n\nname - The name of the channel.@return: True if the channel is enabled, \n          False otherwise.\n\nReturns: bool"
    }, 
    {
        "IGNORECASE (re)": "IGNORECASE = 2"
    }, 
    {
        "inputs() (nuke)": "inputs(n,\n        i)\n\n\u00a0\n    \n\nDeprecated. Use Node.inputs.\nGet how many inputs the node has. Normally this is a constant but some\n  nodes have a variable number, the user can keep connecting them and the \n  count will increase. Attempting to set the number will just disconnect \n  all inputs greater or equal to number. For a variable input node this may\n  decrease inputs to the new value. For most nodes this will have no effect\n  on the value of inputs.\n\nParameters:\n\nn - Node.\ni - Optional number of inputs requested.\n\nReturns: int\nNumber of inputs."
    }, 
    {
        "isConstant() (Box)": "isConstant(self)"
    }, 
    {
        "IgnoreMask (RenderFlag)": "values\n\n\n\nValue:\n\n{'DrawChildren': PySide.QtGui.QWidget.RenderFlag.DrawChildren,\n 'DrawWindowBackground': PySide.QtGui.QWidget.RenderFlag.DrawWindowBac\nkground,\n 'IgnoreMask': PySide.QtGui.QWidget.RenderFlag.IgnoreMask}"
    }, 
    {
        "insert() (Layer)": "insert(self,\n        index,\n        element)\n\n\u00a0\n    \n\nInsert a new element inside this layer at the given index. The element\n  must be an instance of either the Shape, Stroke or Layer classes. Note \n  that an element cannot be in more than one place in the tree, so if you \n  try to add an element that is already in the tree somewhere else, it'll \n  be removed from its old location first.\n\nReturns: None"
    }, 
    {
        "isDeepFilename() (nukescripts.create)": "isDeepFilename(filename)\n\nsource\u00a0code"
    }, 
    {
        "IMAGE (nuke)": "IMAGE = 1"
    }, 
    {
        "insert() (Shape)": "insert(self,\n        index,\n        shapeControlPoint)\n\n\u00a0\n    \n\nInsert a new control point in the shape before the given index. The \n  shapeControlPoint parameter must be either an instance of the \n  ShapeControlPoint class, or something we can convert to a \n  ShapeControlPoint. This includes a sequence of 2, 3 or 4 floats; a CVec2,\n  CVec3 or CVec4 object; or an AnimControlPoint object.\n\nReturns: None"
    }, 
    {
        "isDefault() (AnimCTransform)": "isDefault(self)\n      Check whether this transform has been modified away from the default \n      values."
    }, 
    {
        "import_boujou() (nukescripts.importexport)": "import_boujou()\n\nsource\u00a0code\u00a0\n    \n\nNuke 5.0 Py import_boujou. Demonstrates the use of addKnob.\nFunction called from the \"import Boujou camera track\" user \n  knob of a Boujou Camera gizmo.\nread data from a Boujou text file: format is: FRAME TX TY TZ RX RY RZ \n  VFOV this version will read fewer columns\nmodified by Frank R\u00fcter June 30th 2006 to work with Nuke 4.5\nInstead of writing out an obj like the old version this one creates \n  lowres cylinders for each point found in your boujou export. Those are \n  stuffed into a group which is hooked up to a render node along with the \n  resulting camera.  It has size, colour and render parameters to control \n  those proxies.  Keep in mind that there is a limit for scene nodes of \n  1000 inputs so try to keep your point export from Boujou below that \n  ;)."
    }, 
    {
        "insert() (Stroke)": "insert(self,\n        index,\n        controlPoint)\n\n\u00a0\n    \n\nInsert a new control point in the stroke before the given index. The \n  controlPoint parameter must be either an instance of the AnimControlPoint\n  class, or something we can convert to an AnimControlPoint. This includes \n  a sequence of 2, 3 or 4 floats; or a CVec2, CVec3 or CVec4 object.\n\nReturns: None"
    }, 
    {
        "isDefault() (AnimCurve)": "isDefault(self)\n      Check whether this curve has been modified away from its default \n      values."
    }, 
    {
        "import_module() (nuke)": "import_module(name,\n        filterRule)\n\nsource\u00a0code"
    }, 
    {
        "INT16 (nuke)": "INT16 = 3"
    }, 
    {
        "isDefault() (CTransform)": "isDefault(self)\n      Returns True if this transform matches the default settings, False if\n      not."
    }, 
    {
        "import_script() (nukescripts.importexport)": "import_script()\n\nsource\u00a0code"
    }, 
    {
        "INT8 (nuke)": "INT8 = 2"
    }, 
    {
        "isGeoFilename() (nukescripts.create)": "isGeoFilename(filename)\n\nsource\u00a0code"
    }, 
    {
        "importexport (nukescripts)": null
    }, 
    {
        "Int_Knob (nuke)": null
    }, 
    {
        "isInRange() (FrameRange)": "isInRange(self,\n        n)\n      return if the frame is inside the range."
    }, 
    {
        "importUdimFiles() (UDIMOptionsDialog)": "importUdimFiles(self)\n\nsource\u00a0code"
    }, 
    {
        "integrate() (AnimationCurve)": "integrate(self,\n        t1,\n        t2)\n\n\u00a0\n    \n\nCalculate the area underneath the curve from t1 to t2. @param t1 The \n  start of the integration range. @param t2 The end of the integration \n  range.\n\nReturns: Float\nThe result of the integration."
    }, 
    {
        "isKey() (Array_Knob)": "isKey(self,\n        index,\n        view)\n\n\u00a0\n    \n\nReturn True if there is a keyframe at the current frame for channel \n  'c'.\n\nParameters:\n\nindex - Optional index.\nview - Optional view.\n\nReturns: True if succeeded, False otherwise\nTrue if succeeded, False otherwise.\nOverrides:\n        Knob.isKey"
    }, 
    {
        "increment() (FrameRange)": "increment(self)\n      return the increment between two frames."
    }, 
    {
        "INTERACTIVE (nuke)": "INTERACTIVE = True"
    }, 
    {
        "isKey() (Knob)": "isKey(...)\n      Return True if there is a keyframe at the current frame for channel \n      'c'."
    }, 
    {
        "indices() (LinkableKnobInfo)": "indices(self)\n      Returns a list of the knob channels that should be used with this \n      linkable knob.\n\nsource\u00a0code"
    }, 
    {
        "interpolation (AnimationKey)": "interpolation\n      Used to calculate all the slopes except for the left slope of the \n      first key and the right slope of the last key"
    }, 
    {
        "isKeyAt() (Array_Knob)": "isKeyAt(self,\n        time,\n        index,\n        view)\n\n\u00a0\n    \n\nReturns True if there is a keyframe at specified time, optional index \n  and view, otherwise returns False.\n\nParameters:\n\ntime - Time.\nindex - Optional index.\nview - Optional view.\n\nReturns: True if succeeded, False otherwise\nTrue if succeeded, False otherwise.\nOverrides:\n        Knob.isKeyAt"
    }, 
    {
        "indices() (VertexSelection)": null
    }, 
    {
        "interpolationType (AnimCurveKey)": "interpolationType\n      The interpolation type to use for this key."
    }, 
    {
        "isKeyAt() (Knob)": "isKeyAt(...)\n      Return True if there is a keyframe at time 't' for channel 'c'."
    }, 
    {
        "Info (nuke)": null
    }, 
    {
        "InterpolationType (_curvelib)": null
    }, 
    {
        "isLinear() (Lut)": "isLinear(self)"
    }, 
    {
        "info (nukescripts)": null
    }, 
    {
        "intersect() (Box)": "intersect(self,\n        x,\n        y,\n        r,\n        t)\n      Intersect with the given edges."
    }, 
    {
        "isRegistered() (FlipbookFactory)": "isRegistered(self,\n        flipbook)\n\nsource\u00a0code\u00a0\n    \n\nReturn whether a flipbook app with that name has already been \n  registered.\n\nParameters:\n\nflipbook - FlipBookApplication object that's tested for.\n\nReturns:\nbool"
    }, 
    {
        "infoviewer() (nukescripts.info)": null
    }, 
    {
        "inverse() (AnimationCurve)": "inverse(self,\n        y)\n\n\u00a0\n    \n\nThe inverse function at value y. This is the value of x such that \n  evaluate(x) returns y. This is designed to invert color lookup tables. It\n  only works if the derivative is zero or positive everywhere.\n\nParameters:\n\ny - The value of the function to get the inverse for.\n\nReturns: Float\nFloat."
    }, 
    {
        "isSelected() (Node)": "isSelected(self)\n\n\u00a0\n    \n\nReturns the current selection state of the node.  This is the same as \n  checking the 'selected' knob.\n\nReturns: bool\nTrue if selected, or False if not."
    }, 
    {
        "initiate() (pyAppHelper)": "initiate(self)\n      Start the thread associated with this object\n\nsource\u00a0code"
    }, 
    {
        "inverseRotate() (VertexSelection)": null
    }, 
    {
        "isZero() (Lut)": "isZero(self)"
    }, 
    {
        "initPyQtRenderDialog() (nukescripts.pyQtExamples.pyQtRender)": null
    }, 
    {
        "invertSelection() (nuke)": "invertSelection()\n\n\u00a0\n    \n\nSelects all unselected nodes, and deselects all selected ones.\n\nReturns: None\nNone."
    }, 
    {
        "itemName() (Pulldown_Knob)": "itemName(n)\n\n\u00a0\n    \n\nReturn name of item n. The argument n is an integer and in the range \n  of 0 and numValues.\n\nReturns: string"
    }, 
    {
        "initRenderDialog() (nukescripts.pyQtExamples.pyQtRender2)": null
    }, 
    {
        "INVISIBLE (nuke)": "INVISIBLE = 1024"
    }, 
    {
        "items() (GlobalsEnvironment)": "items(...)"
    }, 
    {
        "initStyleOption() (TableDelegate)": "initStyleOption(self,\n        option,\n        index)\n\nsource\u00a0code\u00a0\n    \n\n\nOverrides:\n        PySide.QtGui.QStyledItemDelegate.initStyleOption"
    }, 
    {
        "invoke() (MenuItem)": "invoke(self)\n      Perform the action associated with this menu item."
    }, 
    {
        "items() (Menu)": "items(self)\n      Returns a list of sub menu items."
    }, 
    {
        "input() (Node)": "input(self,\n        i)\n\n\u00a0\n    \n\n\nParameters:\n\ni - Input number.\n\nReturns: The i'th input\nThe i'th input."
    }, 
    {
        "IrToken() (nuke)": "IrToken(...)\n\n\u00a0\n    \n\nNuke internal. Not for public use."
    }, 
    {
        "items() (MenuBar)": "items(self)\n      Returns a list of sub menu items."
    }, 
    {
        "input() (Root)": "input(self,\n        i)\n\n\u00a0\n    \n\n\nParameters:\n\ni - Input number.\n\nReturns: The i'th input\nThe i'th input.\nOverrides:\n        Node.input\n(inherited documentation)"
    }, 
    {
        "isAbcFilename() (nukescripts.create)": "isAbcFilename(filename)\n\nsource\u00a0code"
    }, 
    {
        "items() (ToolBar)": "items(self)\n      Returns a list of sub menu items."
    }, 
    {
        "inputKnob() (Channel_Knob)": "inputKnob(self)"
    }, 
    {
        "isAnimated() (Array_Knob)": "isAnimated(self,\n        index,\n        view)\n\n\u00a0\n    \n\nReturn True if channel 'c' is animated.\n\nParameters:\n\nindex - Optional index.\nview - Optional view.\n\nReturns: True if animated, False otherwise\nTrue if animated, False otherwise.\nOverrides:\n        Knob.isAnimated"
    }, 
    {
        "inputNumber() (Channel_Knob)": "inputNumber(self)"
    }, 
    {
        "isAnimated() (Knob)": "isAnimated(...)\n      Return True if channel 'c' is animated."
    }, 
    {
        "jumpTo() (nukescripts.bookmarks)": null
    }, 
    {
        "kAlphaAttribute (AnimAttributes)": "kAlphaAttribute = 'a'"
    }, 
    {
        "kGreenOverlayAttribute (AnimAttributes)": "kGreenOverlayAttribute = 'go'"
    }, 
    {
        "knobDefault() (nuke)": "knobDefault(classknob,\n        value)\n\n\u00a0\n    \n\nSet a default value for knobs in nodes that belong to the same class. \n  All knobs with matching names, that are created after this command was \n  issued, will default to the new value. If class. is missing or is \n  \"*.\" then this default applies to all nodes with such a knob. \n  If several values are supplied, the first value which is valid will be \n  used as the default. knobDefault can be used to specify file format \n  specific knobs. These are knobs that are added to Read, Write and other \n  file format dependent nodes when the file name changes. To specify \n  defaults, use the class name, followed by the file format extension, \n  followed by the knob name, all separated by periods. An example is shown \n  below.\nExample: nuke.knobDefault(\"Blur.size\", \"20\")\nExample: nuke.knobDefault(\"Read.exr.compression\", \n  \"2\")\n\nParameters:\n\nclassknob - String in the form \"class.knob\" where \"class\"\n          is the class of Node, i.e. Blur, and \"knob\" is the name\n          of the knob. This can also include a file extension, as in \n          \"class.extension.knob\"\nvalue - Optional string to convert to the default value.\n\nReturns: str\nNone or String with the default value."
    }, 
    {
        "kAlphaOverlayAttribute (AnimAttributes)": "kAlphaOverlayAttribute = 'ao'"
    }, 
    {
        "kHardnessAttribute (AnimAttributes)": "kHardnessAttribute = 'h'"
    }, 
    {
        "knobIndex() (AnimationCurve)": "knobIndex(self)\n      Return the knob index this animation belongs to.@return: Int."
    }, 
    {
        "kBlendingModeAttribute (AnimAttributes)": "kBlendingModeAttribute = 'bm'"
    }, 
    {
        "kInvertedAttribute (AnimAttributes)": "kInvertedAttribute = 'inv'"
    }, 
    {
        "knobs() (Node)": "knobs(self)\n\n\u00a0\n    \n\nGet a dictionary of (name, knob) pairs for all knobs in this node.\nFor example:\n\n>>> b = nuke.nodes.Blur()\n>>> b.knobs()\n\nReturns: dict\nDictionary of all knobs.\n          Note that this doesn't follow the links for Link_Knobs"
    }, 
    {
        "kBlueAttribute (AnimAttributes)": "kBlueAttribute = 'b'"
    }, 
    {
        "kLifeTimeMAttribute (AnimAttributes)": "kLifeTimeMAttribute = 'ltm'"
    }, 
    {
        "knobs() (PanelNode)": "knobs(self)\n\n\u00a0\n    \n\nGet a dictionary of (name, knob) pairs for all knobs in this node.\nFor example:\n\n>>> b = nuke.nodes.Blur()\n>>> b.knobs()\n\nReturns: dict\nDictionary of all knobs.\n          Note that this doesn't follow the links for Link_Knobs"
    }, 
    {
        "kBlueOverlayAttribute (AnimAttributes)": "kBlueOverlayAttribute = 'bo'"
    }, 
    {
        "kLifeTimeNAttribute (AnimAttributes)": "kLifeTimeNAttribute = 'ltn'"
    }, 
    {
        "knobs() (PythonPanel)": "knobs(self)"
    }, 
    {
        "kBrushSizeAttribute (AnimAttributes)": "kBrushSizeAttribute = 'bs'"
    }, 
    {
        "kLifeTimeTypeAttribute (AnimAttributes)": "kLifeTimeTypeAttribute = 'ltt'"
    }, 
    {
        "knobTooltip() (nuke)": "knobTooltip(classknob,\n        value)\n\n\u00a0\n    \n\n\nSet an override for a tooltip on a knob.\n\nExample:\n\n   nuke.knobTooltip('Blur.size', '[some text]')\n\n@param classknob: String in the form \"class.knob\" where \"class\" is the class of Node, i.e. Blur, and \"knob\" is the name of the knob.\n@param value: String to use as the tooltip\n@return: None\n\n\n\nReturns: None"
    }, 
    {
        "kBrushSpacingAttribute (AnimAttributes)": "kBrushSpacingAttribute = 'bsp'"
    }, 
    {
        "kMotionBlurAttribute (AnimAttributes)": "kMotionBlurAttribute = 'mb'"
    }, 
    {
        "KnobType (nuke)": null
    }, 
    {
        "kBrushTypeAttribute (AnimAttributes)": "kBrushTypeAttribute = 'bt'"
    }, 
    {
        "kMotionBlurOnAttribute (AnimAttributes)": "kMotionBlurOnAttribute = 'mbo'"
    }, 
    {
        "kNumberOfViewsAttribute (AnimAttributes)": "kNumberOfViewsAttribute = 'nv'"
    }, 
    {
        "kBuildUpAttribute (AnimAttributes)": "kBuildUpAttribute = 'bu'"
    }, 
    {
        "kMotionBlurShutterAttribute (AnimAttributes)": "kMotionBlurShutterAttribute = 'mbs'"
    }, 
    {
        "kOpacityAttribute (AnimAttributes)": "kOpacityAttribute = 'opc'"
    }, 
    {
        "kCommandField (nukescripts.script)": null
    }, 
    {
        "kMotionBlurShutterOffsetAttribute (AnimAttributes)": "kMotionBlurShutterOffsetAttribute = 'mbso'"
    }, 
    {
        "kPlanarTrackLayerAttribute (AnimAttributes)": "kPlanarTrackLayerAttribute = 'pt'"
    }, 
    {
        "kDefaultAnimCurveKeyInterpolation (AnimCurveKey)": "kDefaultAnimCurveKeyInterpolation = 256"
    }, 
    {
        "kMotionBlurShutterOffsetTypeAttribute (AnimAttributes)": "kMotionBlurShutterOffsetTypeAttribute = 'mbsot'"
    }, 
    {
        "kRedAttribute (AnimAttributes)": "kRedAttribute = 'r'"
    }, 
    {
        "kDefaultAnimCurveKeyTime (AnimCurveKey)": "kDefaultAnimCurveKeyTime = 0.0"
    }, 
    {
        "Knob (nuke)": null
    }, 
    {
        "kRedOverlayAttribute (AnimAttributes)": "kRedOverlayAttribute = 'ro'"
    }, 
    {
        "kDefaultAnimCurveKeyValue (AnimCurveKey)": "kDefaultAnimCurveKeyValue = 0.0"
    }, 
    {
        "knob() (AnimationCurve)": "knob(self)\n      Return knob this animation belongs to.@return: Knob."
    }, 
    {
        "kSourceAttribute (AnimAttributes)": "kSourceAttribute = 'src'"
    }, 
    {
        "kDefaultConstantValue (AnimCurve)": "kDefaultConstantValue = 0.0"
    }, 
    {
        "knob() (LinkableKnobInfo)": "knob(self)\n      Returns the knob that may be linked to.\n\nsource\u00a0code"
    }, 
    {
        "kSourcePivotPointXAttribute (AnimAttributes)": "kSourcePivotPointXAttribute = 'spx'"
    }, 
    {
        "kDefaultCurveFlag (BaseCurve)": "kDefaultCurveFlag = 0"
    }, 
    {
        "knob() (Node)": "knob(self,\n        p)\n\n\u00a0\n    \n\n\nParameters:\n\np - A string or an integer.\n\nReturns: The knob named p or the pth knob\nThe knob named p or the pth knob.\n          Note that this follows the links for Link_Knobs"
    }, 
    {
        "kSourcePivotPointYAttribute (AnimAttributes)": "kSourcePivotPointYAttribute = 'spy'"
    }, 
    {
        "kDefaultCurveTension (BaseCurve)": "kDefaultCurveTension = 0.5"
    }, 
    {
        "knob() (nuke)": "knob(name,\n        value,\n        getType,\n        getClass)\n\n\u00a0\n    \n\n\brief Returns or sets the entire state of a knob.\nEach individual control on a control panel is called a 'knob'. A \n  knob's name is a dot-separated list. An example of a fully-expanded name \n  of a knob is 'root.Group1.Blur1.size.w'. 'root' is the node name of the \n  outermost group, 'Group1' is a group inside that containing the blur \n  operator, 'Blur1' is the name of a blur operator, 'size' is the name of \n  the actual knob, and 'w' is the name of the 'field' (there are two fields\n  in a blur size, 'w' and 'h').\nYou can omit a lot of this because all knob names are figured out \n  relative to a 'current knob' and 'current node'. These are set depending \n  on the context of where the scripting is invoked. For menu items the \n  current node is the group that contained the menu, and there is no \n  current knob. For expressions typed into knob fields the current knob is \n  that knob and the current node is the node the knob belongs to.\nIf a name does not start with 'root' then a search upwards is done for\n  the first word in the name, first against the fields in the current knob,\n  then against the knobs in the current node, then against the nodes in the\n  group containing the current node (or in it if it is a group), on up to \n  the root.\nThe word 'this' means the current knob or the current node.\nThe word 'input' means the first (0 or B) input of a node. Ie \n  'Blur1.input' returns the node connected to the input of Blur1, while \n  'Blur1.input.input' returns the input of that node.\nIf you are getting the value for reporting to the user, you probably \n  want to use the value or expression commands.\nIf the getType argument is specified and is True, it will print out \n  the type of the knob rather than getting or setting the value. The type \n  is an integer, using the same list as addUserKnob.\nIf the getClass argument is specified and is True, it will print out \n  the type of the knob as a string, e.g. 'Int_Knob', 'Enumeration_Knob', \n  'XY_Knob'.\nIf both the getType and getClass arguments are present and are True, \n  getType takes precedence.\n\nParameters:\n\nname - The name of the knob.\nvalue - Optional argument. If this is present, the value will be stored \n          into the knob.\ngetType - Optional boolean argument. If True, return the class ID for the \n          knob instead of the knob itself. The class ID is an int.\ngetClass - Optional boolean argument. If True, return the class name for the\n          knob instead of the knob itself. The class name is a string.\n\nReturns: None"
    }, 
    {
        "kSourceRotateAttribute (AnimAttributes)": "kSourceRotateAttribute = 'sr'"
    }, 
    {
        "kDefaultCurveType (BaseCurve)": "kDefaultCurveType = 0"
    }, 
    {
        "KNOB_CHANGED_RECURSIVE (nuke)": "KNOB_CHANGED_RECURSIVE = 134217728"
    }, 
    {
        "kSourceScaleXAttribute (AnimAttributes)": "kSourceScaleXAttribute = 'ssx'"
    }, 
    {
        "kDefaultViewName (AnimCurveViews)": "kDefaultViewName = 'default'"
    }, 
    {
        "knobAndFieldName() (AnimationCurve)": "knobAndFieldName(self)\n\n\u00a0\n    \n\nKnob and field name combined (e.g. 'translate.x').\n\nReturns: string\nstring."
    }, 
    {
        "kSourceScaleYAttribute (AnimAttributes)": "kSourceScaleYAttribute = 'ssy'"
    }, 
    {
        "kDynamicHardnessAttribute (AnimAttributes)": "kDynamicHardnessAttribute = 'dh'"
    }, 
    {
        "knobChanged() (nuke.callbacks)": "knobChanged()\n\nsource\u00a0code"
    }, 
    {
        "kSourceSkewOrderAttribute (AnimAttributes)": "kSourceSkewOrderAttribute = 'sso'"
    }, 
    {
        "kDynamicSizeAttribute (AnimAttributes)": "kDynamicSizeAttribute = 'ds'"
    }, 
    {
        "knobChanged() (CreateNodePresetsPanel)": null
    }, 
    {
        "kSourceSkewXAttribute (AnimAttributes)": "kSourceSkewXAttribute = 'sskx'"
    }, 
    {
        "kDynamicTransparencyAttribute (AnimAttributes)": "kDynamicTransparencyAttribute = 'dt'"
    }, 
    {
        "knobChanged() (PresetsDeletePanel)": null
    }, 
    {
        "kSourceSkewYAttribute (AnimAttributes)": "kSourceSkewYAttribute = 'ssky'"
    }, 
    {
        "kEffectParameter1Attribute (AnimAttributes)": "kEffectParameter1Attribute = 'ep1'"
    }, 
    {
        "knobChanged() (PresetsLoadPanel)": null
    }, 
    {
        "kSourceTimeOffsetAttribute (AnimAttributes)": "kSourceTimeOffsetAttribute = 'sto'"
    }, 
    {
        "kEffectParameter2Attribute (AnimAttributes)": "kEffectParameter2Attribute = 'ep2'"
    }, 
    {
        "knobChanged() (UserPresetsDeletePanel)": null
    }, 
    {
        "kSourceTimeOffsetTypeAttribute (AnimAttributes)": "kSourceTimeOffsetTypeAttribute = 'stot'"
    }, 
    {
        "kEffectParameter3Attribute (AnimAttributes)": "kEffectParameter3Attribute = 'ep3'"
    }, 
    {
        "knobChanged() (UserPresetsLoadPanel)": null
    }, 
    {
        "kSourceTranslateRoundAttribute (AnimAttributes)": "kSourceTranslateRoundAttribute = 'str'"
    }, 
    {
        "Keyer_Knob (nuke)": null
    }, 
    {
        "knobChanged() (PythonPanel)": "knobChanged(self,\n        knob)"
    }, 
    {
        "kSourceTranslateXAttribute (AnimAttributes)": "kSourceTranslateXAttribute = 'stx'"
    }, 
    {
        "keys() (AnimationCurve)": "addKey(self,\n        keys)\n\n\u00a0\n    \n\nInsert a sequence of keys.\n\nParameters:\n\nkeys - Sequence of AnimationKey.\n\nReturns: None\nNone."
    }, 
    {
        "knobChanged() (ExecuteDialog)": null
    }, 
    {
        "kSourceTranslateYAttribute (AnimAttributes)": "kSourceTranslateYAttribute = 'sty'"
    }, 
    {
        "keys() (GlobalsEnvironment)": "keys(...)"
    }, 
    {
        "knobChanged() (FlipbookDialog)": "knobChanged(self,\n        knob)\n\nsource\u00a0code\u00a0\n    \n\n\nOverrides:\n        ExecuteDialog.knobChanged"
    }, 
    {
        "kTensionAttribute (AnimAttributes)": "kTensionAttribute = 't'"
    }, 
    {
        "kFeatherFallOffAttribute (AnimAttributes)": "kFeatherFallOffAttribute = 'ff'"
    }, 
    {
        "knobChanged() (RenderDialog)": "knobChanged(self,\n        knob)\n\nsource\u00a0code\u00a0\n    \n\n\nOverrides:\n        ExecuteDialog.knobChanged"
    }, 
    {
        "kViewAttribute (AnimAttributes)": "kViewAttribute = 'view'"
    }, 
    {
        "kFeatherOnAttribute (AnimAttributes)": "kFeatherOnAttribute = 'fo'"
    }, 
    {
        "knobChanged() (CreateToolsetsPanel)": null
    }, 
    {
        "kVisibleAttribute (AnimAttributes)": "kVisibleAttribute = 'vis'"
    }, 
    {
        "kFeatherTypeAttribute (AnimAttributes)": "kFeatherTypeAttribute = 'ft'"
    }, 
    {
        "knobChanged() (LinkToTrackPanel)": null
    }, 
    {
        "kWriteOnEndAttribute (AnimAttributes)": "kWriteOnEndAttribute = 'we'"
    }, 
    {
        "kFeatherXAttribute (AnimAttributes)": "kFeatherXAttribute = 'fx'"
    }, 
    {
        "knobChangedCallback() (PythonPanel)": "knobChangedCallback(self,\n        knob)"
    }, 
    {
        "kWriteOnStartAttribute (AnimAttributes)": "kWriteOnStartAttribute = 'ws'"
    }, 
    {
        "kFeatherYAttribute (AnimAttributes)": "kFeatherYAttribute = 'fy'"
    }, 
    {
        "knobChangeds (nuke.callbacks)": "knobChangeds = {}"
    }, 
    {
        "kGreenAttribute (AnimAttributes)": "kGreenAttribute = 'g'"
    }, 
    {
        "knobChangeds (nuke)": "knobChangeds = {}"
    }, 
    {
        "L (re)": "L = 4"
    }, 
    {
        "LicensedDeclarative (nukescripts)": "LicensedDeclarative\n\n\n\nValue:\n\nPySide.QtCore.QtValidLicenseForDeclarativeModule.LicensedDeclarative"
    }, 
    {
        "loadPreset() (PresetsLoadPanel)": null
    }, 
    {
        "la (AnimCurveKey)": "la\n      The left bicubic value for this key."
    }, 
    {
        "LicensedDeclarative (nukescripts.udim)": "LicensedDeclarative\n\n\n\nValue:\n\nPySide.QtCore.QtValidLicenseForDeclarativeModule.LicensedDeclarative"
    }, 
    {
        "loadPreset() (UserPresetsLoadPanel)": null
    }, 
    {
        "la (AnimationKey)": "la\n      The left 'bicubic' value"
    }, 
    {
        "LicensedMultimedia (nukescripts)": "LicensedMultimedia\n\n\n\nValue:\n\nPySide.QtCore.QtValidLicenseForMultimediaModule.LicensedMultimedia"
    }, 
    {
        "loadToolset() (nuke)": "loadToolset(filename=None,\n        overwrite=-1)\n\n\u00a0\n    \n\nLoads the tool preset with the given file name.\n\nParameters:\n\nfilename - name of preset script file to load\n\nReturns: None"
    }, 
    {
        "label() (Knob)": "label(self)\n\n\u00a0\n    \n\n\nReturns: label\nlabel."
    }, 
    {
        "LicensedMultimedia (nukescripts.udim)": "LicensedMultimedia\n\n\n\nValue:\n\nPySide.QtCore.QtValidLicenseForMultimediaModule.LicensedMultimedia"
    }, 
    {
        "LOCALE (re)": "LOCALE = 4"
    }, 
    {
        "last() (FrameRange)": "last(self)\n      return the last frame of the range."
    }, 
    {
        "LicensedOpenVG (nukescripts)": "LicensedOpenVG\n\n\n\nValue:\n\nPySide.QtCore.QtValidLicenseForOpenVGModule.LicensedOpenVG"
    }, 
    {
        "localisationEnabled() (nuke)": "localisationEnabled(knob)\n\n\u00a0\n    \n\n\brief Checks if localisation is enabled on a given Read_File_Knob.\n\nParameters:\n\nknob - The Read_File_Knob to check.\n\nReturns: bool\ntrue if enabled, false otherwise"
    }, 
    {
        "last_cmd (nukescripts.script)": null
    }, 
    {
        "LicensedOpenVG (nukescripts.udim)": "LicensedOpenVG\n\n\n\nValue:\n\nPySide.QtCore.QtValidLicenseForOpenVGModule.LicensedOpenVG"
    }, 
    {
        "localiseFiles() (nuke)": "localiseFiles(readKnobs)\n\n\u00a0\n    \n\ncreates localisations of all files pointed to by the given read \n  knobs\n\nParameters:\n\nreadKnobs - List of read knobs.\n\nReturns: None\nNone."
    }, 
    {
        "lastFrame() (Node)": "lastFrame(self)\n\n\u00a0\n    \n\nLast frame in frame range for this node.\n\nReturns: int\nint."
    }, 
    {
        "LINEAR (nuke)": "LINEAR = 2"
    }, 
    {
        "locked (Element)": "locked\n      Whether this element is locked."
    }, 
    {
        "lastFrame() (Root)": "lastFrame(self)\n\n\u00a0\n    \n\nLast frame.\n\nReturns: Integer\nInteger.\nOverrides:\n        Node.lastFrame"
    }, 
    {
        "linesep (os)": "linesep = '\\n'"
    }, 
    {
        "LOG (nuke)": "LOG = 4"
    }, 
    {
        "Layer (_curveknob)": null
    }, 
    {
        "Link_Knob (nuke)": null
    }, 
    {
        "LookupCurves_Knob (nuke)": null
    }, 
    {
        "Layer (nuke)": null
    }, 
    {
        "LinkableKnobInfo (nuke)": null
    }, 
    {
        "lowSoft() (Keyer_Knob)": "lowSoft(...)"
    }, 
    {
        "Layer (nukescripts.psd)": null
    }, 
    {
        "linkableKnobs() (Node)": "linkableKnobs(self,\n        knobType)\n\n\u00a0\n    \n\nReturns a list of any knobs that may be linked to from the node as \n  well as some meta information about the knob. This may include whether \n  the knob is enabled and whether it should be used for absolute or \n  relative values. Not all of these variables may make sense for all \n  knobs..\n\nParameters:\n\nknobType, A, KnobType, describing, the, type, of, knobs, you, want.@return - A list of LinkableKnobInfo that may be empty .\n\nReturns: List"
    }, 
    {
        "lowTol() (Keyer_Knob)": "lowTol(...)"
    }, 
    {
        "layers() (Root)": "layers(...)\n\n\u00a0\n    \n\nnuke.Root.layers() -> Layer list. Class method.\n\nReturns:\nLayer list."
    }, 
    {
        "lslope (AnimCurveKey)": "lslope\n      The left derivative for this key."
    }, 
    {
        "layers() (nuke)": "layers(node=None)\n\n\u00a0\n    \n\nLists the layers in a node. If no node is provided this will list all \n  known layer names in this script.\n\nParameters:\n\nnode - Optional node parameter.\n\nReturns: string list\nA list of layer names."
    }, 
    {
        "linux_version() (FramecyclerFlipbook)": "linux_version(self)\n\nsource\u00a0code"
    }, 
    {
        "lslope (AnimationKey)": "lslope\n      The derivative to the left of the point"
    }, 
    {
        "layerSelector() (Channel_Knob)": "layerSelector(self)"
    }, 
    {
        "load() (nuke)": "load(s)\n\n\u00a0\n    \n\nLoad a plugin. You can force a certain plugin to load with this \n  function. If the plugin has already been loaded nothing happens. If there\n  is no slash in the name then the pluginPath() is searched for it. If \n  there is a slash then the name is used directly as a filename, if it does\n  not start with a slash the name is relative to the directory containing \n  any plugin being currently loaded. If no filename extension is provided, \n  it will try appending '.so' (or whatever your OS dynamic library \n  extension is) and finding nothing will also try to append '.tcl' and \n  '.py'.\n\nParameters:\n\ns - Plugin name or filename.\n\nReturns: None\nNone\nRaises:\n\nRuntimeError - if the plugin couldn't be loaded for any reason."
    }, 
    {
        "Lut (nuke)": null
    }, 
    {
        "leftTangent (ShapeControlPoint)": "leftTangent\n      The left tangent offsets, relative to the center point."
    }, 
    {
        "load_all_plugins() (nukescripts.all_plugins)": null
    }, 
    {
        "M (re)": "M = 8"
    }, 
    {
        "maximumOutputs() (Root)": "maximumOutputs(self)\n\n\u00a0\n    \n\n\nReturns: Maximum number of outputs this node can have\nMaximum number of outputs this node can have.\nOverrides:\n        Node.maximumOutputs\n(inherited documentation)"
    }, 
    {
        "metadata() (Node)": "metadata(self,\n        key,\n        time,\n        view)\n\n\u00a0\n    \n\nReturn the metadata item for key on this node at current output \n  context, or at optional time and view. If key is not specified a \n  dictionary containing all key/value pairs is returned. None is returned \n  if key does not exist on this node.\n\nParameters:\n\nkey - Optional name of the metadata key to retrieve.\ntime - Optional time to evaluate at (default is taken from node's \n          current output context).\nview - Optional view to evaluate at (default is taken from node's \n          current output context).\n\nReturns: value or dict\nThe requested metadata value, a dictionary containing all keys if\n          a key name is not provided, or None if the specified key is not \n          matched."
    }, 
    {
        "makeGroup() (Gizmo)": "makeGroup(self)\n\n\u00a0\n    \n\nCreates a Group node copy of the Gizmo node.\n\nReturns: Group\nGroup."
    }, 
    {
        "maxInputs() (Node)": "maxInputs(self)\n\n\u00a0\n    \n\n\nReturns: Maximum number of inputs this node can have\nMaximum number of inputs this node can have."
    }, 
    {
        "min() (Array_Knob)": "min(self)\n\n\u00a0\n    \n\n\nReturns: Minimum value\nMinimum value."
    }, 
    {
        "makeGroup() (nuke)": "makeGroup(show=True)\n\n\u00a0\n    \n\nCreates a new group containing copies of all the currently selected \n  nodes. Note that this creates duplicates of the selected nodes, rather \n  than moving them.\n\nParameters:\n\nshow - If show is True, the node graph for the new group is shown.\n\nReturns: Group\nThe new Group node."
    }, 
    {
        "maxint (sys)": "maxint = 9223372036854775807"
    }, 
    {
        "minFrame() (FrameRange)": "minFrame(self)\n      return the minimun frame define in the range."
    }, 
    {
        "makeIdentity() (CMatrix4)": "makeIdentity(self)\n      Set this matrix to be the identity matrix."
    }, 
    {
        "maxOutputs() (Node)": "maxOutputs(self)\n\n\u00a0\n    \n\n\nReturns: Maximum number of outputs this node can have\nMaximum number of outputs this node can have."
    }, 
    {
        "minFrame() (FrameRanges)": "minFrame()\n      get minimun frame of all ranges."
    }, 
    {
        "makeLink() (Link_Knob)": "makeLink(s,\n        t)"
    }, 
    {
        "maxsize (sys)": "maxsize = 9223372036854775807"
    }, 
    {
        "minimum() (Array_Knob)": "minimum(self)\n\n\u00a0\n    \n\n\nReturns: Minimum value\nMinimum value."
    }, 
    {
        "makeUI() (WidgetKnob)": null
    }, 
    {
        "maxunicode (sys)": "maxunicode = 1114111"
    }, 
    {
        "minimumInputs() (Node)": "minimumInputs(self)\n\n\u00a0\n    \n\n\nReturns: Minimum number of inputs this node can have\nMinimum number of inputs this node can have."
    }, 
    {
        "makeUI() (WebBrowserKnob)": null
    }, 
    {
        "memory() (nuke)": "memory(cmd,\n        value)\n\n\u00a0\n    \n\n\nGet or set information about memory usage.\n\nThe value parameter is optional and is only used by some of the commands (see below).\n\nThe cmd parameter specifies what memory information to retrieve. It can be one of the following values:\n- info [node-name]                           Return a string describing current memory usage. Can optionally provide it for a specific node.\n- infoxml [format_bytes] [node-name]         Return current memory usage as above, but in XML format. Can optionally provide if bytes should be formatted to be human readable, and also a specific node\n- allocator_info [format_bytes]              Return current allocator usage in XML format. Can optionally provide if bytes should be formatted to be human readable\n- free [size]                                Free as much memory as possible. If a size is specified, if will stop trying to free memory when usage drops below the size.\n- usage                                      Return the amount of memory currently in use.\n- max_usage [size]                           If no size is specified, returns the current size of the memory limit.  If a size is given, then set this size as the memory limit.\n- total_ram                                  Return the total amount of RAM.\n- total_vm                                   Return the total virtual memory.\n- free_count [num]                           Get or set the free count.\n- new_handler_count [num]                    Get or set the new handler count.\n\n\n\nReturns: str or int"
    }, 
    {
        "minimumInputs() (Root)": "minimumInputs(self)\n\n\u00a0\n    \n\n\nReturns: Minimum number of inputs this node can have\nMinimum number of inputs this node can have.\nOverrides:\n        Node.minimumInputs\n(inherited documentation)"
    }, 
    {
        "MATCH_CLASS (nuke)": "MATCH_CLASS = 0"
    }, 
    {
        "Menu (nuke)": null
    }, 
    {
        "minInputs() (Node)": "minInputs(self)\n\n\u00a0\n    \n\n\nReturns: Minimum number of inputs this node can have\nMinimum number of inputs this node can have."
    }, 
    {
        "MATCH_COLOR (nuke)": "MATCH_COLOR = 2"
    }, 
    {
        "menu (nukescripts.pyQtExamples.webBrowser)": null
    }, 
    {
        "misc (nukescripts)": null
    }, 
    {
        "MATCH_LABEL (nuke)": "MATCH_LABEL = 1"
    }, 
    {
        "menu() (Menu)": "menu(self,\n        name)\n\n\u00a0\n    \n\nFinds a submenu or command with a particular name.\n\nParameters:\n\nname - The name to search for.\n\nReturns: Menu or None\nThe submenu or command we found, or None if we could not find \n          anything."
    }, 
    {
        "modified() (Root)": "modified(self)\n\n\u00a0\n    \n\nGet or set the 'modified' flag in a script\n\nReturns: True if modified, False otherwise\nTrue if modified, False otherwise."
    }, 
    {
        "menu() (MenuBar)": "menu(self,\n        name)\n\n\u00a0\n    \n\nFinds a submenu or command with a particular name.\n\nParameters:\n\nname - The name to search for.\n\nReturns: Menu or None\nThe submenu or command we found, or None if we could not find \n          anything."
    }, 
    {
        "modified() (nuke)": "modified(status)\n\n\u00a0\n    \n\nDeprecated. Use Root.modified and Root.setModified.\nGet or set the 'modified' flag in a script. Setting the value will \n  turn the indicator in the title bar on/off and will start or stop the \n  autosave timeout.\n\nParameters:\n\nstatus - Optional boolean value. If this is present the status will be set\n          to this value; otherwise it will be retrieved instead.\n\nReturns: True if modified, False otherwise\nTrue if modified, False otherwise."
    }, 
    {
        "menu() (ToolBar)": "menu(self,\n        name)\n\n\u00a0\n    \n\nFinds a submenu or command with a particular name.\n\nParameters:\n\nname - The name to search for.\n\nReturns: Menu or None\nThe submenu or command we found, or None if we could not find \n          anything."
    }, 
    {
        "modifyPoint() (CorrespondencePoints)": "modifyPoint(cps,\n        time,\n        index,\n        which,\n        t)\n\n\u00a0\n    \n\n\nParameters:\n\ntime - Time at which to t_in and t_out will be set\nindex - Index to the point to modify\nwhich - Whether the source (0) or destination (1) t-value is being \n          modified\nt - Position on the curve specified in by 'which'"
    }, 
    {
        "max() (Array_Knob)": "max(self)\n\n\u00a0\n    \n\n\nReturns: Maximum value\nMaximum value."
    }, 
    {
        "menu() (nuke)": "menu(name)\n\n\u00a0\n    \n\nFind and return the Menu object with the given name. Current valid \n  menus are:\n'Nuke'          the application menu 'Pane'          the UI Panes \n  & Panels menu 'Nodes'         the Nodes toolbar (and Nodegraph right \n  mouse menu) 'Properties'    the Properties panel right mouse menu \n  'Animation'     the knob Animation menu and Curve Editor right mouse menu\n  'Viewer'        the Viewer right mouse menu 'Node Graph'    the Node \n  Graph right mouse menu 'Axis'          functions which appear in menus on\n  all Axis_Knobs.\n\nParameters:\n\nname - The name of the menu to get. Must be one of the values above.\n\nReturns: Menu\nThe menu.\nRaises:\n\nRuntimeError - if Nuke isn't in GUI mode."
    }, 
    {
        "modules (sys)": "modules\n\n\n\nValue:\n\n{'ConfigParser': <module 'ConfigParser' from '/workspace/peter/7.0dev_\n3/Apps/Nuke/nuke/objects/linux-64-x86-release-410/Bundle/lib/python2.6\n/ConfigParser.pyc'>,\n 'PyOpenColorIO': <module 'PyOpenColorIO' from '/workspace/peter/7.0de\nv_3/Apps/Nuke/nuke/objects/linux-64-x86-release-410/Bundle/plugins/PyO\npenColorIO.so'>,\n 'PyOpenColorIO.Constants': <module 'PyOpenColorIO.Constants' (built-i\nn)>,\n..."
    }, 
    {
        "maxFrame() (FrameRange)": "maxFrame(self)\n      return the maximun frame define in the range."
    }, 
    {
        "MenuBar (nuke)": null
    }, 
    {
        "MONITOR (nuke)": "MONITOR = 0"
    }, 
    {
        "maxFrame() (FrameRanges)": "maxFrame()\n      get maximun frame of all ranges."
    }, 
    {
        "MenuItem (nuke)": null
    }, 
    {
        "move() (Box)": "move(self,\n        dx,\n        dy)\n      Move all the sides and thus the entire box by the given deltas."
    }, 
    {
        "maximum() (Array_Knob)": "maximum(self)\n\n\u00a0\n    \n\n\nReturns: Maximum value\nMaximum value."
    }, 
    {
        "merge() (Box)": "merge(self,\n        x,\n        y,\n        r,\n        t)\n      Merge with the given edges."
    }, 
    {
        "MULTILINE (re)": "MULTILINE = 8"
    }, 
    {
        "maximumInputs() (Node)": "maximumInputs(self)\n\n\u00a0\n    \n\n\nReturns: Maximum number of inputs this node can have\nMaximum number of inputs this node can have."
    }, 
    {
        "mergeFrameRange() (Root)": "mergeFrameRange(self,\n        a,\n        b)\n\n\u00a0\n    \n\nMerge frame range.\n\nParameters:\n\na - Low-end of interval range.\nb - High-end of interval range.\n\nReturns: None\nNone."
    }, 
    {
        "Multiline_Eval_String_Knob (nuke)": null
    }, 
    {
        "maximumInputs() (Root)": "maximumInputs(self)\n\n\u00a0\n    \n\n\nReturns: Maximum number of inputs this node can have\nMaximum number of inputs this node can have.\nOverrides:\n        Node.maximumInputs\n(inherited documentation)"
    }, 
    {
        "message() (nuke)": "critical(message)\n\n\u00a0\n    \n\nPuts the message into the error console, treating it like an error. \n  Also pops up an alert dialog to the user, immediately.\n\nParameters:\n\nmessage - String parameter.\n\nReturns: None\nNone."
    }, 
    {
        "multilineTextInput (nukescripts.panel_test)": null
    }, 
    {
        "maximumOutputs() (Node)": "maximumOutputs(self)\n\n\u00a0\n    \n\n\nReturns: Maximum number of outputs this node can have\nMaximum number of outputs this node can have."
    }, 
    {
        "meta_path (sys)": "meta_path = []"
    }, 
    {
        "MultiView_Knob (nuke)": null
    }, 
    {
        "n() (Box3_Knob)": "n(...)\n\n\u00a0\n    \n\nReturn value for N position. N (near) is the minimum Z extent of the \n  box."
    }, 
    {
        "names() (Color_Knob)": "names(n)\n\n\u00a0\n    \n\nReturn name for dimension n. The argument n is an integer.\n\nReturns: string"
    }, 
    {
        "Nodes (nuke)": null
    }, 
    {
        "n_fields (stat_result)": "n_fields = 16"
    }, 
    {
        "names() (Keyer_Knob)": "names(self,\n        n)\n\n\u00a0\n    \n\n\nParameters:\n\nn - The index of the name to return.\n\nReturns: string\nThe name at position n."
    }, 
    {
        "nodes (nuke)": "dependencies(nodes,\n        what=7)\n\nsource\u00a0code\u00a0\n    \n\n\nList all nodes referred to by the nodes argument. 'what' is an optional integer (see below).\n  You can use the following constants or'ed together to select the types of dependencies that are looked for:\n         nuke.EXPRESSIONS = expressions\n         nuke.INPUTS = visible input pipes\n         nuke.HIDDEN_INPUTS = hidden input pipes.\n  The default is to look for all types of connections.\n  \nExample:\n  n1 = nuke.nodes.Blur()\n  n2 = nuke.nodes.Merge()\n  n2.setInput(0, n1)\n  deps = nuke.dependencies([n2], nuke.INPUTS | nuke.HIDDEN_INPUTS | nuke.EXPRESSIONS)"
    }, 
    {
        "n_fields (statvfs_result)": "n_fields = 10"
    }, 
    {
        "names() (Scale_Knob)": "names(n)\n\n\u00a0\n    \n\nReturn name for dimension n. The argument n is an integer.\n\nReturns: string"
    }, 
    {
        "nodes (nukescripts)": null
    }, 
    {
        "n_sequence_fields (stat_result)": "n_sequence_fields = 10"
    }, 
    {
        "names() (UV_Knob)": "names(n)\n\n\u00a0\n    \n\nReturn name for dimension n. The argument n is an integer.\n\nReturns: string"
    }, 
    {
        "nodes() (Group)": "nodes(self)\n\n\u00a0\n    \n\nList of nodes in group.\n\nReturns: List of nodes\nList of nodes"
    }, 
    {
        "n_sequence_fields (statvfs_result)": "n_sequence_fields = 10"
    }, 
    {
        "names() (WH_Knob)": "names(...)\n      Return name for dimension 'i'."
    }, 
    {
        "nodesSelected() (nuke)": "nodesSelected()\n      returns true if any nodes are currently selected"
    }, 
    {
        "n_unnamed_fields (stat_result)": "n_unnamed_fields = 3"
    }, 
    {
        "names() (XYZ_Knob)": "names(n)\n\n\u00a0\n    \n\nReturn name for dimension n. The argument n is an integer.\n\nReturns: string"
    }, 
    {
        "NODIR (nuke)": "NODIR = 2"
    }, 
    {
        "n_unnamed_fields (statvfs_result)": "n_unnamed_fields = 0"
    }, 
    {
        "names() (XY_Knob)": "names(n)\n\n\u00a0\n    \n\nReturn name for dimension n. The argument n is an integer.\n\nReturns: string"
    }, 
    {
        "noExpression() (AnimationCurve)": "noExpression(self)\n\n\u00a0\n    \n\n\nReturns: bool\nTrue if the expression is the default expression (i.e. the keys \n          control the curve), False otherwise."
    }, 
    {
        "name (Element)": "name\n      The name for this element."
    }, 
    {
        "new() (Undo)": "new(...)\n      Same as end();begin()."
    }, 
    {
        "NoHint (EndEditHint)": "values\n\n\n\nValue:\n\n{'EditNextItem': PySide.QtGui.QAbstractItemDelegate.EndEditHint.EditNe\nxtItem,\n 'EditPreviousItem': PySide.QtGui.QAbstractItemDelegate.EndEditHint.Ed\nitPreviousItem,\n 'NoHint': PySide.QtGui.QAbstractItemDelegate.EndEditHint.NoHint,\n 'RevertModelCache': PySide.QtGui.QAbstractItemDelegate.EndEditHint.Re\nvertModelCache,\n 'SubmitModelCache': PySide.QtGui.QAbstractItemDelegate.EndEditHint.Su\n..."
    }, 
    {
        "name (AnimCTransform)": "name\n      The name for this transform."
    }, 
    {
        "next() (FrameRange)": "next(x)"
    }, 
    {
        "notDefault() (Array_Knob)": "notDefault(self)\n\n\u00a0\n    \n\n\nReturns: True if any of the values is not set to the default, False otherwise\nTrue if any of the values is not set to the default, False \n          otherwise."
    }, 
    {
        "name (AnimControlPoint)": "name\n      The name of the control point (if any)."
    }, 
    {
        "next() (FrameRanges)": "next(x)"
    }, 
    {
        "notDefault() (Format_Knob)": "notDefault()"
    }, 
    {
        "name (BaseCurve)": "name\n      The name for this curve."
    }, 
    {
        "nextView() (ViewerWindow)": "nextView(self)"
    }, 
    {
        "notDefault() (MultiView_Knob)": "notDefault()"
    }, 
    {
        "name (CTransform)": "name\n      The name for this transform."
    }, 
    {
        "NGROUPS_MAX (os)": "NGROUPS_MAX = 65536"
    }, 
    {
        "notepad (nukescripts.panel_test)": null
    }, 
    {
        "name (ControlPoint)": "name\n      The name."
    }, 
    {
        "NO_ANIMATION (nuke)": "NO_ANIMATION = 256"
    }, 
    {
        "name (os)": "fpathconf(fd,\n        name)\n\n\u00a0\n    \n\nReturn the configuration limit name for the file descriptor fd. If \n  there is no limit, return -1.\n\nReturns: integer"
    }, 
    {
        "NO_CHECKMARKS (nuke)": "NO_CHECKMARKS = 1"
    }, 
    {
        "NUKE_VERSION_DATE (nuke)": "NUKE_VERSION_DATE = 'Nov 23 2012'"
    }, 
    {
        "name() (Format)": "add(self,\n        name)\n\n\u00a0\n    \n\nAdd this instance to a list of \"named\" formats. The name \n  parameter is the name of the list to add the format to.\n\nReturns: None"
    }, 
    {
        "NO_MULTIVIEW (nuke)": "NO_MULTIVIEW = 1073741824"
    }, 
    {
        "NUKE_VERSION_MAJOR (nuke)": "NUKE_VERSION_MAJOR = 7"
    }, 
    {
        "name() (Format_Knob)": "name()\n\n\u00a0\n    \n\nReturn name of knob.\n\nReturns: string\nname.\nOverrides:\n        Knob.name"
    }, 
    {
        "NO_POSTAGESTAMPS (nuke)": "NO_POSTAGESTAMPS = False"
    }, 
    {
        "NUKE_VERSION_MINOR (nuke)": "NUKE_VERSION_MINOR = 0"
    }, 
    {
        "name() (Knob)": "name(self)\n\n\u00a0\n    \n\n\nReturns: name\nname."
    }, 
    {
        "NO_UNDO (nuke)": "NO_UNDO = 524288"
    }, 
    {
        "NUKE_VERSION_PHASE (nuke)": "NUKE_VERSION_PHASE = 'd'"
    }, 
    {
        "name() (Layer)": "name(self)\n\n\u00a0\n    \n\nGet the layer name.\n\nReturns: str\nThe layer name, as a string."
    }, 
    {
        "Node (nuke)": null
    }, 
    {
        "NUKE_VERSION_PHASENUMBER (nuke)": "NUKE_VERSION_PHASENUMBER = 0"
    }, 
    {
        "name() (Menu)": "addCommand(self,\n        name,\n        command,\n        shortcut,\n        icon,\n        tooltip,\n        index,\n        readonly)\n\n\u00a0\n    \n\nAdd a new command to this menu/toolbar. Note that when invoked, the \n  command is automatically enclosed in an undo group, so that undo/redo \n  functionality works. Optional arguments can be specified by name. Note \n  that if the command argument is not specified, then the command will be \n  auto-created as a \"nuke.createNode()\" using the name argument \n  as the node to create.\nExample: menubar = nuke.menu('Nuke') fileMenu = \n  menubar.findItem('File') fileMenu.addCommand('NewCommand', 'print 10', \n  shortcut='t')\n\nParameters:\n\nname - The name for the menu/toolbar item. The name may contain submenu \n          names delimited by '/' or '', and submenus are created as needed.\ncommand - Optional. The command to add to the menu/toolbar. This can be a \n          string to evaluate or a Python Callable (function, method, etc) \n          to run.\nshortcut - Optional. The keyboard shortcut for the command, such as 'R', \n          'F5' or 'Ctrl-H'. Note that this overrides pre-existing other \n          uses for the shortcut.\nicon - Optional. An icon for the command. This should be a path to an \n          icon in the nuke.pluginPath() directory. If the icon is not \n          specified, Nuke will automatically try to find an icon with the \n          name argument and .png appended to it.\ntooltip - Optional. The tooltip text, displayed on mouseover for toolbar \n          buttons.\nindex - Optional. The position to insert the new item in, in the \n          menu/toolbar. This defaults to last in the menu/toolbar.\nreadonly - Optional. True/False for whether the item should be available \n          when the menu is invoked in a read-only context.\n\nReturns: The menu/toolbar item that was added to hold the command\nThe menu/toolbar item that was added to hold the command."
    }, 
    {
        "node() (Group)": "node(self,\n        s)\n\n\u00a0\n    \n\nLocate a node by name.\n\nParameters:\n\ns - A string.\n\nReturns: Node with name s or None\nNode with name s or None."
    }, 
    {
        "NUKE_VERSION_RELEASE (nuke)": "NUKE_VERSION_RELEASE = 0"
    }, 
    {
        "name() (MenuBar)": "addCommand(self,\n        name,\n        command,\n        shortcut,\n        icon,\n        tooltip,\n        index,\n        readonly)\n\n\u00a0\n    \n\nAdd a new command to this menu/toolbar. Note that when invoked, the \n  command is automatically enclosed in an undo group, so that undo/redo \n  functionality works. Optional arguments can be specified by name. Note \n  that if the command argument is not specified, then the command will be \n  auto-created as a \"nuke.createNode()\" using the name argument \n  as the node to create.\nExample: menubar = nuke.menu('Nuke') fileMenu = \n  menubar.findItem('File') fileMenu.addCommand('NewCommand', 'print 10', \n  shortcut='t')\n\nParameters:\n\nname - The name for the menu/toolbar item. The name may contain submenu \n          names delimited by '/' or '', and submenus are created as needed.\ncommand - Optional. The command to add to the menu/toolbar. This can be a \n          string to evaluate or a Python Callable (function, method, etc) \n          to run.\nshortcut - Optional. The keyboard shortcut for the command, such as 'R', \n          'F5' or 'Ctrl-H'. Note that this overrides pre-existing other \n          uses for the shortcut.\nicon - Optional. An icon for the command. This should be a path to an \n          icon in the nuke.pluginPath() directory. If the icon is not \n          specified, Nuke will automatically try to find an icon with the \n          name argument and .png appended to it.\ntooltip - Optional. The tooltip text, displayed on mouseover for toolbar \n          buttons.\nindex - Optional. The position to insert the new item in, in the \n          menu/toolbar. This defaults to last in the menu/toolbar.\nreadonly - Optional. True/False for whether the item should be available \n          when the menu is invoked in a read-only context.\n\nReturns: The menu/toolbar item that was added to hold the command\nThe menu/toolbar item that was added to hold the command."
    }, 
    {
        "node() (Knob)": "node(self)\n\n\u00a0\n    \n\nReturn the node that this knob belongs to. If the node has been \n  cloned, we'll always return a reference to the original.\n\nReturns: nuke.Node\nThe node which owns this knob, or None if the knob has no owner \n          yet."
    }, 
    {
        "NUKE_VERSION_STRING (nuke)": "NUKE_VERSION_STRING = '7.0v0d0'"
    }, 
    {
        "name() (MenuItem)": "name(self)\n      Returns the name of the menu item."
    }, 
    {
        "node() (ViewerProcess)": "node(...)\n\n\u00a0\n    \n\nnuke.ViewerProcess.node(name, viewer) -> Node. Returns a \n  ViewerProcess node. Default is to return the current selected one. This \n  is a class method.\n\nParameters:\n\nname - Optional ViewerProcess name.\nviewer - Optional viewer name.\n\nReturns:\nNode."
    }, 
    {
        "name() (Node)": "name(self)\n\n\u00a0\n    \n\n\nReturns: str\nName of node."
    }, 
    {
        "node() (ViewerWindow)": "node(self)\n\n\u00a0\n    \n\nReturns the Viewer node currently associated with this window.\n\nReturns: Node\nNode."
    }, 
    {
        "NUM_CPUS (nuke)": "NUM_CPUS = 16"
    }, 
    {
        "name() (ToolBar)": "addCommand(self,\n        name,\n        command,\n        shortcut,\n        icon,\n        tooltip,\n        index,\n        readonly)\n\n\u00a0\n    \n\nAdd a new command to this menu/toolbar. Note that when invoked, the \n  command is automatically enclosed in an undo group, so that undo/redo \n  functionality works. Optional arguments can be specified by name. Note \n  that if the command argument is not specified, then the command will be \n  auto-created as a \"nuke.createNode()\" using the name argument \n  as the node to create.\nExample: menubar = nuke.menu('Nuke') fileMenu = \n  menubar.findItem('File') fileMenu.addCommand('NewCommand', 'print 10', \n  shortcut='t')\n\nParameters:\n\nname - The name for the menu/toolbar item. The name may contain submenu \n          names delimited by '/' or '', and submenus are created as needed.\ncommand - Optional. The command to add to the menu/toolbar. This can be a \n          string to evaluate or a Python Callable (function, method, etc) \n          to run.\nshortcut - Optional. The keyboard shortcut for the command, such as 'R', \n          'F5' or 'Ctrl-H'. Note that this overrides pre-existing other \n          uses for the shortcut.\nicon - Optional. An icon for the command. This should be a path to an \n          icon in the nuke.pluginPath() directory. If the icon is not \n          specified, Nuke will automatically try to find an icon with the \n          name argument and .png appended to it.\ntooltip - Optional. The tooltip text, displayed on mouseover for toolbar \n          buttons.\nindex - Optional. The position to insert the new item in, in the \n          menu/toolbar. This defaults to last in the menu/toolbar.\nreadonly - Optional. True/False for whether the item should be available \n          when the menu is invoked in a read-only context.\n\nReturns: The menu/toolbar item that was added to hold the command\nThe menu/toolbar item that was added to hold the command."
    }, 
    {
        "node_copypaste() (nukescripts.edit)": "node_copypaste()\n\nsource\u00a0code"
    }, 
    {
        "NUM_INTERPOLATIONS (nuke)": "NUM_INTERPOLATIONS = 5"
    }, 
    {
        "name() (Undo)": "name(...)\n      Name current undo set."
    }, 
    {
        "node_delete() (nukescripts.nodes)": null
    }, 
    {
        "numKnobs() (Node)": "numKnobs(self)\n\n\u00a0\n    \n\n\nReturns: The number of knobs\nThe number of knobs."
    }, 
    {
        "name() (FlipbookApplication)": "name(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the name of the flipbook.\n\nReturns:\nString"
    }, 
    {
        "NodeConstructor (nuke)": null
    }, 
    {
        "numNodes() (Group)": "numNodes(self)\n\n\u00a0\n    \n\nNumber of nodes in group.\n\nReturns: Number of nodes\nNumber of nodes"
    }, 
    {
        "name() (FramecyclerFlipbook)": "name(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the name of the flipbook.\n\nReturns:\nString\nOverrides:\n        flipbooking.FlipbookApplication.name\n(inherited documentation)"
    }, 
    {
        "nodeCopy() (nuke)": "nodeCopy(s)\n\n\u00a0\n    \n\nCopy all selected nodes into a file or the clipboard.\n\nParameters:\n\ns - The name of a clipboad to copy into. If s is the string \n          '%clipboard%' this will copy into the operating systems \n          clipboard.\n\nReturns: bool\nTrue if any nodes were selected, False otherwise."
    }, 
    {
        "numvalue() (nuke)": "numvalue(knob,\n        default=infinity)\n\n\u00a0\n    \n\nThe numvalue function returns the current value of a knob.\nThis is the same as the value() command except it will always return a\n  number. For enumerations this returns the index into the menu, starting \n  at zero. For checkmarks this returns 0 for false and 1 for true.\n\nParameters:\n\nknob - A knob.\ndefault - Optional default value to return if the knob's value cannot  be \n          converted to a number.\n\nReturns: float\nA numeric value for the knob, or the default value (if any)."
    }, 
    {
        "name() (ExampleRVFlipbook)": "name(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the name of the flipbook.\n\nReturns:\nString\nOverrides:\n        flipbooking.FlipbookApplication.name\n(inherited documentation)"
    }, 
    {
        "nodeDelete() (nuke)": "nodeDelete(s)\n\n\u00a0\n    \n\nRemoves all selected nodes from the DAG.\n\nReturns: True if any nodes were deleted, False otherwise\nTrue if any nodes were deleted, False otherwise."
    }, 
    {
        "numValues() (Enumeration_Knob)": "numValues(self)\n\n\u00a0\n    \n\nReturn number of values. Deprecated.\n\nReturns: int"
    }, 
    {
        "names() (BBox_Knob)": "names(...)\n      Return name for dimension 'i'"
    }, 
    {
        "nodePaste() (nuke)": "nodePaste(s)\n\n\u00a0\n    \n\nPaste nodes from a script file or the clipboard. This function \n  executes the script stored in a file. It is assumed the script is the \n  result of a nodeCopy command. The 's' argument can be '%clipboard%' to \n  paste the operating system's clipboard contents.\n\nParameters:\n\ns - The 's' argument can be '%clipboard%' to paste the operating \n          system's clipboard contents.\n\nReturns: Node\nNode"
    }, 
    {
        "numValues() (Pulldown_Knob)": "numValues()\n\n\u00a0\n    \n\nReturn number of values.\n\nReturns: int\nOverrides:\n        Enumeration_Knob.numValues"
    }, 
    {
        "names() (Box3_Knob)": "names(...)\n      Return name for dimension 'i'"
    }, 
    {
        "nodepresets (nukescripts)": null
    }, 
    {
        "O_APPEND (os)": "O_APPEND = 1024"
    }, 
    {
        "oculaPresent() (nuke)": "oculaPresent()\n\n\u00a0\n    \n\nCheck whether Ocula is present.\n\nReturns: bool\nTrue if Ocula is present, False if not."
    }, 
    {
        "onScriptLoad() (nuke.callbacks)": "onScriptLoad()\n\nsource\u00a0code"
    }, 
    {
        "O_ASYNC (os)": "O_ASYNC = 8192"
    }, 
    {
        "ofxAddPluginAliasExclusion() (nuke)": "ofxAddPluginAliasExclusion(fullOfxEffectName)\n\n\u00a0\n    \n\nAdds the ofx effect name to a list of exclusions that will not get tcl\n  aliases automatically created for them. For example, if there is an ofx \n  plugin with a fully qualified name of: \n  'OFXuk.co.thefoundry.noisetools.denoise_v100'. Nuke by default would \n  automatically alias that so that nuke.createNode('Denoise') will create \n  that node type. By calling \n  nuke.ofxAddPluginAliasExclusion('OFXuk.co.thefoundry.noisetools.denoise_v100'),\n  you'd be changing that such that the only way to create a node of that \n  type would be to call \n  nuke.createNode('OFXuk.co.thefoundry.noisetools.denoise_v100') This does \n  not change saving or loading of Nuke scripts with that plugin used in any\n  way.\n\nParameters:\n\nfullOfxEffectName - The fully qualified name of the ofx plugin to add to the \n          exclusion list.\n\nReturns: None\nNone."
    }, 
    {
        "onScriptLoads (nuke.callbacks)": "onScriptLoads = {}"
    }, 
    {
        "O_CREAT (os)": "O_CREAT = 64"
    }, 
    {
        "ofxMenu() (nuke)": "ofxMenu()\n\n\u00a0\n    \n\nFind all the OFX plugins (by searching all the directories below \n  $OFX_PLUGIN_PATH, or by reading a cache file stored in $NUKE_TEMP_DIR), \n  then add a menu item for each of them to the main menu.\n\nReturns: bool\nTrue if succeeded, False otherwise."
    }, 
    {
        "onScriptLoads (nuke)": "onScriptLoads = {}"
    }, 
    {
        "O_DIRECT (os)": "O_DIRECT = 16384"
    }, 
    {
        "ofxPluginPath() (nuke)": "ofxPluginPath(nuke)\n\n\u00a0\n    \n\nList of all the directories Nuke searched for OFX plugins in.\n\nReturns: String list\nString list"
    }, 
    {
        "onScriptSave() (nuke.callbacks)": "onScriptSave()\n\nsource\u00a0code"
    }, 
    {
        "O_DIRECTORY (os)": "O_DIRECTORY = 65536"
    }, 
    {
        "ofxRemovePluginAliasExclusion() (nuke)": "ofxRemovePluginAliasExclusion(fullOfxEffectName)\n\n\u00a0\n    \n\nRemove an ofx plugin alias exclusion that was previously added with . \n  Example: \n  nuke.ofxRemovePluginAliasExclusion('OFXuk.co.thefoundry.noisetools.denoise_v100')\n\nParameters:\n\nfullOfxEffectName - The fully qualified name of the ofx plugin to remove from the \n          exclusion list.\n\nReturns: None\nNone."
    }, 
    {
        "onScriptSaves (nuke.callbacks)": "onScriptSaves = {}"
    }, 
    {
        "O_DSYNC (os)": "O_DSYNC = 4096"
    }, 
    {
        "ok() (PythonPanel)": "ok(self)"
    }, 
    {
        "onScriptSaves (nuke)": "onScriptSaves = {}"
    }, 
    {
        "O_EXCL (os)": "O_EXCL = 128"
    }, 
    {
        "onAutoSave() (nukescripts.rollingAutoSave)": null
    }, 
    {
        "onUserCreate() (nuke.callbacks)": "onUserCreate()\n\nsource\u00a0code"
    }, 
    {
        "O_LARGEFILE (os)": "O_LARGEFILE = 0"
    }, 
    {
        "onAutoSaveDelete() (nukescripts.rollingAutoSave)": null
    }, 
    {
        "onUserCreates (nuke.callbacks)": "onUserCreates = {}"
    }, 
    {
        "O_NDELAY (os)": "O_NDELAY = 2048"
    }, 
    {
        "onAutoSaveRestore() (nukescripts.rollingAutoSave)": null
    }, 
    {
        "onUserCreates (nuke)": "onUserCreates = {}"
    }, 
    {
        "O_NOATIME (os)": "O_NOATIME = 262144"
    }, 
    {
        "onCreate() (nuke.callbacks)": "onCreate()\n\nsource\u00a0code"
    }, 
    {
        "openPanels() (nuke)": "openPanels()\n      returns a list of Nodes which have panels open.The last item in the \n      list is the currently active Node panel."
    }, 
    {
        "O_NOCTTY (os)": "O_NOCTTY = 256"
    }, 
    {
        "onCreateCallback() (pyQtRenderDialog)": "onCreateCallback(self)\n\nsource\u00a0code"
    }, 
    {
        "openurl (nukescripts)": null
    }, 
    {
        "O_NOFOLLOW (os)": "O_NOFOLLOW = 131072"
    }, 
    {
        "onCreates (nuke.callbacks)": "onCreates = {}"
    }, 
    {
        "opHashes() (Node)": "opHashes(self)\n      Returns a list of hash values, one for each op in this node."
    }, 
    {
        "O_NONBLOCK (os)": "O_NONBLOCK = 2048"
    }, 
    {
        "onCreates (nuke)": "onCreates = {}"
    }, 
    {
        "optionalInput() (Node)": "optionalInput(self)\n\n\u00a0\n    \n\n\nReturns: Number of first optional input\nNumber of first optional input."
    }, 
    {
        "O_RDONLY (os)": "O_RDONLY = 0"
    }, 
    {
        "onDestroy() (nuke.callbacks)": "onDestroy()\n\nsource\u00a0code"
    }, 
    {
        "optionalInput() (Root)": "optionalInput(self)\n\n\u00a0\n    \n\n\nReturns: Number of first optional input\nNumber of first optional input.\nOverrides:\n        Node.optionalInput\n(inherited documentation)"
    }, 
    {
        "O_RDWR (os)": "O_RDWR = 2"
    }, 
    {
        "onDestroys (nuke.callbacks)": "onDestroys = {}"
    }, 
    {
        "O_RSYNC (os)": "O_RSYNC = 4096"
    }, 
    {
        "onDestroys (nuke)": "onDestroys = {}"
    }, 
    {
        "O_SYNC (os)": "O_SYNC = 4096"
    }, 
    {
        "OneView_Knob (nuke)": null
    }, 
    {
        "output() (Group)": "output(self)\n\n\u00a0\n    \n\nReturn output node of group.\n\nReturns: Node or None\nNode or None."
    }, 
    {
        "O_TRUNC (os)": "O_TRUNC = 512"
    }, 
    {
        "onScriptClose() (nuke.callbacks)": "onScriptClose()\n\nsource\u00a0code"
    }, 
    {
        "output_redirector() (nuke)": "output_redirector(...)\n\n\u00a0\n    \n\nInternal to Nuke. Not for public use."
    }, 
    {
        "O_WRONLY (os)": "O_WRONLY = 1"
    }, 
    {
        "onScriptCloses (nuke.callbacks)": "onScriptCloses = {}"
    }, 
    {
        "OutputContext (nuke)": null
    }, 
    {
        "Obsolete_Knob (nuke)": null
    }, 
    {
        "onScriptCloses (nuke)": "onScriptCloses = {}"
    }, 
    {
        "overrides (nuke)": null
    }, 
    {
        "P_NOWAIT (os)": "P_NOWAIT = 1"
    }, 
    {
        "PdmWidth (PaintDeviceMetric)": "PdmWidth = PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmWidth"
    }, 
    {
        "PREPEND (nuke)": "PREPEND = 8"
    }, 
    {
        "P_NOWAITO (os)": "P_NOWAITO = 1"
    }, 
    {
        "PdmWidthMM (PaintDeviceMetric)": "PdmWidthMM\n\n\n\nValue:\n\nPySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmWidthMM"
    }, 
    {
        "PresetsDeletePanel (nukescripts.nodepresets)": null
    }, 
    {
        "P_WAIT (os)": "P_WAIT = 0"
    }, 
    {
        "pivot() (Axis_Knob)": "pivot(self)\n      Return pivot knob."
    }, 
    {
        "PresetsLoadPanel (nukescripts.nodepresets)": null
    }, 
    {
        "pad() (Box)": "pad(self,\n        dx,\n        dy,\n        dr,\n        dt)\n      Move all the sides and thus the entire box by the given deltas."
    }, 
    {
        "pivotPoint (CTransform)": "pivotPoint\n      The location of the pivot point, represented as a CVec3 object."
    }, 
    {
        "prev_inrange (nukescripts.flip)": "prev_inrange = ''"
    }, 
    {
        "pixelAspect() (Format)": "pixelAspect(self)\n      Returns the pixel aspect ratio (pixel width divided by pixel height) \n      for this format."
    }, 
    {
        "prev_userrange (nukescripts.flip)": "prev_userrange = ''"
    }, 
    {
        "pan() (nuke)": "pan()\n\n\u00a0\n    \n\nReturn the pan values of a group's display. This function is \n  deprecated and will be removed in a future version.  You probably want to\n  use nuke.center().\nn = nuke.pan() print n[0] print n[1]\n\nReturns: array with x, then y\nArray of x, y."
    }, 
    {
        "pixelAspect() (Node)": "pixelAspect(self)\n\n\u00a0\n    \n\nPixel Aspect ratio of the node.\n\nReturns: int\nfloat."
    }, 
    {
        "previousView() (ViewerWindow)": "previousView(self)"
    }, 
    {
        "Panel (nuke)": null
    }, 
    {
        "planeRotation() (nukescripts.snap3d)": "planeRotation(tri,\n        norm=None)\n\nsource\u00a0code\u00a0\n    \n\nCalculate the rotations around the X, Y and Z axes that will align a \n  plane perpendicular to the Z axis with the given triangle.\n\nParameters:\n\ntri - A list or tuple of 3 _nukemath.Vector3 objects. The 3 points must\n          describe the plane (i.e. they must not be collinear).\n\nReturns:\nA _nukemath.Vector3 object where the x coordinate is the angle of\n          rotation around the x axis and so on.\nRaises:\n\nValueError - if the three points are collinear."
    }, 
    {
        "print_callback_info() (nukescripts.misc)": "print_callback_info(verbose=False,\n        callbackTypes=None)\n      Returns a list of all currently active callbacks, with the following \n      optional arguments:\n\nsource\u00a0code"
    }, 
    {
        "panel_example() (nukescripts.panel_test)": null
    }, 
    {
        "platform (sys)": "platform = 'linux2'"
    }, 
    {
        "processPresetFile() (nukescripts.nodepresets)": null
    }, 
    {
        "panel_test (nukescripts)": null
    }, 
    {
        "play() (ViewerWindow)": "play(...)\n      Play forward (1) or reverse (0)."
    }, 
    {
        "ProgressTask (nuke)": null
    }, 
    {
        "PanelNode (nuke)": null
    }, 
    {
        "playbackRange() (Viewer)": "playbackRange(self)\n      Return the frame range that's currently set to be played back in the \n      viewer.@return: FrameRange."
    }, 
    {
        "projectPoint() (nukescripts.snap3d)": "projectPoint(camera=None,\n        point=None)\n\nsource\u00a0code\u00a0\n    \n\nProject the given 3D point through the camera to get 2D pixel \n  coordinates.\n\nParameters:\n\ncamera - The Camera node or name of the Camera node to use for projecting \n          the point.\npoint - A nuke.math.Vector3 or of list/tuple of three float values \n          representing the 3D point.\n\nReturns: nuke.math.Vector2\nRaises:\n\nValueError - If camera or point is invalid."
    }, 
    {
        "panels (nukescripts)": null
    }, 
    {
        "PLUGIN_EXT (nuke)": "PLUGIN_EXT = 'so'"
    }, 
    {
        "projectPoints() (nukescripts.snap3d)": "projectPoints(camera=None,\n        points=None)\n\nsource\u00a0code\u00a0\n    \n\nProject the given 3D point through the camera to get 2D pixel \n  coordinates.\n\nParameters:\n\ncamera - The Camera node or name of the Camera node to use for projecting \n          the point.\npoints - A list or tuple of either nuke.math.Vector3 or of list/tuples of \n          three float values representing the 3D points.\n\nReturns: list of nuke.math.Vector2\nRaises:\n\nValueError - If camera or point is invalid."
    }, 
    {
        "pardir (os)": "pardir = '..'"
    }, 
    {
        "plugin_menu (nukescripts)": null
    }, 
    {
        "projectSelectedPoints() (nukescripts.snap3d)": "projectSelectedPoints(cameraName='Camera1')\n\nsource\u00a0code\u00a0\n    \n\nUsing the specified camera, project all of the selected points into 2D\n  pixel coordinates and return their locations.\n\nParameters:\n\ncameraName - Optional name of the Camera node to use for projecting the \n          points. If omitted, will look for a node called Camera1.\n\nReturns: iterator yielding nuke.math.Vector2"
    }, 
    {
        "pardir (posixpath)": "pardir = '..'"
    }, 
    {
        "pluginAddPath() (nuke.overrides)": "pluginAddPath(args,\n        addToSysPath=True)\n\nsource\u00a0code\u00a0\n    \n\nAdds all the paths to the beginning of the Nuke plugin path. If the \n  path already exists in the list of plugin paths, it is moved to the \n  start. If this command is executed inside an init.py then the init.py in \n  the path will be executed. It also adds the paths to the sys.path, if \n  addToSysPath is True."
    }, 
    {
        "proxy() (Node)": "proxy(self)\n\n\u00a0\n    \n\n\nReturns: bool\nTrue if proxy is enabled, False otherwise."
    }, 
    {
        "parent() (XYZ_Knob)": "parent()\n      Return parent."
    }, 
    {
        "pluginAppendPath() (nuke.overrides)": "pluginAppendPath(args,\n        addToSysPath=True)\n\nsource\u00a0code\u00a0\n    \n\nAdd a filepath to the end of the Nuke plugin path.  If the path \n  already exists in the list of plugin paths, it will remain at its current\n  position. It also appends the paths to the sys.path, if addToSysPath is \n  True."
    }, 
    {
        "proxy() (Root)": "proxy(self)\n\n\u00a0\n    \n\n\nReturns: True if proxy is set, False otherwise\nTrue if proxy is set, False otherwise.\nOverrides:\n        Node.proxy"
    }, 
    {
        "parseUdimFile() (nukescripts.udim)": "parseUdimFile(f)\n\nsource\u00a0code\u00a0\n    \n\nParsing a filename string in search of the udim number. The function \n  returns the udim number, and None if it is not able to decode the udim \n  value.\nThe udim value is a unique number that defines the tile coordinate. If\n  u,v are the real tile coordinates the equivalent udim number is \n  calculated with the following formula: udim = 1001 + u + 10 * v    (Note:\n  u >=0 && u < 10 && udim > 1000 && udim \n  < 2000)\nRedefine this function if the parsing function is not appropriate with\n  your filename syntax."
    }, 
    {
        "pluginExists() (nuke)": "pluginExists(name)\n\n\u00a0\n    \n\nThis function is the same as load(), but only checks for the existence\n  of a plugin rather than loading it. If there is no slash in the name then\n  the pluginPath() is searched for it. If there is a slash then the name is\n  used directly as a filename, if it does not start with a slash the name \n  is relative to the directory containing any plugin being currently \n  loaded. If no filename extension is provided, it will try appending '.so'\n  (or whatever your OS dynamic library extension is) and finding nothing \n  will also try to append '.tcl' and '.py'.\n\nParameters:\n\nname - Plugin name or filename.\n\nReturns: True if found, or False if not\nTrue if found, or False if not."
    }, 
    {
        "psd (nukescripts)": null
    }, 
    {
        "Password_Knob (nuke)": null
    }, 
    {
        "pluginInstallLocation() (nuke)": "pluginInstallLocation()\n\n\u00a0\n    \n\nThe system-specific locations that Nuke will look in for third-party \n  plugins.\n\nReturns: string list\nList of paths."
    }, 
    {
        "Pulldown_Knob (nuke)": null
    }, 
    {
        "path (sys)": "path\n\n\n\nValue:\n\n[u'/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-relea\nse-410/Bundle/plugins',\n '/workspace/peter/7.0dev_3/Thirdparty/EPyDoc/3.0.1/bin',\n '/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-releas\ne-410/Bundle/plugins',\n '/workspace/peter/7.0dev_3/Resources/Apps/Nuke/Docs/src',\n '/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-releas\ne-410/Bundle/lib/python26.zip',\n..."
    }, 
    {
        "pluginPath() (nuke)": "pluginPath()\n\n\u00a0\n    \n\nList all the directories Nuke will search in for plugins.\nThe built-in default is ~/.nuke and the 'plugins' directory from the \n  same location the NUKE executable file is in. Setting the environment \n  variable $NUKE_PATH to a colon-separated list of directories will replace\n  the ~/.nuke with your own set of directories, but the plugins directory \n  is always on the end.\n\nReturns: string list\nList of paths."
    }, 
    {
        "py3kwarning (sys)": "py3kwarning = False"
    }, 
    {
        "path() (FlipbookApplication)": "path(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the executable path required to run a flipbook.\n\nReturns:\nString"
    }, 
    {
        "plugins() (nuke)": "plugins(switches=0,\n        *pattern)\n\n\u00a0\n    \n\n\nReturns a list of every loaded plugin or every plugin available. By default each plugin is returned as the full pathname of the plugin file.\n\nYou can give a glob-style matching pattern and only the plugins whose filenames (not path) match the pattern will be returned. You can give more than one glob pattern if desired.\n\nYou can also put options before the glob patterns. Currently supported:\n\n  ALL    Return all plugins in each of the plugin_path() directories,\n         rather than only the currently loaded plugins.\n\n  NODIR  Just put the filenames in the list, not the full path. There\n         may be duplicates.\n\nIf you don't specify any switches, the default behaviour is to return a list\nwith the full paths of all loaded plugins.\n\n@param switches: Optional parameter. Bitwise OR of nuke.ALL, nuke.NODIR.\n@param pattern: Zero or more glob patterns.\n@return: List of plugins.\n\n\n\nReturns: list of str"
    }, 
    {
        "path() (FramecyclerFlipbook)": "path(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the executable path required to run a flipbook.\n\nReturns:\nString\nOverrides:\n        flipbooking.FlipbookApplication.path\n(inherited documentation)"
    }, 
    {
        "points() (VertexSelection)": null
    }, 
    {
        "pyAppUtils (nukescripts)": null
    }, 
    {
        "path() (ExampleRVFlipbook)": "path(self)\n\nsource\u00a0code\u00a0\n    \n\nReturn the executable path required to run a flipbook.\n\nReturns:\nString\nOverrides:\n        flipbooking.FlipbookApplication.path\n(inherited documentation)"
    }, 
    {
        "populatePresetsMenu() (nukescripts.nodepresets)": null
    }, 
    {
        "PyCustom_Knob (nuke)": null
    }, 
    {
        "path_hooks (sys)": "path_hooks = [<type 'zipimport.zipimporter'>]"
    }, 
    {
        "populateToolsetsMenu() (nukescripts.toolsets)": null
    }, 
    {
        "pyQtAppHelper (nukescripts.pyQtAppUtils)": null
    }, 
    {
        "path_importer_cache (sys)": "path_importer_cache\n\n\n\nValue:\n\n{'': None,\n '/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-releas\ne-410/Bundle/lib/python2.6': None,\n '/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-releas\ne-410/Bundle/lib/python2.6/': None,\n '/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-releas\ne-410/Bundle/lib/python2.6/ctypes': None,\n '/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-releas\n..."
    }, 
    {
        "PORT (nukescripts.clientserver)": null
    }, 
    {
        "pyQtAppUtils (nukescripts)": null
    }, 
    {
        "pathconf_names (os)": "pathconf_names\n\n\n\nValue:\n\n{'PC_ASYNC_IO': 10,\n 'PC_CHOWN_RESTRICTED': 6,\n 'PC_FILESIZEBITS': 13,\n 'PC_LINK_MAX': 0,\n 'PC_MAX_CANON': 1,\n 'PC_MAX_INPUT': 2,\n 'PC_NAME_MAX': 3,\n 'PC_NO_TRUNC': 7,\n..."
    }, 
    {
        "position (ControlPoint)": "position\n      The position of the control point."
    }, 
    {
        "pyQtExamples (nukescripts)": null
    }, 
    {
        "pathsep (os)": "pathsep = ':'"
    }, 
    {
        "pyQtRender (nukescripts.pyQtExamples)": null
    }, 
    {
        "pathsep (posixpath)": "pathsep = ':'"
    }, 
    {
        "Precomp (nuke)": null
    }, 
    {
        "pyQtRender2 (nukescripts.pyQtExamples)": null
    }, 
    {
        "PdmDepth (PaintDeviceMetric)": "values\n\n\n\nValue:\n\n{'PdmDepth': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDepth,\n 'PdmDpiX': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiX,\n 'PdmDpiY': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiY,\n 'PdmHeight': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeight,\n 'PdmHeightMM': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeightM\nM,\n 'PdmNumColors': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmNumCol\nors,\n..."
    }, 
    {
        "precomp (nukescripts)": null
    }, 
    {
        "pyQtRenderDialog (nukescripts.pyQtExamples.pyQtRender2)": null
    }, 
    {
        "PdmDpiX (PaintDeviceMetric)": "values\n\n\n\nValue:\n\n{'PdmDepth': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDepth,\n 'PdmDpiX': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiX,\n 'PdmDpiY': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiY,\n 'PdmHeight': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeight,\n 'PdmHeightMM': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeightM\nM,\n 'PdmNumColors': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmNumCol\nors,\n..."
    }, 
    {
        "precomp_copyToGroup() (nukescripts.precomp)": null
    }, 
    {
        "PyScript_Knob (nuke)": null
    }, 
    {
        "PdmDpiY (PaintDeviceMetric)": "values\n\n\n\nValue:\n\n{'PdmDepth': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDepth,\n 'PdmDpiX': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiX,\n 'PdmDpiY': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiY,\n 'PdmHeight': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeight,\n 'PdmHeightMM': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeightM\nM,\n 'PdmNumColors': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmNumCol\nors,\n..."
    }, 
    {
        "precomp_open() (nukescripts.precomp)": null
    }, 
    {
        "PYTHON (nuke)": "PYTHON = 32"
    }, 
    {
        "PdmHeight (PaintDeviceMetric)": "values\n\n\n\nValue:\n\n{'PdmDepth': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDepth,\n 'PdmDpiX': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiX,\n 'PdmDpiY': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiY,\n 'PdmHeight': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeight,\n 'PdmHeightMM': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeightM\nM,\n 'PdmNumColors': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmNumCol\nors,\n..."
    }, 
    {
        "precomp_render() (nukescripts.precomp)": null
    }, 
    {
        "PythonCustomKnob (nuke)": null
    }, 
    {
        "PdmHeightMM (PaintDeviceMetric)": "PdmHeightMM\n\n\n\nValue:\n\nPySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeightMM"
    }, 
    {
        "precomp_selected() (nukescripts.precomp)": null
    }, 
    {
        "PythonKnob (nuke)": null
    }, 
    {
        "PdmNumColors (PaintDeviceMetric)": "PdmNumColors\n\n\n\nValue:\n\nPySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmNumColors"
    }, 
    {
        "PrecompOptions (nukescripts.precomp)": null
    }, 
    {
        "PdmPhysicalDpiX (PaintDeviceMetric)": "PdmPhysicalDpiX\n\n\n\nValue:\n\nPySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmPhysicalDpiX"
    }, 
    {
        "PrecompOptionsDialog (nukescripts.precomp)": null
    }, 
    {
        "pyWxAppHelper (nukescripts.pyWxAppUtils)": null
    }, 
    {
        "PdmPhysicalDpiY (PaintDeviceMetric)": "PdmPhysicalDpiY\n\n\n\nValue:\n\nPySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmPhysicalDpiY"
    }, 
    {
        "prefix (sys)": "prefix\n\n\n\nValue:\n\n'/workspace/peter/7.0dev_3/Apps/Nuke/nuke/objects/linux-64-x86-release\n-410/Bundle'"
    }, 
    {
        "pyWxAppUtils (nukescripts)": null
    }, 
    {
        "qApp (nukescripts)": "qApp = <PySide.QtCore.QCoreApplication object at 0x7f9c4cb23e18>"
    }, 
    {
        "QtFatalMsg (nukescripts)": "QtFatalMsg = PySide.QtCore.QtMsgType.QtFatalMsg"
    }, 
    {
        "qApp (nukescripts.udim)": "qApp = <PySide.QtCore.QCoreApplication object at 0x7f9c4cb23e18>"
    }, 
    {
        "QtFatalMsg (nukescripts.udim)": "QtFatalMsg = PySide.QtCore.QtMsgType.QtFatalMsg"
    }, 
    {
        "quickRestore() (nukescripts.bookmarks)": null
    }, 
    {
        "QtCriticalMsg (nukescripts)": "QtCriticalMsg = PySide.QtCore.QtMsgType.QtCriticalMsg"
    }, 
    {
        "QtSystemMsg (nukescripts)": "QtSystemMsg = PySide.QtCore.QtMsgType.QtSystemMsg"
    }, 
    {
        "quickSave() (nukescripts.bookmarks)": null
    }, 
    {
        "QtCriticalMsg (nukescripts.udim)": "QtCriticalMsg = PySide.QtCore.QtMsgType.QtCriticalMsg"
    }, 
    {
        "QtSystemMsg (nukescripts.udim)": "QtSystemMsg = PySide.QtCore.QtMsgType.QtSystemMsg"
    }, 
    {
        "quickSaves (nukescripts.bookmarks)": null
    }, 
    {
        "QtDebugMsg (nukescripts)": "QtDebugMsg = PySide.QtCore.QtMsgType.QtDebugMsg"
    }, 
    {
        "QtWarningMsg (nukescripts)": "QtWarningMsg = PySide.QtCore.QtMsgType.QtWarningMsg"
    }, 
    {
        "QtDebugMsg (nukescripts.udim)": "QtDebugMsg = PySide.QtCore.QtMsgType.QtDebugMsg"
    }, 
    {
        "QtWarningMsg (nukescripts.udim)": "QtWarningMsg = PySide.QtCore.QtMsgType.QtWarningMsg"
    }, 
    {
        "r() (BBox_Knob)": null
    }, 
    {
        "removeAutoSaveDeleteFilter() (nuke.callbacks)": "removeAutoSaveDeleteFilter(filter)\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "replayMouse() (Viewer)": "replayMouse(f)\n      Determine whether frame /f/ is known to be in the memory cache."
    }, 
    {
        "r() (Box)": null
    }, 
    {
        "removeAutoSaveFilter() (nuke.callbacks)": "removeAutoSaveFilter(filter)\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "request() (RunInMainThread)": null
    }, 
    {
        "r() (Box3_Knob)": "r(...)\n\n\u00a0\n    \n\nReturn value for R extent. R (right) is the right extent of the \n  box."
    }, 
    {
        "removeAutoSaveRestoreFilter() (nuke.callbacks)": "removeAutoSaveRestoreFilter(filter)\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "reset() (AnimAttributes)": "reset(self)\n      Reset the object to have no attributes."
    }, 
    {
        "r() (Format)": null
    }, 
    {
        "removeBeforeBackgroundRender() (nuke.callbacks)": "removeBeforeBackgroundRender(call,\n        args=(),\n        kwargs={})\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "reset() (AnimCTransform)": "reset(self)"
    }, 
    {
        "R_OK (os)": "R_OK = 4"
    }, 
    {
        "removeBeforeFrameRender() (nuke.callbacks)": "removeBeforeFrameRender(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "reset() (AnimControlPoint)": "reset(self)\n      Resets the control point back to an initial empty state."
    }, 
    {
        "ra (AnimCurveKey)": "ra\n      The right bicubic value for this key."
    }, 
    {
        "removeBeforeRender() (nuke.callbacks)": "removeBeforeRender(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "reset() (AnimCurve)": "reset(self)\n      Reset this object to its default values."
    }, 
    {
        "ra (AnimationKey)": "ra\n      The right 'bicubic' value"
    }, 
    {
        "removeCallback() (PythonPanel)": "removeCallback(self)"
    }, 
    {
        "reset() (AnimCurveKey)": "reset(self)\n      Reset this key to its default values."
    }, 
    {
        "Range_Knob (nuke)": null
    }, 
    {
        "removeFavoriteDir() (nuke)": "removeFavoriteDir(name,\n        type)\n\n\u00a0\n    \n\nRemove a directory path from the favorites list.\n\nParameters:\n\nname - Favourite path entry ('Home', 'Desktop', etc.).\ntype - Optional bitwise OR combination of nuke.IMAGE, nuke.SCRIPT, \n          nuke.FONT or nuke.GEO.\n\nReturns: None\nNone"
    }, 
    {
        "reset() (CTransform)": "reset(self)\n      Return this transform to its default settings."
    }, 
    {
        "rawArgs (nuke)": "rawArgs\n\n\n\nValue:\n\n['Apps/Nuke/nuke/objects/linux-64-x86-release-410/Bundle/Nuke7.0',\n '-t',\n 'Resources/Apps/Nuke/Docs/src/nuke_epydoc.py',\n '/workspace/peter/7.0dev_3/Thirdparty/EPyDoc/3.0.1/bin',\n '--config',\n 'Resources/Apps/Nuke/Docs/src/nuke_epydoc.cfg',\n '-o',\n '/tmp/tmpCZJ9PX',\n..."
    }, 
    {
        "removeFilenameFilter() (nuke.callbacks)": "removeFilenameFilter(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "reset() (ControlPoint)": "reset(self)"
    }, 
    {
        "removeFilenameValidate() (nuke.callbacks)": "removeFilenameValidate(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n      Remove a previously-added callback.\n\nsource\u00a0code"
    }, 
    {
        "reset() (CorrespondencePoints)": "reset(...)\n      cps->reset() Resets the correspondence points object to empty"
    }, 
    {
        "READ_ONLY (nuke)": "READ_ONLY = 268435456"
    }, 
    {
        "removeItem() (Menu)": "removeItem(self,\n        name)\n\n\u00a0\n    \n\nRemoves a submenu or command with a particular name. If the containing\n  menu becomes empty, it will be removed too.\n\nParameters:\n\nname - The name to remove for.\n\nReturns: None\ntrue if removed, false if menu not found"
    }, 
    {
        "resetKnobsToDefault() (Node)": "resetKnobsToDefault(self)\n      Reset all the knobs to their default values."
    }, 
    {
        "readKnobs() (Node)": "readKnobs(self,\n        s)\n\n\u00a0\n    \n\nRead the knobs from a string (TCL syntax).\n\nParameters:\n\ns - A string.\n\nReturns: None\nNone."
    }, 
    {
        "removeItem() (MenuBar)": "removeItem(self,\n        name)\n\n\u00a0\n    \n\nRemoves a submenu or command with a particular name. If the containing\n  menu becomes empty, it will be removed too.\n\nParameters:\n\nname - The name to remove for.\n\nReturns: None\ntrue if removed, false if menu not found"
    }, 
    {
        "resetPerformanceTimers() (nuke)": "resetPerformanceTimers()\n      Clears the accumulated time on the performance timers."
    }, 
    {
        "readKnobs() (PanelNode)": "readKnobs(self,\n        s)\n\n\u00a0\n    \n\nRead the knobs from a string (TCL syntax).\n\nParameters:\n\ns - A string.\n\nReturns: None\nNone."
    }, 
    {
        "removeItem() (ToolBar)": "removeItem(self,\n        name)\n\n\u00a0\n    \n\nRemoves a submenu or command with a particular name. If the containing\n  menu becomes empty, it will be removed too.\n\nParameters:\n\nname - The name to remove for.\n\nReturns: None\ntrue if removed, false if menu not found"
    }, 
    {
        "resize() (Array_Knob)": "resize(self,\n        w,\n        h)\n\n\u00a0\n    \n\nResize the array.\n\nParameters:\n\nw - New width\nh - Optional new height\n\nReturns: True if successful, False otherwise\nTrue if successful, False otherwise."
    }, 
    {
        "readKnobs() (PythonPanel)": "readKnobs(self,\n        s)"
    }, 
    {
        "removeItems() (SceneView_Knob)": "removeItems(self)\n      Removes a list of string items from the knob."
    }, 
    {
        "restoreWindowLayout() (nuke)": "restoreWindowLayout(i)\n\n\u00a0\n    \n\nRestores a saved window layout.\n\nParameters:\n\ni - Layout number\n\nReturns: None\nNone"
    }, 
    {
        "reads (nukescripts)": null
    }, 
    {
        "removeKey() (AnimAttributes)": "removeKey(self,\n        time,\n        attributeIndex,\n        view)\n\n\u00a0\n    \n\nRemove a particular key from an attribute. The view parameter is \n  optional.\n\nReturns: None"
    }, 
    {
        "result() (RunInMainThread)": null
    }, 
    {
        "realFps() (Root)": "realFps(self)\n      The global frames per second setting."
    }, 
    {
        "removeKey() (AnimControlPoint)": "removeKey(self,\n        time,\n        view)"
    }, 
    {
        "RevertModelCache (EndEditHint)": "RevertModelCache\n\n\n\nValue:\n\nPySide.QtGui.QAbstractItemDelegate.EndEditHint.RevertModelCache"
    }, 
    {
        "recentFile() (nuke)": "recentFile(index)\n\n\u00a0\n    \n\nReturns a filename from the recent-files list.\n\nParameters:\n\nindex - A position in the recent files list. This must be a non-negative \n          number.\n\nReturns: str\nA file path.\nRaises:\n\nValueError - if the index is negative.\nRuntimeError - if there is no entry in the recent files list for the specified \n        index."
    }, 
    {
        "removeKey() (AnimCurve)": "removeKey(self,\n        timeOrHash)\n\n\u00a0\n    \n\nRemove an existing key from this curve. The key is identified by \n  either the time it occurs at, or its hash (as returned by the key's \n  getHash() method.\n\nReturns: None"
    }, 
    {
        "rgbColorChip (nukescripts.panel_test)": null
    }, 
    {
        "recordMouse() (Viewer)": "recordMouse(f)\n      Determine whether frame /f/ is known to be in the memory cache."
    }, 
    {
        "removeKey() (AnimationCurve)": "removeKey(self,\n        keys)\n\n\u00a0\n    \n\nRemove some keys from the curve.\n\nParameters:\n\nkeys - The sequence of keys to be removed.\n\nReturns: None\nNone."
    }, 
    {
        "rightTangent (ShapeControlPoint)": "rightTangent\n      The right tangent offsets, relative to the center point."
    }, 
    {
        "recordMouseStop() (Viewer)": "recordMouseStop(f)\n      Stops mouse recording."
    }, 
    {
        "removeKey() (Array_Knob)": "removeKey(self,\n        index,\n        view)\n\n\u00a0\n    \n\nRemove key.\n\nParameters:\n\nindex - Optional index.\nview - Optional view.\n\nReturns: True if succeeded, False otherwise\nTrue if succeeded, False otherwise.\nOverrides:\n        Knob.removeKey"
    }, 
    {
        "roi() (Viewer)": "roi(self)\n\n\u00a0\n    \n\nRegion of interest set in the viewer in pixel space coordinates. \n  Returns None if the Viewer has no window yet.\n\nReturns: dict\nDict with keys x, y, r and t or None."
    }, 
    {
        "redo() (Undo)": "redo(...)\n      Redoes 0'th redo."
    }, 
    {
        "removeKey() (Knob)": "removeKey(...)\n\n\u00a0\n    \n\nRemove key for channel 'c'. Return True if successful."
    }, 
    {
        "roiEnabled() (Viewer)": "roiEnabled(self)\n\n\u00a0\n    \n\nWhether the viewing of just a region of interest is enabled. Returns \n  None if the Viewer has no window yet.\n\nReturns: bool\nBoolean or None."
    }, 
    {
        "redo() (nuke)": "redo()\n\n\u00a0\n    \n\nPerform the most recent redo.\n\nReturns: None\nNone"
    }, 
    {
        "removeKeyAt() (Array_Knob)": "removeKeyAt(self,\n        time,\n        index,\n        view)\n\n\u00a0\n    \n\nRemove keyframe at specified time, optional index and view. Return \n  True if successful.\n\nParameters:\n\ntime - Time.\nindex - Optional index.\nview - Optional view.\n\nReturns: True if succeeded, False otherwise\nTrue if succeeded, False otherwise.\nOverrides:\n        Knob.removeKeyAt"
    }, 
    {
        "rollingAutoSave (nukescripts)": null
    }, 
    {
        "redoDescribe() (Undo)": "redoDescribe(...)\n      Return short description of redo n."
    }, 
    {
        "removeKeyAt() (Knob)": "removeKeyAt(...)\n\n\u00a0\n    \n\nRemove key at time 't' for channel 'c'. Return True if successful."
    }, 
    {
        "Root (nuke)": null
    }, 
    {
        "redoDescribeFully() (Undo)": "redoDescribeFully(...)\n      Return long description of redo n."
    }, 
    {
        "removeKeys() (AnimAttributes)": "removeKeys(self,\n        attributeIndex,\n        view)\n\n\u00a0\n    \n\nRemove all keys from an attribute. The view parameter is optional.\n\nReturns: None"
    }, 
    {
        "root() (nuke)": "root()\n\n\u00a0\n    \n\nGet the DAG's root node. Always succeeds.\n\nReturns: node\nThe root node. This will never be None."
    }, 
    {
        "redoSize() (Undo)": "redoSize(...)\n      Number of redo's that can be done."
    }, 
    {
        "removeKnob() (Node)": "removeKnob(self,\n        k)\n\n\u00a0\n    \n\nRemove knob k from this node or panel. Throws a ValueError exception \n  if k is not found on the node.\n\nParameters:\n\nk - Knob.\n\nReturns: None\nNone."
    }, 
    {
        "rootLayer (CurveKnob)": "rootLayer\n      The root layer."
    }, 
    {
        "redoTruncate() (Undo)": "redoTruncate(...)\n      Destroy any redo's greater or equal to n."
    }, 
    {
        "removeKnob() (PanelNode)": "removeKnob(self,\n        k)\n\n\u00a0\n    \n\nRemove knob k from this node or panel. Throws a ValueError exception \n  if k is not found on the node.\n\nParameters:\n\nk - Knob.\n\nReturns: None\nNone."
    }, 
    {
        "rotate() (Axis_Knob)": "rotate(self)\n      Return rotation knob."
    }, 
    {
        "redraw() (Node)": "redraw(self)\n\n\u00a0\n    \n\nForce a redraw of the node.\n\nReturns: None\nNone."
    }, 
    {
        "removeKnob() (PythonPanel)": "removeKnob(self,\n        knob)"
    }, 
    {
        "rotateToPointsVerified() (nukescripts.snap3d)": "rotateToPointsVerified(nodeToSnap,\n        vertexSelection)\n\nsource\u00a0code"
    }, 
    {
        "refreshToolsetsMenu() (nukescripts.toolsets)": null
    }, 
    {
        "removeKnobChanged() (nuke.callbacks)": "removeKnobChanged(call,\n        args=(),\n        kwargs={},\n        nodeClass='*',\n        node=None)\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "rotateX() (CMatrix4)": "rotateX(self,\n        angleInRadians)\n      Post-multiply this matrix by a rotation around the X axis."
    }, 
    {
        "register() (ViewerProcess)": "register(...)\n\n\u00a0\n    \n\nnuke.ViewerProcess.register(name, call, args, kwargs) -> None. \n  Register a ViewerProcess. This is a class method.\n\nParameters:\n\nname - Menu name.\ncall - Python callable. Must return a Node.\nargs - Arguments to call.\nkwargs - Optional named arguments.\n\nReturns:\nNone."
    }, 
    {
        "removeOnCreate() (nuke.callbacks)": "removeOnCreate(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "rotateY() (CMatrix4)": "rotateY(self,\n        angleInRadians)\n      Post-multiply this matrix by a rotation around the Y axis."
    }, 
    {
        "register() (FlipbookFactory)": "register(self,\n        flipbookApplication)\n\nsource\u00a0code\u00a0\n    \n\nRegister a flipbook app. It will fail if the flipbook app name isn't \n  unique.\n\nParameters:\n\nflipbook - FlipBookApplication object to register\n\nReturns:\nNone"
    }, 
    {
        "removeOnDestroy() (nuke.callbacks)": "removeOnDestroy(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "rotateZ() (CMatrix4)": "rotateZ(self,\n        angleInRadians)\n      Post-multiply this matrix by a rotation around the Z axis."
    }, 
    {
        "register() (nukescripts.flipbooking)": "register(flipbookApplication)\n\nsource\u00a0code\u00a0\n    \n\nRegister a flipbook. Convenience function that simple calls register()\n  on the FlipbookFactory."
    }, 
    {
        "removeOnScriptClose() (nuke.callbacks)": "removeOnScriptClose(call,\n        args=(),\n        kwargs={},\n        nodeClass='Root')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "rotation (CTransform)": "rotation\n      The rotation amounts, represented as a CVec3 object."
    }, 
    {
        "register_default_viewer_processes() (nukescripts.ViewerProcess)": null
    }, 
    {
        "removeOnScriptLoad() (nuke.callbacks)": "removeOnScriptLoad(call,\n        args=(),\n        kwargs={},\n        nodeClass='Root')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "rotationOrder (AnimCTransform)": "rotationOrder\n      The order in which to perform rotations around the axes."
    }, 
    {
        "register_viewers() (nukescripts.ViewerProcess)": null
    }, 
    {
        "removeOnScriptSave() (nuke.callbacks)": "removeOnScriptSave(call,\n        args=(),\n        kwargs={},\n        nodeClass='Root')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "rotationOrder (CTransform)": "rotationOrder\nIndicates which order to apply the rotations in. The value will be one\n  of the constants from the RotationOrder class."
    }, 
    {
        "registeredNames() (ViewerProcess)": "registeredNames(...)\n\n\u00a0\n    \n\nnuke.ViewerProcess.registeredNames() -> List. Returns a list \n  containing the names of all currently regisered ViewerProcesses.\n\nReturns:\nList."
    }, 
    {
        "removeOnUserCreate() (nuke.callbacks)": "removeOnUserCreate(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "RotationOrder (_curvelib)": null
    }, 
    {
        "registerLUTPath() (nukescripts.flipbooking)": "registerLUTPath(flipbookApplication,\n        lut,\n        path)\n\nsource\u00a0code\u00a0\n    \n\nRegister a LUT for a specific flipbook. The path should refer to a \n  file that contains the LUT for the given flipbook identified by the name \n  in flipbookApplication. It is up to the flipbook subimplementation to \n  actually use this file and the format may vary.\n\nParameters:\n\nflipbook - The unique name of the flipbook\nlut - The unique name for the LUT, e.g. 'sRGB' and 'rec709'\npath - Location of the flipbook specific file."
    }, 
    {
        "removePivotPointKey() (AnimCTransform)": "removePivotPointKey(self,\n        time,\n        view)"
    }, 
    {
        "RotoKnob (_rotopaint)": null
    }, 
    {
        "registerLUTPathForFlipbook() (FlipbookLUTPathRegistry)": "registerLUTPathForFlipbook(self,\n        flipbook,\n        lut,\n        path)\n\nsource\u00a0code\u00a0\n    \n\nRegister the given LUT file.\n\nParameters:\n\nflipbook - The unique name of the flipbook\nlut - The unique name for the LUT, e.g. 'sRGB' and 'rec709'\npath - Location of the flipbook specific file."
    }, 
    {
        "removePoint() (CorrespondencePoints)": "removePoint(cps,\n        index)\n\n\u00a0\n    \n\n\nParameters:\n\nindex - Index to the point to remove"
    }, 
    {
        "rotopaint (nuke)": null
    }, 
    {
        "reject() (PythonPanel)": "reject(self)"
    }, 
    {
        "removePositionKey() (AnimControlPoint)": "removePositionKey(self,\n        time,\n        view)"
    }, 
    {
        "rslope (AnimCurveKey)": "rslope\n      The right derivative for this key."
    }, 
    {
        "Rejected (DialogCode)": "values\n\n\n\nValue:\n\n{'Accepted': PySide.QtGui.QDialog.DialogCode.Accepted,\n 'Rejected': PySide.QtGui.QDialog.DialogCode.Rejected}"
    }, 
    {
        "removeRotationKey() (AnimCTransform)": "removeRotationKey(self,\n        time,\n        view)"
    }, 
    {
        "rslope (AnimationKey)": "rslope\n      The derivative to the right of the point"
    }, 
    {
        "reload() (Precomp)": "reload(self)\n\n\u00a0\n    \n\nPrecomp Node reload()\n\nReturns: None\nNone"
    }, 
    {
        "removeScaleKey() (AnimCTransform)": "removeScaleKey(self,\n        time,\n        view)"
    }, 
    {
        "run() (Group)": "run(self,\n        callable)\n\n\u00a0\n    \n\nExecute in the context of node. All names are evaluated relative to \n  this object.\n\nParameters:\n\ncallable - callable to execute.\n\nReturns: Result of callable\nResult of callable."
    }, 
    {
        "remove() (CurveWidget)": "remove(self)\n      Remove the selected items in the CurveTreeList"
    }, 
    {
        "removeSkewXKey() (AnimCTransform)": "removeSkewXKey(self,\n        time,\n        view)"
    }, 
    {
        "run() (FlipbookApplication)": "run(self,\n        path,\n        frameRanges,\n        views,\n        options)\n\nsource\u00a0code\u00a0\n    \n\nExecute the flipbook on a path.\n\nParameters:\n\npath - The path to run the flipbook on. This will be similar to \n          /path/to/foo%03d.exr\nframeRanges - A FrameRanges object representing the range that should be \n          flipbooked. Note that in 6.2v1-2 this was a FrameRange object.\nviews - A list of strings comprising of the views to flipbook. Willnot be\n          more than the maximum supported by the flipbook.\noptions - A dictionary of options to use. This may contain the keys \n          pixelAspect, roi, dimensions, audio and lut. These contain a \n          float, a dict with bounding box dimensions, a dict with width and\n          height, a path to audio file and a string indicating the LUT \n          conversion to apply.\n\nReturns:\nNone"
    }, 
    {
        "remove() (Layer)": "remove(self,\n        index)\n\n\u00a0\n    \n\nRemove the element at the given index from this layer. If the index is\n  out of bounds, an IndexError will be raised.\n\nReturns: None"
    }, 
    {
        "removeTransformKey() (AnimCTransform)": "removeTransformKey(self,\n        time,\n        view)"
    }, 
    {
        "run() (FramecyclerFlipbook)": "run(self,\n        filename,\n        frameRanges,\n        views,\n        options)\n\nsource\u00a0code\u00a0\n    \n\nExecute the flipbook on a path.\n\nParameters:\n\npath - The path to run the flipbook on. This will be similar to \n          /path/to/foo%03d.exr\nframeRanges - A FrameRanges object representing the range that should be \n          flipbooked. Note that in 6.2v1-2 this was a FrameRange object.\nviews - A list of strings comprising of the views to flipbook. Willnot be\n          more than the maximum supported by the flipbook.\noptions - A dictionary of options to use. This may contain the keys \n          pixelAspect, roi, dimensions, audio and lut. These contain a \n          float, a dict with bounding box dimensions, a dict with width and\n          height, a path to audio file and a string indicating the LUT \n          conversion to apply.\n\nReturns:\nNone\nOverrides:\n        flipbooking.FlipbookApplication.run\n(inherited documentation)"
    }, 
    {
        "remove() (Shape)": "remove(self,\n        index)\n\n\u00a0\n    \n\nRemove the control point at the given index. This removes any \n  associated tangent and feather point data as well. If the index is out of\n  bounds, an IndexError will be raised.\n\nReturns: None"
    }, 
    {
        "removeTranslationKey() (AnimCTransform)": "removeTranslationKey(self,\n        time,\n        view)"
    }, 
    {
        "run() (BreakoutThreadClass)": "run(self)\n\nsource\u00a0code\u00a0\n    \n\n\nOverrides:\n        threading.Thread.run"
    }, 
    {
        "remove() (Stroke)": "remove(self,\n        index)\n\n\u00a0\n    \n\nRemove the control point at the given index. If the index is out of \n  bounds, an IndexError will be raised.\n\nReturns: None"
    }, 
    {
        "removeUpdateUI() (nuke.callbacks)": "removeUpdateUI(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "run() (pyAppHelper)": "run(self,\n        call,\n        args=(),\n        kwargs={})\n      Runs the specified call in a separate thread.\n\nsource\u00a0code"
    }, 
    {
        "remove() (AnimAttributes)": "remove(self,\n        attributeIndexOrName)\n\n\u00a0\n    \n\nRemove an attribute. You can give the name or index of the \n  attribute.\n\nReturns: None"
    }, 
    {
        "render() (nuke)": "render(nameOrNode,\n        start,\n        end,\n        incr,\n        views,\n        continueOnError= False)\n\n\u00a0\n    \n\nexecute(nameOrNode, frameRangeSet, views, continueOnError = False) \n  -> None.\nExecute the named Write node over the specified frames.\nThere are two variants of this function. The first allows you to \n  specify the frames to write range by giving the start frame number, the \n  end frame number and the frame increment. The second allows you to \n  specify more complicated sets of frames by providing a sequence of \n  FrameRange objects.\nIf Nuke is run with the GUI up, this will pop up a progress meter. If \n  the user hits the cancel button this command will return 'cancelled' \n  error. If Nuke is run from the nuke command line (ie nuke was started \n  with the -t switch) execute() prints a text percentage as it progresses. \n  If the user types ^C it will aborting the execute() and return a \n  'cancelled' error.\n\nParameters:\n\nnameOrNode - A node name or a node object.\nstart - Optional start frame. Default is root.first_frame.\nend - Optional end frame. Default is root.last_frame.\nincr - Optional increment. Default is 1.\nviews - Optional list of views. Default is None, meaning \"all \n          views\".\n\nReturns: None\nNone"
    }, 
    {
        "run() (ExampleRVFlipbook)": "run(self,\n        filename,\n        frameRanges,\n        views,\n        options)\n\nsource\u00a0code\u00a0\n    \n\nExecute the flipbook on a path.\n\nParameters:\n\npath - The path to run the flipbook on. This will be similar to \n          /path/to/foo%03d.exr\nframeRanges - A FrameRanges object representing the range that should be \n          flipbooked. Note that in 6.2v1-2 this was a FrameRange object.\nviews - A list of strings comprising of the views to flipbook. Willnot be\n          more than the maximum supported by the flipbook.\noptions - A dictionary of options to use. This may contain the keys \n          pixelAspect, roi, dimensions, audio and lut. These contain a \n          float, a dict with bounding box dimensions, a dict with width and\n          height, a path to audio file and a string indicating the LUT \n          conversion to apply.\n\nReturns:\nNone\nOverrides:\n        flipbooking.FlipbookApplication.run\n(inherited documentation)"
    }, 
    {
        "remove_inputs() (nukescripts.edit)": "remove_inputs()\n\nsource\u00a0code"
    }, 
    {
        "render() (pyQtRenderDialog)": "render(self)\n\nsource\u00a0code"
    }, 
    {
        "run() (ExecuteDialog)": null
    }, 
    {
        "removeAfterBackgroundFrameRender() (nuke.callbacks)": "removeAfterBackgroundFrameRender(call,\n        args=(),\n        kwargs={})\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "render_panel() (nukescripts.renderpanel)": null
    }, 
    {
        "run() (FlipbookDialog)": "run(self)\n\nsource\u00a0code\u00a0\n    \n\n\nOverrides:\n        ExecuteDialog.run"
    }, 
    {
        "removeAfterBackgroundRender() (nuke.callbacks)": "removeAfterBackgroundRender(call,\n        args=(),\n        kwargs={})\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "renderdialog (nukescripts)": null
    }, 
    {
        "run() (RenderDialog)": "run(self)\n\nsource\u00a0code\u00a0\n    \n\n\nOverrides:\n        ExecuteDialog.run"
    }, 
    {
        "removeAfterFrameRender() (nuke.callbacks)": "removeAfterFrameRender(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "RenderDialog (nukescripts.renderdialog)": null
    }, 
    {
        "run_app() (FramecyclerFlipbook)": "run_app(self,\n        app,\n        in_args)\n\nsource\u00a0code"
    }, 
    {
        "removeAfterRender() (nuke.callbacks)": "removeAfterRender(call,\n        args=(),\n        kwargs={},\n        nodeClass='Write')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "run_app() (nukescripts.run_framecycler)": "run_app(app,\n        in_args)\n\nsource\u00a0code"
    }, 
    {
        "removeAll() (Layer)": "removeAll(self)\n      Remove all elements from this layer."
    }, 
    {
        "run_framecycler (nukescripts)": null
    }, 
    {
        "removeAll() (AnimAttributes)": "removeAll(self)\n      Remove all attributes."
    }, 
    {
        "renderman (nukescripts)": null
    }, 
    {
        "runIn() (nuke)": "runIn(object,\n        cmd)\n\n\u00a0\n    \n\nExecute commands with a given node/knob/field as the 'context'. This \n  means that all names are evaluated relative to this object, and commands \n  that modify 'this' node will modify the given one.\n\nParameters:\n\nobject - Name of object.\ncmd - Command to run.\n\nReturns: bool\nTrue if succeeded, False otherwise."
    }, 
    {
        "removeAllKeys() (AnimControlPoint)": "removeAllKeys(self,\n        view)"
    }, 
    {
        "renderpanel (nukescripts)": null
    }, 
    {
        "RunInMainThread (nuke)": null
    }, 
    {
        "removeAllKeys() (AnimCurve)": "removeAllKeys(self)\n      Removes all keys from this curve."
    }, 
    {
        "REPLACE (nuke)": "REPLACE = 1"
    }, 
    {
        "running() (Node)": "running(self)\n\n\u00a0\n    \n\nClass method.\n\nReturns: Node rendering when paralled threads are running or None\nNode rendering when paralled threads are running or None."
    }, 
    {
        "removeAutolabel() (nuke.callbacks)": "removeAutolabel(call,\n        args=(),\n        kwargs={},\n        nodeClass='*')\n      Remove a previously-added callback with the same arguments.\n\nsource\u00a0code"
    }, 
    {
        "replaceHashes() (nukescripts.frame)": null
    }, 
    {
        "S (re)": "S = 16"
    }, 
    {
        "setFlag() (Knob)": "setFlag(self,\n        f)\n\n\u00a0\n    \n\nLogical OR of the argument and existing knob flags.\n\nParameters:\n\nf - Flag.\n\nReturns: None\nNone."
    }, 
    {
        "setViewsForStereo() (nukescripts.stereo)": null
    }, 
    {
        "sample() (Node)": "sample(self,\n        c,\n        x,\n        y,\n        dx,\n        dy)\n\n\u00a0\n    \n\nReturn pixel values from an image. This requires the image to be \n  calculated, so performance may be very bad if this is placed into an \n  expression in a control panel. Produces a cubic filtered result. Any \n  sizes less than 1, including 0, produce the same filtered result, this is\n  correct based on sampling theory. Note that integers are at the corners \n  of pixels, to center on a pixel add .5 to both coordinates. If the \n  optional dx,dy are not given then the exact value of the square pixel \n  that x,y lands in is returned. This is also called 'impulse \n  filtering'.\n\nParameters:\n\nc - Channel name.\nx - Centre of the area to sample (X coordinate).\ny - Centre of the area to sample (Y coordinate).\ndx - Optional size of the area to sample (X coordinate).\ndy - Optional size of the area to sample (Y coordinate).\nframe - Optional frame to sample the node at.\n\nReturns: Floating point value\nFloating point value."
    }, 
    {
        "setFlipbookDefaultOption() (nukescripts.renderdialog)": "setFlipbookDefaultOption(name,\n        value)\n\nsource\u00a0code\u00a0\n    \n\nSet a particular option to the given value. The type of the value \n  differs per option, giving the wrong value may result in exceptions. The \n  options are read every time the dialog is opened, though not every knob \n  in the dialog has it's value stored."
    }, 
    {
        "setVisible() (Element)": "setVisible(self,\n        time,\n        value)\n\n\u00a0\n    \n\nSet the value of the visible attribute at a particular time. value \n  must be a bool.\n\nReturns: None"
    }, 
    {
        "sample() (nuke)": "sample(n,\n        c,\n        x,\n        y,\n        dx,\n        dy)\n\n\u00a0\n    \n\nGet pixel values from an image. Deprecated, use Node.sample \n  instead.\nThis requires the image to be calculated, so performance may be very \n  bad if this is placed into an expression in a control panel. Produces a \n  cubic filtered result. Any sizes less than 1, including 0, produce the \n  same filtered result, this is correct based on sampling theory. Note that\n  integers are at the corners of pixels, to center on a pixel add .5 to \n  both coordinates. If the optional dx,dy are not given then the exact \n  value of the square pixel that x,y lands in is returned. This is also \n  called 'impulse filtering'.\n\nParameters:\n\nn - Node.\nc - Channel name.\nx - Centre of the area to sample (X coordinate).\ny - Centre of the area to sample (Y coordinate).\ndx - Optional size of the area to sample (X coordinate).\ndy - Optional size of the area to sample (Y coordinate).\n\nReturns: float\nFloating point value."
    }, 
    {
        "setFrame() (OutputContext)": "setFrame(f)\n\n\u00a0\n    \n\nSet frame value. The f argument is a float.\n\nReturns: True"
    }, 
    {
        "setVisible() (Knob)": "setVisible(self,\n        visible)\n\n\u00a0\n    \n\nShow or hide the knob.\n\nParameters:\n\nvisible - True to show the knob, False to hide it.\n\nReturns: None"
    }, 
    {
        "save() (DialogState)": "save(self,\n        knob)\n\nsource\u00a0code\u00a0\n    \n\nStore the knob's current value as the 'last state' for the next time \n  the dialog is opened. Values are stored in a dict referenced by knob \n  name, so names must be unique!"
    }, 
    {
        "setFrame() (Root)": "setFrame(self,\n        n)\n\n\u00a0\n    \n\nSet frame.\n\nParameters:\n\nn - Frame number.\n\nReturns: None\nNone."
    }, 
    {
        "setW() (Box)": "setW(self,\n        n)\n      Set width by moving right edge."
    }, 
    {
        "SAVE_MENU (nuke)": "SAVE_MENU = 33554432"
    }, 
    {
        "setH() (Box)": "setH(self,\n        n)\n      Set height by moving top edge."
    }, 
    {
        "setWidth() (Format)": "setWidth(self,\n        newWidth)\n      Set the width of image file in pixels.newWidth is the new width for \n      the image; it should be a positive integer."
    }, 
    {
        "saveNodePresets() (nukescripts.nodepresets)": null
    }, 
    {
        "setHeight() (Format)": "setHeight(self,\n        newHeight)\n\n\u00a0\n    \n\nSet the height of image file in pixels. newHeight is the new height \n  for the image; it should be a positive integer.\n\nReturns: None"
    }, 
    {
        "setWidth() (Panel)": "setWidth(self,\n        val)\n\n\u00a0\n    \n\nSet the width of the panel.\n\nParameters:\n\nval - The width as an int.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "saveUserPreset() (nuke)": "saveUserPreset(node,\n        presetName)\n\n\u00a0\n    \n\nSaves a node's current knob values as a user preset.\n\nParameters:\n\npresetName - Name of the preset to create.\n\nReturns: None\nbool."
    }, 
    {
        "setIcon() (MenuItem)": "setIcon(self,\n        icon)\n\n\u00a0\n    \n\nSet the icon on this menu item.\n\nParameters:\n\nicon - the new icon as a path\n\nReturns: None"
    }, 
    {
        "setX() (BBox_Knob)": "setX(...)\n      Set value for X position."
    }, 
    {
        "saveValue() (DialogState)": "saveValue(self,\n        id,\n        value)\n      Stores the value with the given id.\n\nsource\u00a0code"
    }, 
    {
        "setIdentity() (AnimCTransform)": "setIdentity(self,\n        view='default')"
    }, 
    {
        "setX() (Box)": "setX(self,\n        n)\n\n\u00a0\n    \n\nSet the left edge. The parameter n is an integer.\n\nReturns: None"
    }, 
    {
        "saveWindowLayout() (nuke)": "saveWindowLayout(i=-1)\n\n\u00a0\n    \n\nSaves the current window layout.\n\nParameters:\n\ni - Optional layout index. If this is omitted or set to a negative \n          value, save as the default layout.\n\nReturns: None\nNone."
    }, 
    {
        "setIdentity() (CTransform)": "setIdentity(self)\n      Set this transform to the identity transform (the transform which \n      doesn't change the object at all)."
    }, 
    {
        "setX() (Box3_Knob)": "setX(...)\n\n\u00a0\n    \n\nSet value for X position. X is the minimum horizontal extent of the \n  box."
    }, 
    {
        "scale (CTransform)": "scale\n      The scale factors, represented as a CVec3 object."
    }, 
    {
        "setImportedItems() (SceneView_Knob)": "setImportedItems(self,\n        items)\n\n\u00a0\n    \n\nSets a list of strings containing all items imported into the knob. \n  This will overwrite the current imported items list.@param items: List of\n  imported items.\n\nReturns: None\nNone."
    }, 
    {
        "setX() (Format)": "setX(self,\n        newX)\n\n\u00a0\n    \n\nSet the left edge of image file in pixels. newX is the new left edge \n  for the  image; it should be a positive integer.\n\nReturns: None"
    }, 
    {
        "scale() (CMatrix4)": "scale(self,\n        x,\n        y,\n        z)\n\n\u00a0\n    \n\nPost-multiply this matrix by a scale transformation. The y and z \n  parameters may be left out; if so the scale is uniform along all three \n  axes.\n\nReturns: None"
    }, 
    {
        "setIncrement() (FrameRange)": "setIncrement(self,\n        n)\n      set the increment between two frames."
    }, 
    {
        "setXpos() (Node)": "setXpos(self,\n        x)\n\n\u00a0\n    \n\nSet the x position of node in node graph.\n\nParameters:\n\nx - The x position of node in node graph.\n\nReturns: None\nNone."
    }, 
    {
        "scale() (Axis_Knob)": "scale(self)\n      Return scale knob."
    }, 
    {
        "setInput() (Channel_Knob)": "setInput(self,\n        num)\n\n\u00a0\n    \n\nSet the input number for this knob.@param num: The number of the new \n  input.\n\nReturns: None\nNone"
    }, 
    {
        "setXYpos() (Node)": "setXYpos(self,\n        x,\n        y)\n\n\u00a0\n    \n\nSet the (x, y) position of node in node graph.\n\nParameters:\n\nx - The x position of node in node graph.\ny - The y position of node in node graph.\n\nReturns: None\nNone."
    }, 
    {
        "scale() (VertexSelection)": null
    }, 
    {
        "setInput() (Node)": "setInput(self,\n        i,\n        node)\n\n\u00a0\n    \n\nConnect input i to node if canSetInput() returns true.\n\nParameters:\n\ni - Input number.\nnode - The node to connect to input i.\n\nReturns: bool\nTrue if canSetInput() returns true, or if the input is already \n          correct."
    }, 
    {
        "setY() (BBox_Knob)": "setY(...)\n      Set value for Y position."
    }, 
    {
        "Scale_Knob (nuke)": null
    }, 
    {
        "setInput() (Root)": "setInput(self,\n        i,\n        node)\n\n\u00a0\n    \n\nConnect input i to node if canSetInput() returns true.\n\nParameters:\n\ni - Input number.\nnode - The node to connect to input i.\n\nReturns: bool\nTrue if canSetInput() returns true, or if the input is already \n          correct.\nOverrides:\n        Node.setInput\n(inherited documentation)"
    }, 
    {
        "setY() (Box)": "setY(self,\n        n)\n\n\u00a0\n    \n\nSet the bottom edge. The parameter n is an integer.\n\nReturns: None"
    }, 
    {
        "scaled() (Format)": "scaled(sx,\n        sy,\n        tx,\n        ty)\n\n\u00a0\n    \n\nScale and translate this format by sx, sy, tx and ty.\n\nParameters:\n\nsx - Scale factor in X.@param sy: Scale factor in Y.@param tx: Offset \n          factor in X.@param ty: Offset factor in Y.@return: Format.\n\nReturns: Format"
    }, 
    {
        "setKey() (AnimAttributes)": "setKey(self,\n        time,\n        attributeIndex,\n        hash,\n        value,\n        view)\n\n\u00a0\n    \n\nSet a key for an attribute. The time parameter is when the new key \n  will be created for; the attributeIndex says which attribute to set the \n  key for; the\n\nReturns: None"
    }, 
    {
        "setY() (Box3_Knob)": "setY(...)\n\n\u00a0\n    \n\nSet value for Y position. Y is the minimum vertical extent of the \n  box."
    }, 
    {
        "scaleToPointsVerified() (nukescripts.snap3d)": "scaleToPointsVerified(nodeToScale,\n        vertexSelection)\n\nsource\u00a0code"
    }, 
    {
        "setKey() (AnimationCurve)": "setKey(self,\n        t,\n        y)\n\n\u00a0\n    \n\nSet a key at time t and value y. If there is no key there one is \n  created. If there is a key there it is moved vertically to be at y.  If a\n  new key is inserted the interpolation and extrapolation are copied from a\n  neighboring key, if there were no keys then it is set to nuke.SMOOTH \n  interpolation and nuke.CONSTANT extrapolation.\n\nParameters:\n\nt - The time to set the key at.\ny - The value for the key.\n\nReturns: Key\nThe new key."
    }, 
    {
        "setY() (Format)": "setY(self,\n        newY)\n\n\u00a0\n    \n\nSet the bottom edge of image file in pixels. newY is the new bottom \n  edge for the image; it should be a positive integer.\n\nReturns: None"
    }, 
    {
        "setKeyAt() (Array_Knob)": "setKeyAt(self,\n        time,\n        index,\n        view)\n\n\u00a0\n    \n\nSet a key on element 'index', at time and view.\n\nParameters:\n\ntime - Time.\nindex - Optional index.\nview - Optional view.\n\nReturns: None\nNone."
    }, 
    {
        "setYpos() (Node)": "setYpos(self,\n        y)\n\n\u00a0\n    \n\nSet the y position of node in node graph.\n\nParameters:\n\ny - The y position of node in node graph.\n\nReturns: None\nNone."
    }, 
    {
        "SceneView_Knob (nuke)": null
    }, 
    {
        "setKnob() (DialogState)": "setKnob(self,\n        knob,\n        defaultValue=None)\n      Convenience method for setting a value straight on a knob.\n\nsource\u00a0code"
    }, 
    {
        "Shape (_curveknob)": null
    }, 
    {
        "screenHeight() (Node)": "screenHeight(self)\n\n\u00a0\n    \n\nHeight of the node when displayed on screen in the DAG, at 1:1 zoom, \n  in pixels.\n\nReturns: int\nint."
    }, 
    {
        "setLabel() (Knob)": "setLabel(self,\n        s)\n\n\u00a0\n    \n\n\nParameters:\n\ns - New label.\n\nReturns: None\nNone."
    }, 
    {
        "ShapeControlPoint (_curveknob)": null
    }, 
    {
        "screenWidth() (Node)": "screenWidth(self)\n\n\u00a0\n    \n\nWidth of the node when displayed on screen in the DAG, at 1:1 zoom, in\n  pixels.\n\nReturns: int\nint."
    }, 
    {
        "setLast() (FrameRange)": "setLast(self,\n        n)\n      set the last frame of the range."
    }, 
    {
        "shortcut() (MenuItem)": "shortcut(self)\n\n\u00a0\n    \n\nReturns the keyboard shortcut on this menu item. The format of this is\n  the PortableText format. It will return a string such as \n  \"Ctrl+Shift+P\". Note that on Mac OS X the Command key is \n  equivalent to Ctrl.\n\nReturns: String"
    }, 
    {
        "SCRIPT (nuke)": "SCRIPT = 2"
    }, 
    {
        "setLink() (Link_Knob)": "setLink(s)"
    }, 
    {
        "show() (Panel)": "show(self)\n\n\u00a0\n    \n\nDisplay the panel.\n\nReturns: An int value indicating how the dialog was closed (normally, or \n      cancelled)\nAn int value indicating how the dialog was closed (normally, or \n          cancelled)."
    }, 
    {
        "script (nukescripts)": null
    }, 
    {
        "setMessage() (ProgressTask)": "setMessage(self,\n        s)\n      set the message for the progress task"
    }, 
    {
        "show() (nuke)": "collapseToGroup(show=True)\n\n\u00a0\n    \n\nMoves the currently selected nodes to a new group, maintaining their \n  previous connections.\n\nParameters:\n\nshow - If show is True, the node graph for the new group is shown in the\n          background.\n\nReturns: Group\nThe new Group node."
    }, 
    {
        "script() (MenuItem)": "setScript(self,\n        script)\n\n\u00a0\n    \n\nSet the script to be executed for this menu item. Note: To call a \n  python script file, you can use the execfile() function. i.e: \n  menu.setScript(\"execfile('script.py')\")\n\nReturns: None"
    }, 
    {
        "setModified() (Root)": "setModified(self,\n        b)\n\n\u00a0\n    \n\nSet the 'modified' flag in a script. Setting the value will turn the \n  indicator in the title bar on/off and will start or stop the autosave \n  timeout.\n\nParameters:\n\nb - Boolean convertible object.\n\nReturns: None\nNone."
    }, 
    {
        "show() (PythonPanel)": "show(self)\n\n\u00a0\n    \n\nShow the widget.\n\nOverrides:\n        unreachable.Widget.show\n        (inherited documentation)"
    }, 
    {
        "script_command() (nukescripts.script)": null
    }, 
    {
        "setN() (Box3_Knob)": "setN(...)\n\n\u00a0\n    \n\nSet value for N position. N (near) is the minimum Z extent of the \n  box."
    }, 
    {
        "showBookmarkChooser() (nuke)": "showBookmarkChooser(n)\n\n\u00a0\n    \n\nShow bookmark chooser search box.\n\nReturns: None\nNone"
    }, 
    {
        "script_data() (nukescripts.script)": null
    }, 
    {
        "setName() (AnimAttributes)": "setName(self,\n        attributeIndex,\n        newName)\n      Change the name of an existing attribute."
    }, 
    {
        "showControlPanel() (Node)": "showControlPanel(self,\n        forceFloat= false)\n\n\u00a0\n    \n\n\nParameters:\n\nforceFloat - Optional python object. If it evaluates to True the control panel\n          will always open as a floating panel. Default is False.\n\nReturns: None\nNone"
    }, 
    {
        "script_directory() (nuke.utils)": null
    }, 
    {
        "setName() (Format)": "setName(self,\n        name)\n\n\u00a0\n    \n\nSet name of this format. The name parameter is the new name for the \n  format.\n\nReturns: None"
    }, 
    {
        "showDag() (nuke)": "showDag(n)\n\n\u00a0\n    \n\nShow the tree view of a group node or opens a node control panel.\n\nParameters:\n\nn - Optional Group.\n\nReturns: None\nNone"
    }, 
    {
        "script_directory() (nukescripts.script)": null
    }, 
    {
        "setName() (Knob)": "setName(self,\n        s)\n\n\u00a0\n    \n\n\nParameters:\n\ns - New name.\n\nReturns: None\nNone."
    }, 
    {
        "showDialog() (FrameRangePanel)": null
    }, 
    {
        "Script_Knob (nuke)": null
    }, 
    {
        "setName() (Layer)": "setName(self,\n        newName)\n\n\u00a0\n    \n\nSet the name of this layer.\n\nParameters:\n\nnewName - The new name for this layer.\n\nReturns: None"
    }, 
    {
        "showExecuteDialog() (nukescripts.renderdialog)": "showExecuteDialog(nodesToExecute,\n        exceptOnError=True)\n      Present a dialog that executes the given list of nodes.\n\nsource\u00a0code"
    }, 
    {
        "script_version_up() (nukescripts.script)": null
    }, 
    {
        "setName() (Node)": "setName(self,\n        name,\n        uncollide=True,\n        updateExpressions=False)\n\n\u00a0\n    \n\nSet name of the node and resolve name collisions if optional named \n  argument 'uncollide' is True.\n\nParameters:\n\nname - A string.\nuncollide - Optional boolean to resolve name collisions. Defaults to True.\nupdateExpressions - Optional boolean to update expressions in other nodes to point at\n          the new name. Defaults to False.\n\nReturns: None\nNone"
    }, 
    {
        "showFlipbookDialog() (nukescripts.renderdialog)": "showFlipbookDialog(node,\n        takeNodeSettings=False)\n      Present a dialog that flipbooks the given node.\n\nsource\u00a0code"
    }, 
    {
        "scriptClear() (nuke)": "scriptClear(...)\n\n\u00a0\n    \n\nClears a Nuke script and resets all the root knobs to user defined \n  knob defaults. To reset to compiled in defaults only pass in \n  resetToCompiledDefaults=True."
    }, 
    {
        "setPivotPointAnimCurve() (AnimCTransform)": "setPivotPointAnimCurve(self,\n        index,\n        animCurve,\n        view)\n\n\u00a0\n    \n\nSet the anim curve for the pivot point attribute of this transform. \n  The index parameter should be 0 for the x values, 1 for the y values. The\n  view parameter is optional.\n\nReturns: None"
    }, 
    {
        "showFlipbookDialogForSelected() (nukescripts.renderdialog)": "showFlipbookDialogForSelected()\n      Present a dialog that flipbooks the currently selected node.\n\nsource\u00a0code"
    }, 
    {
        "scriptClose() (nuke)": "scriptClose(...)\n\n\u00a0\n    \n\nClose the current script or group. Returns True if successful."
    }, 
    {
        "setPixelAspect() (Format)": "setPixelAspect(self,\n        aspectRatio)\n\n\u00a0\n    \n\nSet a new pixel aspect ratio for this format. The aspectRatio \n  parameter is the new ratio, found by dividing the desired pixel width by \n  the desired pixel height.\n\nReturns: None"
    }, 
    {
        "showInfo() (Node)": "showInfo(self,\n        s)\n\n\u00a0\n    \n\nCreates a dialog box showing the result of script s.\n\nParameters:\n\ns - A string.\n\nReturns: None\nNone."
    }, 
    {
        "scriptExit() (nuke)": "scriptExit(...)\n      Exit Nuke."
    }, 
    {
        "setPosition() (AnimControlPoint)": "setPosition(self,\n        position,\n        view)\n\n\u00a0\n    \n\nSets the control point's 'constant' position (the position used when \n  there are no keys - see AnimCurve for further info). Calling this method \n  when the control point has keys will have no effect.\n\nReturns: None"
    }, 
    {
        "showInfo() (nuke)": "showInfo(n)\n\n\u00a0\n    \n\nReturns a long string of debugging information about each node and the\n  operators it is currently managing. You should not rely on its contents \n  or format being the same in different versions of Nuke.\n\nParameters:\n\nn - Optional node argument.\n\nReturns: str\nString."
    }, 
    {
        "scriptName() (nuke)": "scriptName()\n      Return the current script's file name"
    }, 
    {
        "setPositionAnimCurve() (AnimControlPoint)": "setPositionAnimCurve(self,\n        index,\n        animCurve,\n        view)\n      Set the point's AnimCurve object (its time line)."
    }, 
    {
        "showModal() (PythonPanel)": "showModal(self,\n        defaultKnobText='')\n\n\u00a0\n    \n\nShow the dialog as modal, and wait for it to be dismissed.\n\nOverrides:\n        unreachable.Dialog.showModal\n        (inherited documentation)"
    }, 
    {
        "scriptNew() (nuke)": "scriptNew(...)\n\n\u00a0\n    \n\nStart a new script. Returns True if successful."
    }, 
    {
        "setPositionKey() (AnimControlPoint)": "setPositionKey(self,\n        time,\n        index,\n        value,\n        id,\n        view)\n\n\u00a0\n    \n\nSets an individual dimension (index) of a key to a specific value. The\n  key to modify is identified by hash (id). The method fails if there is no\n  key at the specified time.\n\nReturns: None"
    }, 
    {
        "showModalDialog() (PythonPanel)": "showModalDialog(self,\n        defaultKnobText='')"
    }, 
    {
        "scriptOpen() (nuke)": "scriptOpen(...)\n      Opens a new script containing the contents of the named file."
    }, 
    {
        "setPreset() (nuke)": "setPreset(nodeClassName,\n        presetName,\n        knobValues)\n\n\u00a0\n    \n\nCreate a node preset for the given node using the supplied knob \n  values\n\nParameters:\n\nnodeClassName - Name of the node class to create a preset for.\npresetName - Name of the preset to create.\nknobValues - A dictionary containing a set of knob names and preset values.\n\nReturns: None\nbool."
    }, 
    {
        "shown() (Node)": "shown(self)\n\n\u00a0\n    \n\nThis can be used to skip updates that are not visible to the user.\n\nReturns: true if the properties panel is open\ntrue if the properties panel is open. This can be used to skip \n          updates that are not visible to the user."
    }, 
    {
        "scriptReadFile() (nuke)": "scriptReadFile(...)\n      Read nodes from a file."
    }, 
    {
        "setProgress() (ProgressTask)": "setProgress(self,\n        i)\n      i is an integer representing the current progress"
    }, 
    {
        "showname() (nukescripts.misc)": "showname()\n      Shows the current script path and, if the selected node is a Read or \n      Write node, the filename from it.\n\nsource\u00a0code"
    }, 
    {
        "scriptReadText() (nuke)": "scriptReadText(...)\n      Read nodes from a string."
    }, 
    {
        "setProxy() (Root)": "setProxy(self,\n        b)\n\n\u00a0\n    \n\nSet proxy.\n\nParameters:\n\nb - Boolean convertible object.\n\nReturns: None\nNone."
    }, 
    {
        "showRenderDialog() (nukescripts.renderdialog)": "showRenderDialog(nodesToRender,\n        exceptOnError=True)\n      Present a dialog that renders the given list of nodes.\n\nsource\u00a0code"
    }, 
    {
        "scriptSave() (nuke)": "scriptSave(filename=None)\n\n\u00a0\n    \n\nSaves the current script to the current file name. If there is no \n  current file name and Nuke is running in GUI mode, the user is asked for \n  a name using the file chooser.\n\nParameters:\n\nfilename - Save to this file name without changing the script name in the \n          project (use scriptSaveAs() if you want it to change).\n\nReturns: bool\nTrue if the file was saved, otherwise an exception is thrown."
    }, 
    {
        "setR() (BBox_Knob)": "setR(...)\n      Set value for R extent."
    }, 
    {
        "showSettings() (nuke)": "showSettings()\n\n\u00a0\n    \n\nShow the settings of the current group.\n\nReturns: None\nNone"
    }, 
    {
        "scriptSaveAs() (nuke)": "scriptSaveAs(filename=None,\n        overwrite=-1)\n\n\u00a0\n    \n\nSaves the current script with the given file name if supplied, or (in \n  GUI mode) asks the user for one using the file chooser. If Nuke is not \n  running in GUI mode, you must supply a filename.\n\nParameters:\n\nfilename - Saves the current script with the given file name if  supplied, \n          or (in GUI mode) asks the user for one using the file chooser.\noverwrite - If 1 (true) always overwrite; if 0 (false) never overwrite;  \n          otherwise, in GUI mode ask the user, in terminal do same as \n          False. Default  is -1, meaning 'ask the user'.\n\nReturns: None"
    }, 
    {
        "setR() (Box)": "setR(self,\n        n)\n\n\u00a0\n    \n\nSet the right edge. The parameter n is an integer.\n\nReturns: None"
    }, 
    {
        "showUI() (pyQtRenderDialog)": "showUI(self)\n\nsource\u00a0code"
    }, 
    {
        "scriptSource() (nuke)": "scriptSource(...)\n      Same as scriptReadFile()."
    }, 
    {
        "setR() (Box3_Knob)": "setR(...)\n\n\u00a0\n    \n\nSet value for R extent. R (right) is the right extent of the box."
    }, 
    {
        "singleLineInput (nukescripts.panel_test)": null
    }, 
    {
        "search_replace() (nukescripts.searchreplace)": null
    }, 
    {
        "setR() (Format)": "setR(self,\n        newR)\n\n\u00a0\n    \n\nSet the right edge of image file in pixels. newR is the new right edge\n  for the image; it should be a positive integer.\n\nReturns: None"
    }, 
    {
        "singleValue() (Array_Knob)": "singleValue(self,\n        view)\n\n\u00a0\n    \n\n\nParameters:\n\nview - Optional view. Default is current view.\n\nReturns: True if holds a single value\nTrue if holds a single value."
    }, 
    {
        "searchreplace (nukescripts)": null
    }, 
    {
        "setRange() (Array_Knob)": "setRange(self,\n        f1,\n        f2)\n\n\u00a0\n    \n\nSet range of values. @param f1 Min value. @param f2 Max value.\n\nReturns: None\nNone."
    }, 
    {
        "size() (AnimationCurve)": "size(self)\n\n\u00a0\n    \n\n\nReturns: Number of keys\nNumber of keys."
    }, 
    {
        "SEEK_CUR (os)": "SEEK_CUR = 1"
    }, 
    {
        "setReadOnlyPresets() (nuke)": "setReadOnlyPresets(readOnly)\n\n\u00a0\n    \n\nSets whether newly created presets should be added in read-only mode. \n  Read-only presets can be applied to a node, but can't be overwritten or \n  deleted.\n\nReturns: None"
    }, 
    {
        "size() (FrameRanges)": "size()\n      return the ranges number."
    }, 
    {
        "SEEK_END (os)": "SEEK_END = 2"
    }, 
    {
        "setRenderDialogDefaultOption() (nukescripts.renderdialog)": "setRenderDialogDefaultOption(name,\n        value)\n\nsource\u00a0code\u00a0\n    \n\nSet a particular option to the given value. The type of the value \n  differs per option, giving the wrong value may result in exceptions. The \n  options are read every time the dialog is opened, though not every knob \n  in the dialog has it's value stored."
    }, 
    {
        "skew (CTransform)": "skew\n      The skew amounts, represented as a CVec3 object."
    }, 
    {
        "SEEK_SET (os)": "SEEK_SET = 0"
    }, 
    {
        "setRoi() (Viewer)": "setRoi(self,\n        box)\n\n\u00a0\n    \n\nSet the region of interest in pixel space.\n\nParameters:\n\nbox - A dictionary with the x, y, r and t keys.@return: None.\n\nReturns: None"
    }, 
    {
        "skew() (CMatrix4)": "skew(self,\n        x,\n        y,\n        z)\n\n\u00a0\n    \n\nPost-multiply this matrix with a skew transformation. The y and z \n  parameters may be left out; if so, the skew is in the X direction \n  only.\n\nReturns: None"
    }, 
    {
        "select (nukescripts)": null
    }, 
    {
        "setRotationAnimCurve() (AnimCTransform)": "setRotationAnimCurve(self,\n        index,\n        animCurve,\n        view)\n\n\u00a0\n    \n\nSet the anim curve for the rotation attribute of this transform. The \n  index parameter should be 0 for the x values, 1 for the y values. The \n  view parameter is optional.\n\nReturns: None"
    }, 
    {
        "skew() (Axis_Knob)": "skew(self)\n      Return skew knob."
    }, 
    {
        "select_by_name() (nukescripts.select)": "select_by_name()\n\nsource\u00a0code\u00a0\n    \n\nMenu command to select nodes by a glob-pattern name. This function is \n  only maintained for backwards compatibility. Please use \n  nuke.selectPattern() instead."
    }, 
    {
        "setScaleAnimCurve() (AnimCTransform)": "setScaleAnimCurve(self,\n        index,\n        animCurve,\n        view)\n\n\u00a0\n    \n\nSet the anim curve for the scale attribute of this transform. The \n  index parameter should be 0 for the x values, 1 for the y values. The \n  view parameter is optional.\n\nReturns: None"
    }, 
    {
        "SMOOTH (nuke)": "SMOOTH = 0"
    }, 
    {
        "select_similar() (nukescripts.select)": "select_similar(_type)\n\nsource\u00a0code\u00a0\n    \n\nIncluded only for compatibility.  Use nuke.selectSimilar()."
    }, 
    {
        "setScript() (MenuItem)": "setScript(self,\n        script)\n\n\u00a0\n    \n\nSet the script to be executed for this menu item. Note: To call a \n  python script file, you can use the execfile() function. i.e: \n  menu.setScript(\"execfile('script.py')\")\n\nReturns: None"
    }, 
    {
        "snap3d (nukescripts)": null
    }, 
    {
        "selectAll() (nuke)": "selectAll()\n\n\u00a0\n    \n\nSelect all nodes in the DAG.\n\nReturns: None\nNone"
    }, 
    {
        "setSelected() (Node)": "setSelected(self,\n        selected)\n\n\u00a0\n    \n\nSet the selection state of the node.  This is the same as changing the\n  'selected' knob.\n\nParameters:\n\nselected - New selection state - True or False.\n\nReturns: None\nNone."
    }, 
    {
        "snapFuncs (nukescripts.snap3d)": "snapFuncs = []"
    }, 
    {
        "selectConnectedNodes() (nuke.overrides)": "selectConnectedNodes()\n      Selects all nodes in the tree of the selected node.\n\nsource\u00a0code"
    }, 
    {
        "setSelectedItems() (SceneView_Knob)": "setSelectedItems(self)\n      Takes a list of strings of items contained in the knob and sets them \n      as selected."
    }, 
    {
        "splayNodes() (nuke)": "splayNodes()\n\n\u00a0\n    \n\nDeprecated. Use Group.splaySelectedNodes.\n\nReturns: None\nNone"
    }, 
    {
        "selected (AnimationKey)": "selected\n      True if the point is selected in the curve editor"
    }, 
    {
        "setShortcut() (MenuItem)": "setShortcut(self,\n        keySequence)\n\n\u00a0\n    \n\nSet the keyboard shortcut on this menu item.\n\nParameters:\n\nkeySequence - the new shortcut in PortableText format, e.g. \n          \"Ctrl+Shift+P\"\n\nReturns: None"
    }, 
    {
        "splaySelectedNodes() (Group)": "splaySelectedNodes(self,\n        backward,\n        inputA)\n\n\u00a0\n    \n\nSplay the selected nodes. @param backward. @param inputA.\n\nReturns: None\nNone."
    }, 
    {
        "selected() (AnimationCurve)": "selected(self)\n\n\u00a0\n    \n\n\nReturns: bool\nTrue if selected, False otherwise."
    }, 
    {
        "setSingleValue() (Array_Knob)": "setSingleValue(self,\n        b,\n        view)\n\n\u00a0\n    \n\nSet to just hold a single value or not.\n\nParameters:\n\nb - Boolean object.\nview - Optional view. Default is current view.\n\nReturns: None\nNone."
    }, 
    {
        "SplineKnob (_splinewarp)": null
    }, 
    {
        "selectedNode() (Group)": "selectedNode(self)\n\n\u00a0\n    \n\nReturns the node the user is most likely thinking about. This is the \n  last node the user clicked on, if it is selected.  Otherwise it is an \n  'output' (one with no selected outputs) of the set of selected nodes. If \n  no nodes are selected then None is returned.\n\nReturns: Node or None\nNode or None."
    }, 
    {
        "setSkewXAnimCurve() (AnimCTransform)": "setSkewXAnimCurve(self,\n        index,\n        animCurve,\n        view)\n\n\u00a0\n    \n\nSet the anim curve for the skewX attribute of this transform. The \n  index parameter should be 0 for the x values, 1 for the y values. The \n  view parameter is optional.\n\nReturns: None"
    }, 
    {
        "splinewarp (nuke)": null
    }, 
    {
        "selectedNode() (nuke)": "selectedNode()\n\n\u00a0\n    \n\nReturns the 'node the user is thinking about'. If several nodes are \n  selected, this returns one of them. The one returned will be an 'output' \n  node in that no other selected nodes use that node as an input. If no \n  nodes are selected, then if the last thing typed was a hotkey this \n  returns the node the cursor is pointing at. If none, or the last event \n  was not a hotkey, this produces a 'No node selected' error.\n\nReturns: Node\nNode."
    }, 
    {
        "setT() (BBox_Knob)": "setT(...)\n      Set value for T extent."
    }, 
    {
        "splitInSequence() (nukescripts.udim)": "splitInSequence(f)\n\nsource\u00a0code"
    }, 
    {
        "selectedNodes() (Group)": "selectedNodes(self)\n\n\u00a0\n    \n\nSelected nodes.\n\nReturns: Node or None\nNode or None."
    }, 
    {
        "setT() (Box)": "setT(self,\n        n)\n      Set top edge."
    }, 
    {
        "splitView() (Array_Knob)": "splitView(self,\n        view)\n\n\u00a0\n    \n\nSplit the view away from the current knob value.\n\nParameters:\n\nview - Optional view. Default is current view.\n\nReturns: None\nNone."
    }, 
    {
        "selectedNodes() (nuke)": "selectedNodes(filter)\n\n\u00a0\n    \n\nReturns a list of all selected nodes in the current group. An attempt \n  is made to return them in 'useful' order where inputs are done before the\n  final node, so commands applied to this list go from top-down.\n\nParameters:\n\nfilter - Optional class of Node. Instructs the algorithm to apply only to \n          a specific class of nodes.\n\nReturns: List\nThe list of selected nodes."
    }, 
    {
        "setT() (Box3_Knob)": "setT(...)\n\n\u00a0\n    \n\nSet value for T extent. T (top) is the maximum vertical extent of the \n  box."
    }, 
    {
        "splitView() (String_Knob)": "splitView(self,\n        view)\n\n\u00a0\n    \n\nSplit the view away from the current knob value.\n\nParameters:\n\nview - Optional view. Default is current view.\n\nReturns: None\nNone."
    }, 
    {
        "selectedPoints() (nukescripts.snap3d)": "selectedPoints(selectionThreshold=0.5)\n\nsource\u00a0code\u00a0\n    \n\nReturn an iterator which yields the position of every point currently \n  selected in the Viewer in turn.\nThe selectionThreshold parameter is used when working with a soft \n  selection. Only points with a selection level >= the selection \n  threshold will be returned by this function.\n\nReturns: iterator"
    }, 
    {
        "setT() (Format)": "setT(self,\n        newT)\n\n\u00a0\n    \n\nSet the top edge of image file in pixels. newY is the new top edge for\n  the image; it should be a positive integer.\n\nReturns: None"
    }, 
    {
        "start() (server)": null
    }, 
    {
        "selectedVertexInfos() (nukescripts.snap3d)": "selectedVertexInfos(selectionThreshold=0.5)\n\nsource\u00a0code\u00a0\n    \n\nReturn an iterator which yields a tuple of the index and position of \n  each point currently selected in the Viewer in turn.\nThe selectionThreshold parameter is used when working with a soft \n  selection. Only points with a selection level >= the selection \n  threshold will be returned by this function.\n\nReturns: iterator"
    }, 
    {
        "setText() (String_Knob)": "setText(self,\n        val,\n        view='default')\n\n\u00a0\n    \n\nSet value of knob.\n\nParameters:\n\nval - The new value.\nview - Optional parameter specifying which view to set the value for. If\n          omitted, the value will be set for the default view.\n\nReturns: None\nNone"
    }, 
    {
        "start() (nukescripts.openurl)": null
    }, 
    {
        "selectNodes() (BackdropNode)": "selectNodes(self,\n        selectNodes)\n\n\u00a0\n    \n\nSelect or deselect all nodes in backdrop node Example: backdrop = \n  nuke.toNode(\"BackdropNode1\") backdrop.selectNodes(True)\n\nReturns: None\nNone."
    }, 
    {
        "setTitle() (Panel)": "setTitle(self,\n        val)\n\n\u00a0\n    \n\nSet the current title for the panel.\n\nParameters:\n\nval - The title as a string.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "start() (pyQtAppHelper)": "__init__(self,\n        argv=[],\n        start=None)\n(Constructor)\n\nsource\u00a0code\u00a0\n    \n\nconstructor\n\nOverrides:\n        object.__init__\n        (inherited documentation)"
    }, 
    {
        "selectPattern() (nuke)": "selectPattern()\n\n\u00a0\n    \n\nSelects nodes according to a regular expression matching pattern, \n  entered through an input dialog. The pattern can include wildcards ('?' \n  and '*') as well as regular expressions. The expressions are checked \n  against the node name, label, class, and associated file names.\n\nReturns: None\nNone"
    }, 
    {
        "setTooltip() (Knob)": "setTooltip(self,\n        s)\n\n\u00a0\n    \n\n\nParameters:\n\ns - New tooltip.\n\nReturns: None\nNone."
    }, 
    {
        "start() (pyWxAppHelper)": "__init__(self,\n        wxApp,\n        start=None)\n(Constructor)\n\nsource\u00a0code\u00a0\n    \n\nconstructor\n\nOverrides:\n        object.__init__\n        (inherited documentation)"
    }, 
    {
        "selectSimilar() (nuke)": "selectSimilar(matchType)\n\n\u00a0\n    \n\nSelects nodes that match a node in the current selection based on \n  matchType criteria.\n\nParameters:\n\nmatchType - One of nuke.MATCH_CLASS, nuke.MATCH_LABEL, nuke.MATCH_COLOR.\n\nReturns: None\nNone."
    }, 
    {
        "setTransform() (Layer)": "setTransform(self,\n        transform)\n\n\u00a0\n    \n\nReplace the existing transform for this shape with a new one. The \n  transform parameter must be an instance of the AnimTransform class.\n\nReturns: None"
    }, 
    {
        "start_server() (nukescripts.clientserver)": null
    }, 
    {
        "send() (client)": null
    }, 
    {
        "setTranslationAnimCurve() (AnimCTransform)": "setTranslationAnimCurve(self,\n        index,\n        animCurve,\n        view)\n\n\u00a0\n    \n\nSet the anim curve for the translation attribute of this transform. \n  The index parameter should be 0 for the x values, 1 for the y values. The\n  view parameter is optional.\n\nReturns: None"
    }, 
    {
        "STARTLINE (nuke)": "STARTLINE = 4096"
    }, 
    {
        "sendMouseEvent() (Viewer)": "sendMouseEvent(f)\n      Determine whether frame /f/ is known to be in the memory cache."
    }, 
    {
        "setup_toolbars() (nukescripts.toolbars)": null
    }, 
    {
        "startPerformanceTimers() (nuke)": "startPerformanceTimers()\n      Start keeping track of accumulated time on the performance timers, \n      and display the accumulated time in the DAG."
    }, 
    {
        "sep (os)": "sep = '/'"
    }, 
    {
        "setUserPreset() (nuke)": "setUserPreset(nodeClassName,\n        presetName,\n        knobValues)\n\n\u00a0\n    \n\nCreate a node preset for the given node using the supplied knob \n  values\n\nParameters:\n\nnodeClassName - Name of the node class to create a preset for.\npresetName - Name of the preset to create.\nknobValues - A dictionary containing a set of knob names and preset values.\n\nReturns: None\nbool."
    }, 
    {
        "startQtRenderDialog() (nukescripts.pyQtExamples.pyQtRender)": null
    }, 
    {
        "sep (posixpath)": "sep = '/'"
    }, 
    {
        "setValue() (Array_Knob)": "setValue(self,\n        value,\n        index,\n        time,\n        view)\n\n\u00a0\n    \n\nSafe to ignore. Set index to value at time and view.\n\nParameters:\n\nvalue - Floating point value.\nindex - Optional index.\ntime - Optional time.\nview - Optional view.\n\nReturns: True if value changed, False otherwise\nTrue if value changed, False otherwise. Safe to ignore.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "sequence() (FramecyclerFlipbook)": "sequence(self,\n        frange,\n        filename,\n        cmd_args_size)\n\nsource\u00a0code"
    }, 
    {
        "setValue() (Boolean_Knob)": "setValue(self,\n        b)\n\n\u00a0\n    \n\nSet the boolean value of this knob.\n\nParameters:\n\nb - Boolean convertible object.\n\nReturns: bool\nTrue if modified, False otherwise.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "staticMetaObject (TableDelegate)": "staticMetaObject\n\n\n\nValue:\n\n<PySide.QtCore.QMetaObject object at 0x7f9c4cb23ea8>"
    }, 
    {
        "serialise() (Element)": "serialise(self)\n      Returns a string representation of the given element."
    }, 
    {
        "setValue() (Channel_Knob)": "setValue(self,\n        name)\n\n\u00a0\n    \n\nSet the selected channel using the channel name.\n\nParameters:\n\nname - The name of the new channel as a string.\n\nReturns: None\nNone @raise ValueError exception if the channel doesn't exist.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "staticMetaObject (UDIMErrorDialog)": "staticMetaObject\n\n\n\nValue:\n\n<PySide.QtCore.QMetaObject object at 0x7f9c4cb23e60>"
    }, 
    {
        "server (nukescripts.clientserver)": null
    }, 
    {
        "setValue() (Enumeration_Knob)": "setValue(self,\n        item)\n\n\u00a0\n    \n\nSet the current value. If item is of an Integer type it will treat it \n  as an index to the enum, otherwise as a value.\n\nParameters:\n\nitem - String or Integer.\n\nReturns: None\nNone. Example: w = nuke.nodes.Write() k = w['file_type'] \n          k.setValue('exr')\nOverrides:\n        Knob.setValue"
    }, 
    {
        "staticMetaObject (UDIMOptionsDialog)": "staticMetaObject\n\n\n\nValue:\n\n<PySide.QtCore.QMetaObject object at 0x7f9c4cb23f38>"
    }, 
    {
        "set() (AnimAttributes)": "set(self,\n        time,\n        attributeIndexOrName,\n        value,\n        view)\n\n\u00a0\n    \n\nSet the value of an attribute. The time parameter is optional: if it's\n  present, a new key is created at that time with the specified value; if \n  it's not present, a constant value is set for the attribute. The \n  attribute to set may be identified by its name or index. The view \n  parameter is optional.\n\nReturns: None"
    }, 
    {
        "setValue() (File_Knob)": "setValue(self,\n        s)\n\n\u00a0\n    \n\nAssign string to knob.\n\nParameters:\n\ns - String to assign.\n\nReturns: None\nNone.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "set() (Box)": "set(self,\n        x,\n        y,\n        r,\n        t)\n      Set all values at once."
    }, 
    {
        "setValue() (Font_Knob)": "setValue(self,\n        val,\n        chan)\n\n\u00a0\n    \n\nSets the value 'val' at channel 'chan'.\n\nReturns: bool\nTrue if successful, False if not.\nOverrides:\n        Knob.setValue\n(inherited documentation)"
    }, 
    {
        "stderr (sys)": "stderr = <open file '<stderr>', mode 'w' at 0x7f9c4c0821e0>"
    }, 
    {
        "setAllItems() (SceneView_Knob)": "setAllItems(self,\n        items,\n        autoSelect)\n\n\u00a0\n    \n\nSets a list of strings containing all items that the knob can import. \n  After calling this function, only items from this list can be imported \n  into the nosde.\n\nParameters:\n\nitems - List of imported items.\nautoSelect - If True, all items are automatically set as imported and \n          selected.\n\nReturns: None\nNone."
    }, 
    {
        "setValue() (Format_Knob)": "setValue(format)\n\n\u00a0\n    \n\nSet value of knob to format (either a Format object or a name of a \n  format, e.g. \"NTSC\").\n\nReturns: True if succeeded, False otherwise\nTrue if successful, False if not.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "stderr_redirector() (nuke)": "stderr_redirector(...)\n\n\u00a0\n    \n\nInternal to Nuke. Not for public use."
    }, 
    {
        "setAnimated() (Array_Knob)": "setAnimated(self,\n        index,\n        view)\n\n\u00a0\n    \n\nCreate an Animation object. Return True if successful, in which case \n  caller must initialise it by calling setValue() or setValueAt().\n\nParameters:\n\nindex - Optional index.\nview - Optional view.\n\nReturns: True if succeeded, False otherwise\nTrue if succeeded, False otherwise.\nOverrides:\n        Knob.setAnimated"
    }, 
    {
        "setValue() (Int_Knob)": "setValue(self,\n        val)\n\n\u00a0\n    \n\nSet the integer value of this knob.\n\nParameters:\n\nval - The new value. Must be an integer.\n\nReturns: bool\nTrue if succeeded, False otherwise.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "stdin (sys)": "stdin = <open file '<stdin>', mode 'r' at 0x7f9c4c0820c0>"
    }, 
    {
        "setAnimated() (Knob)": "setAnimated(...)\n      Set channel 'c' to be animated."
    }, 
    {
        "setValue() (Knob)": "setValue(self,\n        val,\n        chan)\n\n\u00a0\n    \n\nSets the value 'val' at channel 'chan'.\n\nReturns: bool\nTrue if successful, False if not."
    }, 
    {
        "stdout (sys)": "stdout = <open file '<stdout>', mode 'w' at 0x7f9c4c082150>"
    }, 
    {
        "setCommand() (Script_Knob)": "setCommand(self,\n        cmd)\n\n\u00a0\n    \n\nSet the new command for this knob.\n\nParameters:\n\ncmd - String containing a TCL command.\n\nReturns: None\nNone."
    }, 
    {
        "setValue() (Link_Knob)": "setValue()\n\n\u00a0\n    \n\nSet value of knob.\n\nReturns: None\nTrue if successful, False if not.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "stepFrame() (FrameRange)": "stepFrame(self)\n      return the absolute increment between two frames."
    }, 
    {
        "setCurve() (AnimAttributes)": "setCurve(self,\n        index,\n        curve)\n\n\u00a0\n    \n\nReplace the current anim curve for an attribute with a new one. The \n  index parameter is the index of the attribute; and curve is an AnimCurve \n  instance.\n\nReturns: None"
    }, 
    {
        "setValue() (MultiView_Knob)": "setValue(s)\n\n\u00a0\n    \n\nInitialise from script s.\n\nReturns: True if succeeded, False otherwise\nTrue if successful, False if not.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "stereo (nukescripts)": null
    }, 
    {
        "setDefaultValue() (Array_Knob)": "setDefaultValue(self,\n        s)\n\n\u00a0\n    \n\n\nParameters:\n\ns - Sequence of floating-point values.\n\nReturns: None\nNone."
    }, 
    {
        "setValue() (Obsolete_Knob)": "setValue(self,\n        val,\n        chan)\n\n\u00a0\n    \n\nSets the value 'val' at channel 'chan'.\n\nReturns: bool\nTrue if successful, False if not.\nOverrides:\n        Knob.setValue\n(inherited documentation)"
    }, 
    {
        "stop() (ViewerWindow)": "stop(...)\n      Stop playing."
    }, 
    {
        "setEnable() (Channel_Knob)": "setEnable(self,\n        name)\n\n\u00a0\n    \n\nEnable a channel.\n\nParameters:\n\nname - The name of the channel to enable.\n\nReturns: None\nNone"
    }, 
    {
        "setValue() (Password_Knob)": "setValue(self,\n        val,\n        view='default')\n\n\u00a0\n    \n\nSet value of knob.\n\nParameters:\n\nval - The new value.\nview - Optional parameter specifying which view to set the value for. If\n          omitted, the value will be set for the default view.\n\nReturns: None\nNone\nOverrides:\n        Knob.setValue"
    }, 
    {
        "stop() (pyQtAppHelper)": "stop(self)\n\nsource\u00a0code"
    }, 
    {
        "setEnabled() (Knob)": "setEnabled(self,\n        enabled)\n\n\u00a0\n    \n\nEnable or disable the knob.\n\nParameters:\n\nenabled - True to enable the knob, False to disable it.\n\nReturns: None"
    }, 
    {
        "setValue() (Script_Knob)": "setValue(self,\n        cmd)\n\n\u00a0\n    \n\nSet the new command for this knob.\n\nParameters:\n\ncmd - String containing a TCL command.\n\nReturns: None\nNone.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "stopPerformanceTimers() (nuke)": "stopPerformanceTimers()\n      Stop keeping track of accumulated time on the performance timers, and\n      cease displaying the accumulated time in the DAG."
    }, 
    {
        "setEnabled() (MenuItem)": "setEnabled(self,\n        enabled)\n\n\u00a0\n    \n\nEnable or disable the item.\n\nParameters:\n\nenabled - True to enable the object; False to disable it.\n\nReturns: None"
    }, 
    {
        "setValue() (String_Knob)": "setValue(self,\n        val,\n        view='default')\n\n\u00a0\n    \n\nSet value of knob.\n\nParameters:\n\nval - The new value.\nview - Optional parameter specifying which view to set the value for. If\n          omitted, the value will be set for the default view.\n\nReturns: None\nNone\nOverrides:\n        Knob.setValue"
    }, 
    {
        "string() (View)": "string(self)\n\n\u00a0\n    \n\n\nReturns: Name of view\nName of view."
    }, 
    {
        "setExpression() (AnimationCurve)": "setExpression(self,\n        s)\n\n\u00a0\n    \n\nSet expression.\n\nParameters:\n\ns - A string containing the expression.\n\nReturns: None\nNone."
    }, 
    {
        "setValue() (Tab_Knob)": "setValue(self,\n        val,\n        chan)\n\n\u00a0\n    \n\nSets the value 'val' at channel 'chan'.\n\nReturns: bool\nTrue if successful, False if not.\nOverrides:\n        Knob.setValue\n(inherited documentation)"
    }, 
    {
        "String_Knob (nuke)": null
    }, 
    {
        "setExpression() (Array_Knob)": "setExpression(self,\n        expr,\n        channel=-1,\n        view=None)\n\n\u00a0\n    \n\nSet the expression for a knob. You can optionally specify a channel to\n  set the expression for.\n\nParameters:\n\nexpr - The new expression for the knob. This should be a string.\nchannel - Optional parameter, specifying the channel to set the expression \n          for. This should be an integer.\nview - Optional view parameter. Without, this command will set the \n          expression for the current view theinterface is displaying. Can \n          be the name of the view or the index.\n\nReturns: bool\nTrue if successful, False if not.\nOverrides:\n        Knob.setExpression"
    }, 
    {
        "setValue() (Text_Knob)": "setValue(self,\n        val,\n        chan)\n\n\u00a0\n    \n\nSets the value 'val' at channel 'chan'.\n\nReturns: bool\nTrue if successful, False if not.\nOverrides:\n        Knob.setValue\n(inherited documentation)"
    }, 
    {
        "StringTypes (types)": null
    }, 
    {
        "setExpression() (Knob)": "setExpression(self,\n        expr,\n        channel=-1,\n        view=None)\n\n\u00a0\n    \n\nSet the expression for a knob. You can optionally specify a channel to\n  set the expression for.\n\nParameters:\n\nexpr - The new expression for the knob. This should be a string.\nchannel - Optional parameter, specifying the channel to set the expression \n          for. This should be an integer.\nview - Optional view parameter. Without, this command will set the \n          expression for the current view theinterface is displaying. Can \n          be the name of the view or the index.\n\nReturns: bool\nTrue if successful, False if not."
    }, 
    {
        "setValue() (Unsigned_Knob)": "setValue(self,\n        val)\n\n\u00a0\n    \n\nSet the unsigned integer value of this knob.\n\nParameters:\n\nval - The new value for the knob. Must be an integer >= 0.\n\nReturns: bool\nTrue if succeeded, False otherwise.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "stripFrameRange() (nuke)": "stripFrameRange(clipname)\n\n\u00a0\n    \n\nStrip out the frame range from a clipname, leaving a file path (still \n  possibly with variables).\n\nParameters:\n\nclipname - The clipname.\n\nReturns: string\nThe name without the frame range."
    }, 
    {
        "setExtraMatrixAnimCurve() (AnimCTransform)": "setExtraMatrixAnimCurve(self,\n        i,\n        j,\n        animcurve,\n        view)\n      Sets the AnimCurve object for the '4i+j'-th element of the extra \n      matrix.The view parameter is optional"
    }, 
    {
        "setValueAt() (Array_Knob)": "setValueAt(self,\n        value,\n        time,\n        index,\n        view)\n\n\u00a0\n    \n\nSet value of element 'index' at time for view. If the knob is \n  animated, it will set a new keyframe or change an existing one. Index and\n  view are optional. Return True if successful.\n\nParameters:\n\nvalue - Floating point value.\ntime - Time.\nindex - Optional index.\nview - Optional view.\n\nReturns: bool\nTrue if value changed, False otherwise. Safe to ignore.\nOverrides:\n        Knob.setValueAt"
    }, 
    {
        "Stroke (_curveknob)": null
    }, 
    {
        "setF() (Box3_Knob)": "setF(...)\n\n\u00a0\n    \n\nSet value for F extent. F (far) is the maximum Z extent of the \n  box."
    }, 
    {
        "setValueAt() (Knob)": "setValueAt(self,\n        val,\n        time,\n        chan)\n\n\u00a0\n    \n\nSets the value 'val' at channel 'chan' for time 'time'.\n\nReturns: bool\nTrue if successful, False if not."
    }, 
    {
        "SubmitModelCache (EndEditHint)": "SubmitModelCache\n\n\n\nValue:\n\nPySide.QtGui.QAbstractItemDelegate.EndEditHint.SubmitModelCache"
    }, 
    {
        "setFirst() (FrameRange)": "setFirst(self,\n        n)\n      set the first frame of the range."
    }, 
    {
        "setValues() (Enumeration_Knob)": "setValues(self,\n        items)\n\n\u00a0\n    \n\n(Re)initialise knob to the supplied list of items.\n\nParameters:\n\nitems - The new list of values.\n\nReturns: None\nNone. Example: w = nuke.nodes.Write() k = w['file_type'] \n          k.setValues(['exr'])"
    }, 
    {
        "subversion (sys)": "subversion = ('CPython', 'tags/r265', '36342M')"
    }, 
    {
        "setFlag() (Layer)": "setFlag(self,\n        flag,\n        value)\n\n\u00a0\n    \n\nSet a particular flag. The flag parameter specifies which flag to set \n  and should be one of the constants from the FlagType class. The value \n  parameter is a boolean value; True will set the flag, False will clear \n  it.\n\nReturns: None"
    }, 
    {
        "setValues() (Pulldown_Knob)": "setValues(self,\n        items)\n\n\u00a0\n    \n\n(Re)initialise knob to the list of items.\n\nParameters:\n\nitems - Dictionary of name/value pairs.\nsort - Optional parameter as to whether to sort the names.\n\nReturns: None\nNone. Example: w = nuke.nodes.NoOp() k = \n          nuke.Pulldown_Knob('kname', 'klabel') \n          k.setValues({'label/command' : 'eval(\"3*2\")'}) \n          w.addKnob(k) k = w['kname']\nOverrides:\n        Enumeration_Knob.setValues"
    }, 
    {
        "supports_unicode_filenames (posixpath)": "supports_unicode_filenames = False"
    }, 
    {
        "setFlag() (Shape)": "setFlag(self,\n        flag,\n        value)\n\n\u00a0\n    \n\nSet a particular flag. The flag parameter specifies which flag to set \n  and should be one of the constants from the FlagType class. The value \n  parameter is a boolean value; True will set the flag, False will clear \n  it.\n\nReturns: None"
    }, 
    {
        "setView() (OutputContext)": "setView(n)\n\n\u00a0\n    \n\nSet view number. The n argument is an integer in the range of 0 to \n  number of views.\n\nReturns: True"
    }, 
    {
        "swapAB() (nukescripts.misc)": "swapAB(n)\n      Swaps the first two inputs of a node.\n\nsource\u00a0code"
    }, 
    {
        "setFlag() (Stroke)": "setFlag(self,\n        flag,\n        value)\n\n\u00a0\n    \n\nSet a particular flag. The flag parameter specifies which flag to set \n  and should be one of the constants from the FlagType class. The value \n  parameter is a boolean value; True will set the flag, False will clear \n  it.\n\nReturns: None"
    }, 
    {
        "setView() (Root)": "setView(self,\n        s)\n\n\u00a0\n    \n\nSet view.\n\nParameters:\n\ns - Name of view.\n\nReturns: None\nNone."
    }, 
    {
        "setFlag() (Flag)": "setFlag(flag,\n        value)\n\n\u00a0\n    \n\nSet or clear the specified flag. The flag parameter should be one of \n  the FlagType constants and value should be True or False.\n\nReturns: None"
    }, 
    {
        "setView() (ViewerWindow)": "setView(self,\n        s)"
    }, 
    {
        "sysconf_names (os)": "sysconf_names\n\n\n\nValue:\n\n{'SC_2_CHAR_TERM': 95,\n 'SC_2_C_BIND': 47,\n 'SC_2_C_DEV': 48,\n 'SC_2_C_VERSION': 96,\n 'SC_2_FORT_DEV': 49,\n 'SC_2_FORT_RUN': 50,\n 'SC_2_LOCALEDEF': 52,\n 'SC_2_SW_DEV': 51,\n..."
    }, 
    {
        "T (re)": "T = 1"
    }, 
    {
        "title() (Panel)": "title(self)\n\n\u00a0\n    \n\nGet the current title for the panel.\n\nReturns: The title as a string\nThe title as a string."
    }, 
    {
        "tprint() (nuke)": "tprint(value,\n        sep=' ',\n        end='\\n',\n        file=sys.stdout,\n        ...)\n\n\u00a0\n    \n\nPrints the values to a stream, or to stdout by default.\n\nParameters:\n\nvalue - A python object\nfile - a file-like object (stream); defaults to stdout.\nsep - string inserted between values, default a space.\nend - string appended after the last value, default a newline.\n\nReturns: None\nNone"
    }, 
    {
        "t() (BBox_Knob)": null
    }, 
    {
        "TMP_MAX (os)": "TMP_MAX = 238328"
    }, 
    {
        "trackerlinkingdialog (nukescripts)": null
    }, 
    {
        "t() (Box)": null
    }, 
    {
        "TO_SCRIPT (nuke)": "TO_SCRIPT = 1"
    }, 
    {
        "Transform2d_Knob (nuke)": null
    }, 
    {
        "t() (Box3_Knob)": "t(...)\n\n\u00a0\n    \n\nReturn value for T extent. T (top) is the maximum vertical extent of \n  the box."
    }, 
    {
        "TO_VALUE (nuke)": "TO_VALUE = 2"
    }, 
    {
        "transformOrder (AnimCTransform)": "transformOrder\n      The order in which to perform the transformations."
    }, 
    {
        "t() (Format)": null
    }, 
    {
        "toByte() (Lut)": "toByte(self,\n        float)\n      Converts floating point values to byte values in the range 0-255."
    }, 
    {
        "transformOrder (CTransform)": "transformOrder\nIndicates which order to apply the transformations in. The value will \n  be one of the constants from the TransformOrder class."
    }, 
    {
        "Tab_Knob (nuke)": null
    }, 
    {
        "toByteSingle() (Lut)": "toByteSingle(self,\n        float)\n      Converts floating point values to byte values in the range 0-255."
    }, 
    {
        "TransformOrder (_curvelib)": null
    }, 
    {
        "TABBEGINCLOSEDGROUP (nuke)": "TABBEGINCLOSEDGROUP = 2"
    }, 
    {
        "toDict() (BBox_Knob)": "toDict(self)\n\n\u00a0\n    \n\nReturns the bounding box as a dict with x, y, r, and t keys.\n\nReturns: dict\ndict with x, y, r and t keys"
    }, 
    {
        "translate() (CMatrix4)": "translate(self,\n        x,\n        y,\n        z)\n      Post-multiply this matrix by a translation matrix."
    }, 
    {
        "TABBEGINGROUP (nuke)": "TABBEGINGROUP = 1"
    }, 
    {
        "toElement() (CurveKnob)": "toElement(self,\n        path)\n\n\u00a0\n    \n\nTakes a path which identifies a particular element in the curve tree \n  and returns the corresponding Layer, Stroke or Shape object. The path is \n  a slash separated string and is always resolved relative to the root \n  layer. So if, for example, you have a RotoPaint node with a layer called \n  'Layer1' which contains a shape called 'Shape1', the path to the shape \n  would be 'Layer1/Shape1'. >>> knob = \n  nuke.toNode('RotoPaint1)['curves'] >>> shape = \n  knob.toElement('Layer1/Shape1') >>> shape.name 'Shape1'\n\nReturns: Element"
    }, 
    {
        "translate() (Axis_Knob)": "translate(self)\n      Return translation knob."
    }, 
    {
        "tabClose() (nuke)": "tabClose(...)\n\n\u00a0\n    \n\nClose the active dock tab. Returns True if successful."
    }, 
    {
        "toFloat() (Lut)": "toFloat(src,\n        alpha)\n\n\u00a0\n    \n\nConvert a sequence of floating-point values to to_byte(x)/255. Alpha \n  is an optional argument and if present unpremultiply by alpha, convert, \n  and then multiply back.\n\nReturns: float list"
    }, 
    {
        "translate() (VertexSelection)": null
    }, 
    {
        "TABENDGROUP (nuke)": "TABENDGROUP = -1"
    }, 
    {
        "toFrameList() (FrameRanges)": "toFrameList()\n      return a list of frames in a vector"
    }, 
    {
        "translateRotateScaleSelectionToPoints() (nukescripts.snap3d)": "translateRotateScaleSelectionToPoints(nodeToSnap,\n        vertexSelection)\n\nsource\u00a0code"
    }, 
    {
        "TABKNOB (nuke)": "TABKNOB = 0"
    }, 
    {
        "toggle() (nukescripts.flags)": "toggle(knob)\n\nsource\u00a0code\u00a0\n    \n\n\"Inverts\" some flags on the selected nodes.\nWhat this really does is set all of them to the same value, by finding\n  the majority value and using the inverse of that."
    }, 
    {
        "translateRotateScaleThisNodeToPoints() (nukescripts.snap3d)": "translateRotateScaleThisNodeToPoints()\n\nsource\u00a0code"
    }, 
    {
        "TableDelegate (nukescripts.udim)": null
    }, 
    {
        "toggle_monitor_output() (nukescripts.misc)": "toggle_monitor_output()\n      Toggles monitor output (switches it on if it's off, or vice versa) \n      for the currently active viewer.\n\nsource\u00a0code"
    }, 
    {
        "translateRotateScaleToPoints() (nukescripts.snap3d)": "translateRotateScaleToPoints(nodeToSnap)\n\nsource\u00a0code\u00a0\n    \n\nTranslate the specified node to the average position of the current \n  vertex selection in the active viewer, rotate to the orientation of the \n  (mean squares) best fit plane for the selection and scale to the extents \n  of the selection. The nodeToSnap must contain 'translate', 'rotate' and \n  'scale' knobs, the transform order must be 'SRT' and the rotation order \n  must be 'ZXY'.\n\nParameters:\n\nnodeToSnap (nuke.Node) - Node to translate, rotate and scale"
    }, 
    {
        "tabNext() (nuke)": "tabNext(...)\n\n\u00a0\n    \n\nMake the next tab in this dock active. Returns True if successful."
    }, 
    {
        "toggleFullscreen() (nuke)": "toggleFullscreen()\n\n\u00a0\n    \n\nToggles between windowed and fullscreen mode.\n\nReturns: None\nNone"
    }, 
    {
        "translateRotateScaleToPointsVerified() (nukescripts.snap3d)": "translateRotateScaleToPointsVerified(nodeToSnap,\n        vertexSelection)\n\nsource\u00a0code"
    }, 
    {
        "tcl() (nuke)": "tcl(s,\n        *args)\n\n\u00a0\n    \n\nRun a tcl command. The arguments must be strings and passed to the \n  command. If no arguments are given and the command has whitespace in it \n  then it is instead interpreted as a tcl program (this is deprecated).\n\nParameters:\n\ns - TCL code.\nargs - The arguments to pass in to the TCL code.\n\nReturns: str\nResult of TCL command as string."
    }, 
    {
        "toggleMouseTrails() (Viewer)": "toggleMouseTrails(f)\n      Determine whether frame /f/ is known to be in the memory cache."
    }, 
    {
        "translateRotateSelectionToPoints() (nukescripts.snap3d)": "translateRotateSelectionToPoints(nodeToSnap,\n        vertexSelection)\n\nsource\u00a0code"
    }, 
    {
        "TEMPLATE (re)": "TEMPLATE = 1"
    }, 
    {
        "toggleViewers() (nuke)": "toggleViewers()\n\n\u00a0\n    \n\nToggles all the viewers on and off.\n\nReturns: None\nNone"
    }, 
    {
        "translateRotateThisNodeToPoints() (nukescripts.snap3d)": "translateRotateThisNodeToPoints()\n\nsource\u00a0code"
    }, 
    {
        "terminate() (pyAppHelper)": "terminate(self)\n      Terminated the thread associated with this object\n\nsource\u00a0code"
    }, 
    {
        "toNode() (nuke)": "toNode(s)\n\n\u00a0\n    \n\nSearch for a node in the DAG by name and return it as a Python \n  object.\n\nParameters:\n\ns - Node name.\n\nReturns: Node\nNode or None if it does not exist."
    }, 
    {
        "translateRotateToPoints() (nukescripts.snap3d)": "translateRotateToPoints(nodeToSnap)\n\nsource\u00a0code\u00a0\n    \n\nTranslate the specified node to the average position of the current \n  vertex selection in the active viewer and rotate to the orientation of \n  the (mean squares) best fit plane for the selection. The nodeToSnap must \n  contain 'translate' and 'rotate' knobs, the transform order must be 'SRT'\n  and the rotation order must be 'ZXY'.\n\nParameters:\n\nnodeToSnap (nuke.Node) - Node to translate and rotate"
    }, 
    {
        "Text_Knob (nuke)": null
    }, 
    {
        "ToolBar (nuke)": null
    }, 
    {
        "translateRotateToPointsVerified() (nukescripts.snap3d)": "translateRotateToPointsVerified(nodeToSnap,\n        vertexSelection)\n\nsource\u00a0code"
    }, 
    {
        "textFontPulldown (nukescripts.panel_test)": null
    }, 
    {
        "toolbar() (nuke)": "toolbar(name,\n        create=True)\n\n\u00a0\n    \n\nFind and return the ToolBar object with the given name. The name of \n  the built-in nodes toolbar is 'Nodes'.\nA RuntimeException is thrown if not in GUI mode.\n\nParameters:\n\nname - The name of the toolbar to find or create.\ncreate - Optional parameter. True (the default value) will mean that a new\n          toolbar gets created if one with the given name couldn't be \n          found; False will  mean that no new toolbar will be \n          created.@return: The toolbar, or None if no toolbar was found and\n          'create' was False.\n\nReturns: ToolBar"
    }, 
    {
        "translateSelectionToPoints() (nukescripts.snap3d)": "translateSelectionToPoints(nodeToSnap,\n        vertexSelection)\n\nsource\u00a0code"
    }, 
    {
        "thisClass() (nuke)": "thisClass()\n\n\u00a0\n    \n\nGet the class name of the current node. This equivalent to calling \n  nuke.thisNode().Class(), only faster.\n\nReturns: None\nThe class name for the current node."
    }, 
    {
        "toolbar_sticky_note() (nukescripts.toolbars)": null
    }, 
    {
        "translateThisNodeToPoints() (nukescripts.snap3d)": "translateThisNodeToPoints()\n\nsource\u00a0code"
    }, 
    {
        "thisGroup() (nuke)": "thisGroup()\n\n\u00a0\n    \n\nReturns the current context Group node.\n\nReturns: Group\nThe group node."
    }, 
    {
        "toolbars (nukescripts)": null
    }, 
    {
        "translateToPoints() (nukescripts.snap3d)": "translateToPoints(nodeToSnap)\n\nsource\u00a0code\u00a0\n    \n\nTranslate the specified node to the average position of the current \n  vertex selection in the active viewer. The nodeToSnap must contain a \n  'translate' knob and the transform order must be 'SRT'.\n\nParameters:\n\nnodeToSnap (nuke.Node) - Node to translate"
    }, 
    {
        "thisKnob() (nuke)": "thisKnob()\n\n\u00a0\n    \n\nReturns the current context knob if any.\n\nReturns: Knob\nKnob or None"
    }, 
    {
        "toolsets (nukescripts)": null
    }, 
    {
        "translateToPointsVerified() (nukescripts.snap3d)": "translateToPointsVerified(nodeToSnap,\n        vertexSelection)\n\nsource\u00a0code"
    }, 
    {
        "thisNode() (nuke)": "thisNode()\n\n\u00a0\n    \n\nReturn the current context node.\n\nReturns: Node\nThe node."
    }, 
    {
        "tooltip() (Knob)": "tooltip(self)\n\n\u00a0\n    \n\n\nReturns: tooltip\ntooltip."
    }, 
    {
        "translation (CTransform)": "translation\n      The translation amounts, represented as a CVec3 object."
    }, 
    {
        "thisPane() (nuke)": "thisPane()\n\n\u00a0\n    \n\nReturns the active pane. This is only valid during a pane menu \n  callback or window layout restoration.\n\nReturns: the active pane\nThe active pane."
    }, 
    {
        "toScript() (AnimationCurve)": "toScript(self,\n        selected)\n\n\u00a0\n    \n\n\nParameters:\n\nselected - Optional parameter. If this is given and is True, then only \n          process the selected curves; otherwise convert all.\n\nReturns: str\nA string containing the curves."
    }, 
    {
        "translation() (CMatrix4)": "translation(self,\n        x,\n        y,\n        z)\n\n\u00a0\n    \n\nSet this matrix to be a translation matrix, replacing any existing \n  values.\nThis is different from other methods in this class as it replaces, \n  rather than multiplying by, the existing values in the matrix.\n\nReturns: None"
    }, 
    {
        "thisParent() (nuke)": "thisParent()\n\n\u00a0\n    \n\nReturns the current context Node parent.\n\nReturns: Node\nA node."
    }, 
    {
        "toScript() (Array_Knob)": "toScript(self,\n        quote,\n        context)\n\n\u00a0\n    \n\nReturn the value of the knob in script syntax.\n\nParameters:\n\nquote - Optional, default is False. Specify True to return the knob value\n          quoted in {}.\ncontext - Optional context, default is current, None will be \n          \"contextless\" (all views, all keys) as in a .nk file.\n\nReturns: String\nString.\nOverrides:\n        Knob.toScript"
    }, 
    {
        "transpose() (CMatrix4)": "transpose(self)\n      Transpose the matrix in-place."
    }, 
    {
        "thisView() (nuke)": "thisView()\n\n\u00a0\n    \n\nGet the name of the current view.\n\nReturns: str\nThe current view name as a string."
    }, 
    {
        "toScript() (Format_Knob)": "toScript(quote,\n        context=current)\n\n\u00a0\n    \n\nReturn the value of the knob in script syntax. Pass True for quote to \n  return results quoted in {}. Pass None for context to get results for all\n  views and key times (as stored in a .nk file).\n\nReturns: string\nOverrides:\n        Knob.toScript"
    }, 
    {
        "transpose() (nukescripts.snap3d)": "transpose(m)\n\nsource\u00a0code"
    }, 
    {
        "toScript() (Knob)": "toScript(quote,\n        context=current)\n\n\u00a0\n    \n\nReturn the value of the knob in script syntax. Pass True for quote to \n  return results quoted in {}. Pass None for context to get results for all\n  views and key times (as stored in a .nk file).\n\nReturns: string"
    }, 
    {
        "traversePluginPaths() (nukescripts.toolsets)": null
    }, 
    {
        "threaded_server() (nukescripts.clientserver)": null
    }, 
    {
        "toScript() (MultiView_Knob)": "toScript(quote,\n        context=current)\n\n\u00a0\n    \n\nReturn the value of the knob in script syntax. Pass True for quote to \n  return results quoted in {}. Pass None for context to get results for all\n  views and key times (as stored in a .nk file).\n\nReturns: string\nOverrides:\n        Knob.toScript"
    }, 
    {
        "treeHasError() (Node)": "treeHasError()\n\n\u00a0\n    \n\nTrue if the node or any in its input tree have an error, or False \n  otherwise.\nError state of the node and its input tree. Note that this will always\n  return false for viewers, which cannot generate their input trees.  \n  Instead, choose an input of the viewer (e.g. the active one), and call \n  treeHasError() on that.\n\nReturns: bool"
    }, 
    {
        "toScriptPrefix() (MultiView_Knob)": "toScriptPrefix(...)"
    }, 
    {
        "THREADS (nuke)": "THREADS = 16"
    }, 
    {
        "toScriptPrefixUserKnob() (MultiView_Knob)": "toScriptPrefixUserKnob(...)"
    }, 
    {
        "time (AnimCurveKey)": "time\n      The time this key is set at."
    }, 
    {
        "toUV() (Format)": "toUV(self,\n        x,\n        y)\n\n\u00a0\n    \n\nBack-transform an XY coordinate in the format's space into UV \n  space.\n\nParameters:\n\nx - The X coordinate.\ny - The Y coordinate.\n\nReturns: (u, v)\n[u, v]."
    }, 
    {
        "U (re)": "U = 32"
    }, 
    {
        "undoSize() (Undo)": "undoSize(...)\n      Number of undo's that can be done."
    }, 
    {
        "updateUIs (nuke.callbacks)": "updateUIs = {}"
    }, 
    {
        "udim (nukescripts)": null
    }, 
    {
        "undoTruncate() (Undo)": "undoTruncate(...)\n      Destroy any undo's greater or equal to n."
    }, 
    {
        "updateUIs (nuke)": "updateUIs = {}"
    }, 
    {
        "udim_group() (nukescripts.udim)": "udim_group(nodes)\n\nsource\u00a0code"
    }, 
    {
        "UNICODE (re)": "UNICODE = 32"
    }, 
    {
        "useExpression (AnimCurve)": "useExpression\n      Whether or not to use the expression string to calculate a value for \n      this curve."
    }, 
    {
        "udim_import() (nukescripts.udim)": "udim_import(udim_parsing_func=<function parseUdimFile at 0x7f9c4cb25050>,\n        udim_column_label='UDIM')\n\nsource\u00a0code\u00a0\n    \n\n\nImports a sequence of UDIM files and creates the node material tree needed.\n    This function simplifies the process of importing textures. It generates a tree of nodes which\n    adjusts the texture coordinates at rendering time for a model containing multiple texture tiles.     \n    In general a tile texture coordinate can be expressed with a single value(UDIM) or with a tuple(ST or UV). \n    The udim_import function can decode a UDIM number from a filename. \n    To determine the tile coordinate encoding for a generic filename convention, the udim_import script can use an \n    external parsing function.\n    \n    The redefined parsing function needs to decode a filename string and return the udim or the u,v tile coordinate\n    as an integer or tuple of integers. It should return None if the tile coordinate id can not be determined.       \n                   \n@param udim_parsing_func:   The parsing function. This parses a filename string and returns a tile id.\n@param udim_column_label:   The name of the column in the dialog box used to show the tile id.\n@return:                    None"
    }, 
    {
        "uniformScale() (Axis_Knob)": "uniformScale(self)\n      Return uniform scale knob."
    }, 
    {
        "USER_SET_SLOPE (nuke)": "USER_SET_SLOPE = 16"
    }, 
    {
        "UDIMErrorDialog (nukescripts.udim)": null
    }, 
    {
        "unregister() (ViewerProcess)": "unregister(...)\n\n\u00a0\n    \n\nnuke.ViewerProcess.unregister(name) -> None. Unregister a \n  ViewerProcess. This is a class method.\n\nParameters:\n\nname - Menu name.\n\nReturns:\nNone."
    }, 
    {
        "UserPresetsDeletePanel (nukescripts.nodepresets)": null
    }, 
    {
        "UDIMFile (nukescripts.udim)": null
    }, 
    {
        "unregister_viewers() (nukescripts.ViewerProcess)": null
    }, 
    {
        "UserPresetsLoadPanel (nukescripts.nodepresets)": null
    }, 
    {
        "UDIMOptionsDialog (nukescripts.udim)": null
    }, 
    {
        "Unsigned_Knob (nuke)": null
    }, 
    {
        "usingPerformanceTimers() (nuke)": "usingPerformanceTimers()\n      Return true if performance timers are in use."
    }, 
    {
        "udimStr() (nukescripts.udim)": "udimStr(s,\n        label)\n\nsource\u00a0code"
    }, 
    {
        "unsplitView() (Array_Knob)": "unsplitView(self,\n        view)\n\n\u00a0\n    \n\nUnsplit the view so that it shares a value with other views.\n\nParameters:\n\nview - Optional view. Default is current view.\n\nReturns: None\nNone."
    }, 
    {
        "utils (nuke)": null
    }, 
    {
        "Undo (nuke)": null
    }, 
    {
        "unsplitView() (String_Knob)": "unsplitView(self,\n        view)\n\n\u00a0\n    \n\nUnsplit the view so that it shares a value with other views.\n\nParameters:\n\nview - Optional view. Default is current view.\n\nReturns: None\nNone."
    }, 
    {
        "utils (nukescripts)": null
    }, 
    {
        "undo() (Undo)": "undo(...)\n      Undoes 0'th undo."
    }, 
    {
        "untitled (nuke)": "untitled = 'Untitled'"
    }, 
    {
        "uv2udim() (nukescripts.udim)": "uv2udim(uv)\n\nsource\u00a0code"
    }, 
    {
        "undo() (nuke)": "undo()\n\n\u00a0\n    \n\nPerform the most recent undo.\n\nReturns: None\nNone"
    }, 
    {
        "update_plugin_menu() (nukescripts.plugin_menu)": null
    }, 
    {
        "UV_Knob (nuke)": null
    }, 
    {
        "undoDescribe() (Undo)": "undoDescribe(...)\n      Return short description of undo n."
    }, 
    {
        "updateTableWidget() (UDIMOptionsDialog)": "updateTableWidget(self)\n\nsource\u00a0code"
    }, 
    {
        "undoDescribeFully() (Undo)": "undoDescribeFully(...)\n      Return long description of undo n."
    }, 
    {
        "updateUI() (nuke.callbacks)": "updateUI()\n\nsource\u00a0code"
    }, 
    {
        "validateFilename() (nuke.callbacks)": "validateFilename(filename)\n\nsource\u00a0code"
    }, 
    {
        "value() (String_Knob)": "value(self,\n        oc)\n\n\u00a0\n    \n\nGet the value of this knob as a string.\n\nParameters:\n\noc - Optional parameter specifying the output context.\n\nReturns: str\nString value.\nOverrides:\n        Knob.value"
    }, 
    {
        "version_down() (nukescripts.version)": "version_down()\n\nsource\u00a0code\u00a0\n    \n\nAll new version_down that uses the version_get/set functions. This \n  script takes the render version up one in selected iread/writes."
    }, 
    {
        "validateFilenames (nuke.callbacks)": "validateFilenames = {}"
    }, 
    {
        "value() (Tab_Knob)": "value(...)\n\n\u00a0\n    \n\nReturn value at the current frame for channel 'c'.\n\nOverrides:\n        Knob.value\n(inherited documentation)"
    }, 
    {
        "version_get() (nukescripts.version)": "version_get(string,\n        prefix,\n        suffix=None)\n\nsource\u00a0code\u00a0\n    \n\nExtract version information from filenames used by DD (and Weta, \n  apparently) These are _v# or /v# or .v# where v is a prefix string, in \n  our case we use \"v\" for render version and \"c\" for \n  camera track version. See the version.py and camera.py plugins for \n  usage."
    }, 
    {
        "validateFilenames (nuke)": "validateFilenames = {}"
    }, 
    {
        "value() (Text_Knob)": "value(...)\n\n\u00a0\n    \n\nReturn value at the current frame for channel 'c'.\n\nOverrides:\n        Knob.value\n(inherited documentation)"
    }, 
    {
        "version_info (sys)": "version_info = (2, 6, 5, 'final', 0)"
    }, 
    {
        "value (AnimCurveKey)": "value\n      The value for this key."
    }, 
    {
        "value() (Transform2d_Knob)": "value(oc)\n\n\u00a0\n    \n\nReturn transformation matrix. The argument oc is an OutputContext. \n  Both arguments are optional.\n\nReturns: matrix\nOverrides:\n        Knob.value"
    }, 
    {
        "version_latest() (nukescripts.version)": "version_latest()\n\nsource\u00a0code\u00a0\n    \n\nLike version_up, but only goes up to the highest numbered version that\n  exists.\nWorks on all selected Read nodes, or all Read nodes if nothing is \n  selected.\nDoes not modify Write nodes."
    }, 
    {
        "value() (Array_Knob)": "setValue(self,\n        value,\n        index,\n        time,\n        view)\n\n\u00a0\n    \n\nSafe to ignore. Set index to value at time and view.\n\nParameters:\n\nvalue - Floating point value.\nindex - Optional index.\ntime - Optional time.\nview - Optional view.\n\nReturns: True if value changed, False otherwise\nTrue if value changed, False otherwise. Safe to ignore.\nOverrides:\n        Knob.setValue"
    }, 
    {
        "value() (Unsigned_Knob)": "value(self)\n\n\u00a0\n    \n\nGet the value of this knob as an integer.\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: int\nint\nOverrides:\n        Knob.value"
    }, 
    {
        "version_set() (nukescripts.version)": "version_set(string,\n        prefix,\n        oldintval,\n        newintval)\n\nsource\u00a0code\u00a0\n    \n\nChanges version information from filenames used by DD (and Weta, \n  apparently) These are _v# or /v# or .v# where v is a prefix string, in \n  our case we use \"v\" for render version and \"c\" for \n  camera track version. See the version.py and camera.py plugins for \n  usage."
    }, 
    {
        "value() (Axis_Knob)": "value(self)\n\n\u00a0\n    \n\nReturn the transform matrix formed by combining the input knob values \n  for translate, rotate, scale, skew and pivot.\n\nReturns: _nukemath.Matrix4\nOverrides:\n        Knob.value"
    }, 
    {
        "value() (View)": "value(self)\n\n\u00a0\n    \n\n\nReturns: Value of view\nValue of view."
    }, 
    {
        "version_up() (nukescripts.version)": "version_up()\n\nsource\u00a0code\u00a0\n    \n\nAll new version_up that uses the version_get/set functions. This \n  script takes the render version up one in selected iread/writes."
    }, 
    {
        "value() (BBox_Knob)": "value(self,\n        index,\n        view,\n        time)\n\n\u00a0\n    \n\nReturn value for dimension 'i'\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: Floating point or List of floating point values (in case some are \n      different)\nFloating point or List of floating point values (in case some are\n          different).\nOverrides:\n        Knob.value"
    }, 
    {
        "value() (XYZ_Knob)": "value(n,\n        oc)\n\n\u00a0\n    \n\nReturn value for dimension n. The optional argument oc is an \n  OutputContext.\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: float\nFloating point or List of floating point values (in case some are\n          different).\nOverrides:\n        Knob.value"
    }, 
    {
        "VertexInfo (nukescripts.snap3d)": null
    }, 
    {
        "value() (Boolean_Knob)": "value(self)\n\n\u00a0\n    \n\nGet the boolean value for this knob.\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: bool\nTrue or False.\nOverrides:\n        Knob.value"
    }, 
    {
        "value() (XY_Knob)": "value(n,\n        oc)\n\n\u00a0\n    \n\nReturn value for dimension n. The optional argument oc is an \n  OutputContext.\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: float\nFloating point or List of floating point values (in case some are\n          different).\nOverrides:\n        Knob.value"
    }, 
    {
        "VertexSelection (nukescripts.snap3d)": null
    }, 
    {
        "value() (Box3_Knob)": "value(self,\n        index,\n        view,\n        time)\n\n\u00a0\n    \n\nReturn value for dimension 'i'\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: Floating point or List of floating point values (in case some are \n      different)\nFloating point or List of floating point values (in case some are\n          different).\nOverrides:\n        Knob.value"
    }, 
    {
        "value() (nuke)": "knob(name,\n        value,\n        getType,\n        getClass)\n\n\u00a0\n    \n\n\brief Returns or sets the entire state of a knob.\nEach individual control on a control panel is called a 'knob'. A \n  knob's name is a dot-separated list. An example of a fully-expanded name \n  of a knob is 'root.Group1.Blur1.size.w'. 'root' is the node name of the \n  outermost group, 'Group1' is a group inside that containing the blur \n  operator, 'Blur1' is the name of a blur operator, 'size' is the name of \n  the actual knob, and 'w' is the name of the 'field' (there are two fields\n  in a blur size, 'w' and 'h').\nYou can omit a lot of this because all knob names are figured out \n  relative to a 'current knob' and 'current node'. These are set depending \n  on the context of where the scripting is invoked. For menu items the \n  current node is the group that contained the menu, and there is no \n  current knob. For expressions typed into knob fields the current knob is \n  that knob and the current node is the node the knob belongs to.\nIf a name does not start with 'root' then a search upwards is done for\n  the first word in the name, first against the fields in the current knob,\n  then against the knobs in the current node, then against the nodes in the\n  group containing the current node (or in it if it is a group), on up to \n  the root.\nThe word 'this' means the current knob or the current node.\nThe word 'input' means the first (0 or B) input of a node. Ie \n  'Blur1.input' returns the node connected to the input of Blur1, while \n  'Blur1.input.input' returns the input of that node.\nIf you are getting the value for reporting to the user, you probably \n  want to use the value or expression commands.\nIf the getType argument is specified and is True, it will print out \n  the type of the knob rather than getting or setting the value. The type \n  is an integer, using the same list as addUserKnob.\nIf the getClass argument is specified and is True, it will print out \n  the type of the knob as a string, e.g. 'Int_Knob', 'Enumeration_Knob', \n  'XY_Knob'.\nIf both the getType and getClass arguments are present and are True, \n  getType takes precedence.\n\nParameters:\n\nname - The name of the knob.\nvalue - Optional argument. If this is present, the value will be stored \n          into the knob.\ngetType - Optional boolean argument. If True, return the class ID for the \n          knob instead of the knob itself. The class ID is an int.\ngetClass - Optional boolean argument. If True, return the class name for the\n          knob instead of the knob itself. The class name is a string.\n\nReturns: None"
    }, 
    {
        "View (nuke)": null
    }, 
    {
        "value() (Channel_Knob)": "value(self)\n\n\u00a0\n    \n\nGet the name of the selected channel.\n\nReturns: str\nThe name of the channel as a string.\nOverrides:\n        Knob.value"
    }, 
    {
        "valueAt() (Array_Knob)": "valueAt(self,\n        time,\n        index,\n        view)\n\n\u00a0\n    \n\nReturn value for this knob at specified time, optional index and \n  view.\n\nParameters:\n\ntime - Time.\nindex - Optional index. Default is 0.\nview - Optional view.\n\nReturns: Floating point or List of floating point values (in case some are \n      different)\nFloating point or List of floating point values (in case some are\n          different)."
    }, 
    {
        "view() (AnimationCurve)": "view(self)\n\n\u00a0\n    \n\nThe view this AnimationCurve object is associated with.\n\nReturns: String\nString."
    }, 
    {
        "value() (Enumeration_Knob)": "value(self)\n\n\u00a0\n    \n\nCurrent value.\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: String\nString. Example: w = nuke.nodes.Write() k = w['file_type'] \n          k.value()\nOverrides:\n        Knob.value"
    }, 
    {
        "values (EndEditHint)": "values\n\n\n\nValue:\n\n{'EditNextItem': PySide.QtGui.QAbstractItemDelegate.EndEditHint.EditNe\nxtItem,\n 'EditPreviousItem': PySide.QtGui.QAbstractItemDelegate.EndEditHint.Ed\nitPreviousItem,\n 'NoHint': PySide.QtGui.QAbstractItemDelegate.EndEditHint.NoHint,\n 'RevertModelCache': PySide.QtGui.QAbstractItemDelegate.EndEditHint.Re\nvertModelCache,\n 'SubmitModelCache': PySide.QtGui.QAbstractItemDelegate.EndEditHint.Su\n..."
    }, 
    {
        "view() (OutputContext)": "view()\n      Return view number."
    }, 
    {
        "value() (File_Knob)": "value(self)\n\n\u00a0\n    \n\nReturns the string on this knob, will be normalized to technical \n  notation if sequence (%4d).\n\nParameters:\n\noc - Optional parameter specifying the output context.\n\nReturns: String\nString.\nOverrides:\n        Knob.value"
    }, 
    {
        "values (DialogCode)": "values\n\n\n\nValue:\n\n{'Accepted': PySide.QtGui.QDialog.DialogCode.Accepted,\n 'Rejected': PySide.QtGui.QDialog.DialogCode.Rejected}"
    }, 
    {
        "view() (ViewerWindow)": "view(self)"
    }, 
    {
        "value() (Font_Knob)": "value(...)\n\n\u00a0\n    \n\nReturn value at the current frame for channel 'c'.\n\nOverrides:\n        Knob.value\n(inherited documentation)"
    }, 
    {
        "values (PaintDeviceMetric)": "values\n\n\n\nValue:\n\n{'PdmDepth': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDepth,\n 'PdmDpiX': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiX,\n 'PdmDpiY': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmDpiY,\n 'PdmHeight': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeight,\n 'PdmHeightMM': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmHeightM\nM,\n 'PdmNumColors': PySide.QtGui.QPaintDevice.PaintDeviceMetric.PdmNumCol\nors,\n..."
    }, 
    {
        "viewcount() (OutputContext)": "viewcount()\n      Return number of views."
    }, 
    {
        "value() (Format_Knob)": "value()\n\n\u00a0\n    \n\nReturn value of knob.\n\nReturns: Format\nOverrides:\n        Knob.value"
    }, 
    {
        "values (RenderFlag)": "values\n\n\n\nValue:\n\n{'DrawChildren': PySide.QtGui.QWidget.RenderFlag.DrawChildren,\n 'DrawWindowBackground': PySide.QtGui.QWidget.RenderFlag.DrawWindowBac\nkground,\n 'IgnoreMask': PySide.QtGui.QWidget.RenderFlag.IgnoreMask}"
    }, 
    {
        "VIEWER (nuke)": "VIEWER = 1"
    }, 
    {
        "value() (IArray_Knob)": "value(self,\n        index,\n        view,\n        time)\n\n\u00a0\n    \n\nReturn value of the array at position (x, y).\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: Floating point or List of floating point values (in case some are \n      different)\nFloating point or List of floating point values (in case some are\n          different).\nOverrides:\n        Knob.value"
    }, 
    {
        "values() (Enumeration_Knob)": "values(self)\n\n\u00a0\n    \n\nReturn list of items.\n\nReturns: List of strings\nList of strings. Example: w = nuke.nodes.Write() k = \n          w['file_type'] k.values()"
    }, 
    {
        "Viewer (nuke)": null
    }, 
    {
        "value() (Int_Knob)": "value(self)\n\n\u00a0\n    \n\nGet the integer value of this knob.\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: int\nThe value of this knob as an int.\nOverrides:\n        Knob.value"
    }, 
    {
        "values() (GlobalsEnvironment)": "values(...)"
    }, 
    {
        "ViewerProcess (nuke)": null
    }, 
    {
        "value() (Keyer_Knob)": "value(self,\n        outputCtx,\n        n)\n\n\u00a0\n    \n\nGet the value of argument n.\n\nParameters:\n\noutputCtx - The OutputContext to evaluate the argument in.\nn - The index of the argument to get the value of.\n\nReturns: float\nThe value of argument n.\nOverrides:\n        Knob.value"
    }, 
    {
        "vect() (Array_Knob)": "vect(self)\n\n\u00a0\n    \n\n\nReturns: List of knob values\nList of knob values."
    }, 
    {
        "ViewerProcess (nukescripts)": null
    }, 
    {
        "value() (Knob)": "value(...)\n      Return value at the current frame for channel 'c'."
    }, 
    {
        "ViewerWindow (nuke)": null
    }, 
    {
        "value() (Link_Knob)": "value()\n\n\u00a0\n    \n\nReturn value of knob.\n\nReturns: string\nOverrides:\n        Knob.value"
    }, 
    {
        "viewname() (OutputContext)": "viewname(n)\n\n\u00a0\n    \n\nReturn name of the view. The n argument is an integer in the range of \n  0 to number of views.\n\nReturns: string"
    }, 
    {
        "value() (MultiView_Knob)": "value(quote,\n        context=current)\n\n\u00a0\n    \n\nReturn the value of the knob in script syntax. Pass True for quote to \n  return results quoted in {}. Pass None for context to get results for all\n  views and key times (as stored in a .nk file).\n\nReturns: string\nOverrides:\n        Knob.value"
    }, 
    {
        "views() (nuke)": "execute(nameOrNode,\n        start,\n        end,\n        incr,\n        views,\n        continueOnError= False)\n\n\u00a0\n    \n\nexecute(nameOrNode, frameRangeSet, views, continueOnError = False) \n  -> None.\nExecute the named Write node over the specified frames.\nThere are two variants of this function. The first allows you to \n  specify the frames to write range by giving the start frame number, the \n  end frame number and the frame increment. The second allows you to \n  specify more complicated sets of frames by providing a sequence of \n  FrameRange objects.\nIf Nuke is run with the GUI up, this will pop up a progress meter. If \n  the user hits the cancel button this command will return 'cancelled' \n  error. If Nuke is run from the nuke command line (ie nuke was started \n  with the -t switch) execute() prints a text percentage as it progresses. \n  If the user types ^C it will aborting the execute() and return a \n  'cancelled' error.\n\nParameters:\n\nnameOrNode - A node name or a node object.\nstart - Optional start frame. Default is root.first_frame.\nend - Optional end frame. Default is root.last_frame.\nincr - Optional increment. Default is 1.\nviews - Optional list of views. Default is None, meaning \"all \n          views\".\n\nReturns: None\nNone"
    }, 
    {
        "value() (Obsolete_Knob)": "value(...)\n\n\u00a0\n    \n\nReturn value at the current frame for channel 'c'.\n\nOverrides:\n        Knob.value\n(inherited documentation)"
    }, 
    {
        "VERBOSE (re)": "VERBOSE = 64"
    }, 
    {
        "viewshort() (OutputContext)": "viewshort(n)\n\n\u00a0\n    \n\nReturn short name of the view. The n argument is an integer in the \n  range of 0 to number of views.\n\nReturns: string"
    }, 
    {
        "value() (Panel)": "addBooleanCheckBox(self,\n        name,\n        value)\n\n\u00a0\n    \n\nAdd a boolean check box knob to the panel.\n\nParameters:\n\nname - The name for the new knob.\nvalue - The initial value for the new knob.\n\nReturns: True if successful\nTrue if successful."
    }, 
    {
        "verifyNodeOrder() (nukescripts.snap3d)": "verifyNodeOrder(node,\n        knobName,\n        orderName)\n\nsource\u00a0code"
    }, 
    {
        "ViewView_Knob (nuke)": null
    }, 
    {
        "value() (Password_Knob)": "value(self)\n\n\u00a0\n    \n\nGet the value of this knob as a string.\n\nReturns: str\nString value.\nOverrides:\n        Knob.value"
    }, 
    {
        "verifyNodeToSnap() (nukescripts.snap3d)": "verifyNodeToSnap(nodeToSnap,\n        knobList)\n\nsource\u00a0code"
    }, 
    {
        "visible() (Knob)": "setVisible(self,\n        visible)\n\n\u00a0\n    \n\nShow or hide the knob.\n\nParameters:\n\nvisible - True to show the knob, False to hide it.\n\nReturns: None"
    }, 
    {
        "value() (Pulldown_Knob)": "value(self)\n\n\u00a0\n    \n\nCurrent value.\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: String\nString. Example: w = nuke.nodes.Write() k = w['file_type'] \n          k.value()\nOverrides:\n        Knob.value\n(inherited documentation)"
    }, 
    {
        "verifyVertexSelection() (nukescripts.snap3d)": "verifyVertexSelection(vertexSelection,\n        minLen)\n\nsource\u00a0code"
    }, 
    {
        "visible() (Layer)": "visible(self)\n\n\u00a0\n    \n\nCheck whether the layer is visible.\n\nReturns: bool\nTrue if visible, False if not."
    }, 
    {
        "value() (Scale_Knob)": "value(n,\n        oc)\n\n\u00a0\n    \n\nReturn value for dimension n. The optional argument oc is an \n  OutputContext.\n\nParameters:\n\nindex - Optional index. Default is 0.\nview - Optional view.\ntime - Optional time.\n\nReturns: float\nFloating point or List of floating point values (in case some are\n          different).\nOverrides:\n        Knob.value"
    }, 
    {
        "version (nukescripts)": null
    }, 
    {
        "value() (Script_Knob)": "value(self)\n\n\u00a0\n    \n\nGet the current command.\n\nParameters:\n\noc - Optional parameter specifying the output context.\n\nReturns: str\nThe current command as a string, or None if there is no current \n          command.\nOverrides:\n        Knob.value"
    }, 
    {
        "version (sys)": "version\n\n\n\nValue:\n\n'''2.6.5 (r265:36342M, May  5 2011, 16:43:13) \n[GCC 4.1.2 20080704 (Red Hat 4.1.2-46)]'''"
    }, 
    {
        "w (CVec4)": "w\n      The w coordinate."
    }, 
    {
        "WebBrowserKnob (nukescripts.pyQtExamples.webBrowser)": null
    }, 
    {
        "WNOHANG (os)": "WNOHANG = 1"
    }, 
    {
        "w() (Box)": "w(self)\n      Return width."
    }, 
    {
        "WebBrowserPanel (nukescripts.pyQtExamples.webBrowser)": null
    }, 
    {
        "WRITE_ALL (nuke)": "WRITE_ALL = 8"
    }, 
    {
        "w() (Info)": "w(self)\n      Return width."
    }, 
    {
        "WebBrowserWidget (nukescripts.pyQtExamples.webBrowser)": null
    }, 
    {
        "WRITE_NON_DEFAULT_ONLY (nuke)": "WRITE_NON_DEFAULT_ONLY = 16"
    }, 
    {
        "W_OK (os)": "W_OK = 2"
    }, 
    {
        "WH_Knob (nuke)": null
    }, 
    {
        "WRITE_USER_KNOB_DEFS (nuke)": "WRITE_USER_KNOB_DEFS = 4"
    }, 
    {
        "waitForThreadsToFinish() (nuke)": "waitForThreadsToFinish()\n\n\u00a0\n    \n\nReturns true if Nuke should wait for any Python threads to finish \n  before exitting.\n\nReturns: str\nTrue or False."
    }, 
    {
        "writeKnobs() (Node)": "writeKnobs(self,\n        i)\n\n\u00a0\n    \n\n\nReturn a tcl list. If TO_SCRIPT | TO_VALUE is not on, this is a simple list\nof knob names. If it is on, it is an alternating list of knob names\nand the output of to_script().\n\nFlags can be any of these or'd together:\n- nuke.TO_SCRIPT produces to_script(0) values\n- nuke.TO_VALUE produces to_script(context) values\n- nuke.WRITE_NON_DEFAULT_ONLY skips knobs with not_default() false\n- nuke.WRITE_USER_KNOB_DEFS writes addUserKnob commands for user knobs\n- nuke.WRITE_ALL writes normally invisible knobs like name, xpos, ypos\n\n@param i: The set of flags or'd together. Default is TO_SCRIPT | TO_VALUE.\n@return: String in .nk form.\n\n\n\nReturns: String in .nk form"
    }, 
    {
        "warning() (Knob)": "warning(self,\n        message)\n\n\u00a0\n    \n\n\nParameters:\n\nmessage - message to put a warning on the knob.\n\nReturns: None\nNone."
    }, 
    {
        "width() (Array_Knob)": "width(self)\n\n\u00a0\n    \n\n\nReturns: Width of array of values\nWidth of array of values."
    }, 
    {
        "writeKnobs() (PanelNode)": "writeKnobs(self,\n        i)\n\n\u00a0\n    \n\n\nReturn a tcl list. If TO_SCRIPT | TO_VALUE is not on, this is a simple list\nof knob names. If it is on, it is an alternating list of knob names\nand the output of to_script().\n\nFlags can be any of these or'd together:\n- nuke.TO_SCRIPT produces to_script(0) values\n- nuke.TO_VALUE produces to_script(context) values\n- nuke.WRITE_NON_DEFAULT_ONLY skips knobs with not_default() false\n- nuke.WRITE_USER_KNOB_DEFS writes addUserKnob commands for user knobs\n- nuke.WRITE_ALL writes normally invisible knobs like name, xpos, ypos\n\n@param i: The set of flags or'd together. Default is TO_SCRIPT | TO_VALUE.\n@return: String in .nk form.\n\n\n\nReturns: String in .nk form"
    }, 
    {
        "warning() (nuke)": "warning(message)\n\n\u00a0\n    \n\nPuts the message into the error console, treating it like a \n  warning.\n\nParameters:\n\nmessage - String parameter.\n\nReturns: None\nNone."
    }, 
    {
        "width() (Format)": "width(self)\n      Return the width of image file in pixels."
    }, 
    {
        "writeKnobs() (PythonPanel)": "writeKnobs(self,\n        flags)"
    }, 
    {
        "warnoptions (sys)": "warnoptions = []"
    }, 
    {
        "width() (IArray_Knob)": "width(self)\n\n\u00a0\n    \n\nReturn width of the array.\n\nReturns: Width of array of values\nWidth of array of values.\nOverrides:\n        Array_Knob.width"
    }, 
    {
        "WUNTRACED (os)": "WUNTRACED = 2"
    }, 
    {
        "WCONTINUED (os)": "WCONTINUED = 8"
    }, 
    {
        "width() (Node)": "width(self)\n\n\u00a0\n    \n\nWidth of the node.\n\nReturns: int\nint."
    }, 
    {
        "webBrowser (nukescripts.pyQtExamples)": null
    }, 
    {
        "width() (Panel)": "width(self)\n\n\u00a0\n    \n\nGet the width of the panel.\n\nReturns: The width as an int\nThe width as an int."
    }, 
    {
        "x (CVec2)": "__repr__(x)\n(Representation operator)\n\n\u00a0\n    \n\nrepr(x)\n\nOverrides:\n        object.__repr__"
    }, 
    {
        "x() (Box3_Knob)": "x(...)\n\n\u00a0\n    \n\nReturn value for X position. X is the minimum horizontal extent of the\n  box."
    }, 
    {
        "x_at() (WH_Knob)": "x_at(...)\n      Return value for X position at time 't'."
    }, 
    {
        "x (CVec3)": "__repr__(x)\n(Representation operator)\n\n\u00a0\n    \n\nrepr(x)\n\nOverrides:\n        object.__repr__"
    }, 
    {
        "x() (Format)": "toUV(self,\n        x,\n        y)\n\n\u00a0\n    \n\nBack-transform an XY coordinate in the format's space into UV \n  space.\n\nParameters:\n\nx - The X coordinate.\ny - The Y coordinate.\n\nReturns: (u, v)\n[u, v]."
    }, 
    {
        "X_OK (os)": "X_OK = 1"
    }, 
    {
        "x (CVec4)": "__repr__(x)\n(Representation operator)\n\n\u00a0\n    \n\nrepr(x)\n\nOverrides:\n        object.__repr__"
    }, 
    {
        "x() (Info)": "x()\n      Return left edge."
    }, 
    {
        "xpos() (Node)": "xpos(self)\n\n\u00a0\n    \n\n\nReturns: X position of node in node graph\nX position of node in node graph."
    }, 
    {
        "x (AnimationKey)": "x\n      The horizontal position of the point"
    }, 
    {
        "x() (Scale_Knob)": "x(oc)\n\n\u00a0\n    \n\nReturn value for x. The optional oc argument is an OutputContext\n\nReturns: float"
    }, 
    {
        "XY_Knob (nuke)": null
    }, 
    {
        "X (re)": "X = 64"
    }, 
    {
        "x() (WH_Knob)": "x(...)\n      Return value for X position."
    }, 
    {
        "XYZ_Knob (nuke)": null
    }, 
    {
        "x() (BBox_Knob)": "x(...)\n      Return value for X position."
    }, 
    {
        "x() (XYZ_Knob)": "x(oc)\n\n\u00a0\n    \n\nReturn value for x. The optional oc argument is an OutputContext\n\nReturns: float"
    }, 
    {
        "x() (Box)": "clampX(self,\n        x)\n      Return x restricted to pointing at a pixel in the box."
    }, 
    {
        "x() (XY_Knob)": "x(oc)\n\n\u00a0\n    \n\nReturn value for x. The optional oc argument is an OutputContext\n\nReturns: float"
    }, 
    {
        "y (CVec2)": "__add__(x,\n        y)\n      x+y"
    }, 
    {
        "y() (Box)": "clampY(self,\n        y)\n      Return y restricted to pointing at a pixel in the box."
    }, 
    {
        "y() (WH_Knob)": "y(...)\n      Return value for Y position."
    }, 
    {
        "y (CVec3)": "__add__(x,\n        y)\n      x+y"
    }, 
    {
        "y() (Box3_Knob)": "y(...)\n\n\u00a0\n    \n\nReturn value for Y position. Y is the minimum vertical extent of the \n  box."
    }, 
    {
        "y() (XYZ_Knob)": "y(oc)\n\n\u00a0\n    \n\nReturn value for y. The optional oc argument is an OutputContext\n\nReturns: float"
    }, 
    {
        "y (CVec4)": "__add__(x,\n        y)\n      x+y"
    }, 
    {
        "y() (Format)": "toUV(self,\n        x,\n        y)\n\n\u00a0\n    \n\nBack-transform an XY coordinate in the format's space into UV \n  space.\n\nParameters:\n\nx - The X coordinate.\ny - The Y coordinate.\n\nReturns: (u, v)\n[u, v]."
    }, 
    {
        "y() (XY_Knob)": "y(oc)\n\n\u00a0\n    \n\nReturn value for y. The optional oc argument is an OutputContext\n\nReturns: float"
    }, 
    {
        "y (AnimationKey)": "y\n      The vertical position of the point"
    }, 
    {
        "y() (Info)": "y(self)\n      Return the bottom edge."
    }, 
    {
        "y_at() (WH_Knob)": "y_at(...)\n      Return value for Y position at time 't'."
    }, 
    {
        "y() (BBox_Knob)": "y(...)\n      Return value for Y position."
    }, 
    {
        "y() (Scale_Knob)": "y(oc)\n\n\u00a0\n    \n\nReturn value for y. The optional oc argument is an OutputContext\n\nReturns: float"
    }, 
    {
        "ypos() (Node)": "ypos(self)\n\n\u00a0\n    \n\n\nReturns: Y position of node in node graph\nY position of node in node graph."
    }, 
    {
        "z (CVec3)": "z\n      The z coordinate."
    }, 
    {
        "z() (Scale_Knob)": "z(oc)\n\n\u00a0\n    \n\nReturn value for z. The optional oc argument is an OutputContext\n\nReturns: float"
    }, 
    {
        "zoom() (nuke)": "zoom(scale,\n        center,\n        group)\n\n\u00a0\n    \n\nChange the zoom and pan of a group's display. The scale argument is \n  the new zoom factor. If the scale is given, but not the center, the zoom \n  is set to that factor and the view is positioned so the cursor is \n  pointing at the same place it was before zooming. A zero or negative \n  scale value will cause a zoom-to-fit.\nIf both scale and center arguments are given, the view is zoomed and \n  then centered on the specified point.\nThe new scale factor will be returned, or None if the function is run \n  in a non-GUI context.\n\nParameters:\n\nscale - New zoom factor.\ncenter - Optional 2-item tuple specifying the center coordinates.\ngroup - Optional Group. This is ignored at present.\n\nReturns: float\nCurrent zoom factor or None if not in a GUI context."
    }, 
    {
        "z (CVec4)": "z\n      The z coordinate."
    }, 
    {
        "z() (XYZ_Knob)": "z(oc)\n\n\u00a0\n    \n\nReturn value for z. The optional oc argument is an OutputContext\n\nReturns: float"
    }, 
    {
        "zoomToFitSelected() (nuke)": "zoomToFitSelected()\n\n\u00a0\n    \n\nDoes a zoom to fit on the selected nodes in the DAG\n\nReturns: None\nNone."
    }
]